{
  //────────────────────────────────────────────────────
  // 楽をする・STL的な
  //────────────────────────────────────────────────────
  "yn": {
    "prefix": "yn",
    "body": "puts ${1:condition} ? \"Yes\" : \"No\"",
    "description": "yesno"
  },
  "ComplexInt": {
    "prefix": "ComplexInt",
    "body": [
      "struct ComplexInt",
      "  getter real : Int64",
      "  getter imag : Int64",
      "",
      "  def initialize",
      "    @real = 0_i64",
      "    @imag = 0_i64",
      "  end",
      "",
      "  def self.zero; ComplexInt.new end",
      "",
      "  def initialize(@real : Int64, @imag : Int64)",
      "  end",
      "",
      "  def r; Math.sqrt((@real**2 + @imag**2).to_f64) end",
      "  def theta; Math.atan2(@real.to_f64, @imag.to_f64) end",
      "",
      "  def + : self; self end",
      "  def - : self; ComplexInt.new(-@real, -@imag) end",
      "",
      "  def +(other : self); ComplexInt.new(@real + other.real, @imag + other.imag) end",
      "  def -(other : self); ComplexInt.new(@real - other.real, @imag - other.imag) end",
      "  def *(other : self); ComplexInt.new(@real*other.real - @imag*other.imag, @real*other.imag + @imag*other.real) end",
      "  def /(other : self); self * ComplexInt.new(other.real, -other.imag) / (other.real**2 + other.imag**2) end",
      "",
      "  def +(other : Int); ComplexInt.new(@real + other, @imag) end",
      "  def -(other : Int); ComplexInt.new(@real - other, @imag) end",
      "  def *(other : Int); ComplexInt.new(@real*other, @imag*other) end",
      "  def /(other : Int); ComplexInt.new(@real / other, @imag / other) end",
      "  def //(other : Int); ComplexInt.new(@real // other, @imag // other) end",
      "",
      "  def <=>(other : self); {@real, @imag} <=> {other.real, other.imag} end",
      "end",
      "alias C = ComplexInt"
    ],
    "description": "ComplexInt"
  },
  "make_array": {
    "prefix": "make_array",
    "body": [
      "macro make_array(s, x)",
      "  Array.new({{ s[0] }}){",
      "    {% if s[1..s.size].empty? %}; {{ x }}",
      "    {% else %}; make_array({{ s[1..s.size] }}, {{ x }}) {% end %}",
      "  }",
      "end"
    ],
    "description": "make_array"
  },
  "座標圧縮": {
    "prefix": ["zaatu", "compress", "mapping"],
    "body": [
      "class Array(T)",
      "  def compress",
      "    b = clone.sort.uniq",
      "    map{ |s| b.bsearch_index{ |x| x >= s } || b.size }",
      "  end",
      "",
      "  def mapping",
      "    b = clone.sort.uniq",
      "    f, g = Hash(Int64, Int64).new, Hash(Int64, Int64).new",
      "    each do |s|",
      "      index = b.bsearch_index{ |x| x >= s } || b.size",
      "      f[s] = index",
      "      g[index] = s",
      "    end",
      "    {f, g}",
      "  end",
      "end"
    ],
    "description": "座標圧縮"
  },
  "next_permutation": {
    "prefix": ["next_permutation", "prev_permutation"],
    "body": [
      "class Array(T)",
      "  def next_permutation!",
      "    return nil if self.empty?",
      "",
      "    prev = self.last",
      "    i = self.rindex{ |v| v < prev || (prev = v; false) }",
      "",
      "    unless i",
      "      self.reverse!",
      "      return nil",
      "    end",
      "",
      "    key = self[i]",
      "    j = self.rindex{ |v| v > key }.not_nil!",
      "    self.swap(i, j)",
      "    self[i+1..-1] = self[i+1..-1].reverse!",
      "    return self",
      "  end",
      "",
      "  def prev_permutation!",
      "    return nil if self.empty?",
      "",
      "    prev = self.last",
      "    i = self.rindex{ |v| v > prev || (prev = v; false) }",
      "",
      "    unless i",
      "      self.reverse!",
      "      return nil",
      "    end",
      "",
      "    key = self[i]",
      "    j = self.rindex{ |v| v < key }.not_nil!",
      "    self.swap(i, j)",
      "    self[i+1..-1] = self[i+1..-1].reverse!",
      "    return self",
      "  end",
      "end"
    ],
    "description": "next_permutation"
  },

  //────────────────────────────────────────────────────
  // 文字列
  //────────────────────────────────────────────────────
  "runLengthEncoding": {
    "prefix": "runLengthEncoding",
    "body": [
      "s.chars.slice_when{ |i, j| i != j }.map{ |a| { a[0], a.size} }.to_a"
    ],
    "description": "runLengthEncoding"
  },
  "z_algorithm": {
    "prefix": "z_algorithm",
    "body": [
      "class Array(T)",
      "  def z_algorithm",
      "    n = size",
      "    return [] of Int32 if n == 0",
      "    z = Array(Int32).new(n){ 0 }",
      "    z[0] = 0",
      "    i = 1",
      "    j = 0",
      "    while i < n",
      "      z[i] = (j + z[j] <= i) ? 0 : Math.min(j + z[j] - i, z[i - j])",
      "      while i + z[i] < n && self[z[i]] == self[i + z[i]]",
      "        z[i] += 1",
      "      end",
      "      j = i if j + z[j] < i + z[i]",
      "      i += 1",
      "    end",
      "    z[0] = n",
      "    z",
      "  end",
      "end",
      "",
      "class String",
      "  def z_algorithm",
      "    chars.z_algorithm",
      "  end",
      "end"
    ],
    "description": "z_algorithm"
  },

  //────────────────────────────────────────────────────
  // 探索
  //────────────────────────────────────────────────────
  "binary_search": {
    "prefix": "binary_search",
    "body": [
      "def binary_search(ac : Int64, wa : Int64, f : Proc(Int64, Bool))",
      "  while (ac - wa).abs > 1",
      "    wj = (ac + wa) >> 1",
      "    if f.call(wj); ac = wj",
      "    else; wa = wj end",
      "  end",
      "  ac",
      "end",
    ],
    "description": "binary_search"
  },

  //────────────────────────────────────────────────────
  // グラフ理論
  //────────────────────────────────────────────────────
  "Edge": {
    "prefix": "Edge",
    "body": [
      "struct Edge",
      "  getter to : Int64",
      "  getter weight : Int64",
      "  def initialize(@to : Int64, @weight : Int64); end",
      "end",
      "alias Edges = Array(Edge)",
      "alias Graph = Array(Edges)"
    ],
    "description": "重み付きグラフ"
  },
  "DijkstraGraph": {
    "prefix": "DijkstraGraph",
    "body": [
      "class DijkstraGraph",
      "  record Edge, target : Int32, weight : UInt64",
      "",
      "  # 基数ヒープ",
      "  class RadixHeap64(T)",
      "    @s : Int32",
      "    @last : UInt64",
      "    @bit : Int32",
      "    @vs : Array(Array({UInt64, T}))",
      "    @ms : Array(UInt64)",
      "",
      "    def initialize",
      "      @s = 0",
      "      @last = 0_u64",
      "      @bit = sizeof(UInt64) * 8",
      "      @vs = Array.new(@bit + 1){ Array({UInt64, T}).new }",
      "      @ms = Array.new(@bit + 1){ -1.to_u64! }",
      "    end",
      "",
      "    def empty? : Bool",
      "      @s == 0",
      "    end",
      "",
      "    def size : Int32",
      "      s",
      "    end",
      "",
      "    @[AlwaysInline]",
      "    def get_bit(x : UInt64) : UInt64",
      "      64_u64 - x.leading_zeros_count",
      "    end",
      "",
      "    def push(key : UInt64, val : T) : Nil",
      "      @s += 1",
      "      b = get_bit(key ^ @last)",
      "      @vs[b] << {key, val}",
      "      @ms[b] = Math.min(@ms[b], key)",
      "    end",
      "",
      "    def pop : {UInt64, T}",
      "      if @ms[0] == -1.to_u64!",
      "        idx = @ms.index{ |m| m != -1.to_u64! }.not_nil!",
      "        @last = @ms[idx]",
      "        @vs[idx].each do |v|",
      "          b = get_bit(v[0] ^ @last)",
      "          @vs[b] << v",
      "          @ms[b] = Math.min(@ms[b], v[0])",
      "        end",
      "        @vs[idx].clear",
      "        @ms[idx] = -1.to_u64!",
      "      end",
      "",
      "      @s -= 1",
      "      res = @vs[0].last",
      "      @vs[0].pop",
      "      @ms[0] = -1.to_u64! if @vs[0].empty?",
      "",
      "      res",
      "    end",
      "  end",
      "",
      "  getter size : Int32",
      "  getter graph : Array(Array(Edge))",
      "",
      "  # n 頂点 0 辺からなるグラフを作成します。",
      "  #",
      "  # ```",
      "  # graph = Dijkstra.new(n)",
      "  # ```",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @graph = Array.new(@size){ Array(Edge).new }",
      "  end",
      "",
      "  # 非負整数の重み w の辺 (u, v) を追加します。",
      "  #",
      "  # `directed` が `true` の場合、",
      "  # 無向グラフとみなして、両端から辺を生やします。",
      "  #",
      "  # ```",
      "  # graph = Dijkstra.new(n)",
      "  # graph.add_edge(u, v, w) # => (u) <---w---> (v)",
      "  # graph.add_edge(u, v, w, directed: false) # => (u) ----w---> (v)",
      "  # ```",
      "  def add_edge(u : Int, v : Int, w : Int, directed : Bool = true)",
      "    @graph[u.to_i32] << Edge.new(v.to_i32, w.to_u64)",
      "    @graph[v.to_i32] << Edge.new(u.to_i32, w.to_u64) if directed",
      "  end",
      "",
      "  # 全点対間の最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dists = graph.shortest_path",
      "  # dists # => [[0, 1, 3], [1, 0, 2], [1, 1, 0]]",
      "  # ```",
      "  def shortest_path",
      "    (0...@size).map{ |s| shortest_path(s) }",
      "  end",
      "",
      "  # 始点 `start` から各頂点への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(2)",
      "  # dist # => [3, 8, 0, 7, 1]",
      "  # ```",
      "  def shortest_path(start : Int)",
      "    dist = Array.new(@size){ OO }",
      "    dist[start] = 0_i64",
      "    next_node = RadixHeap64(Int32).new",
      "    next_node.push(0_u64, start.to_i32)",
      "",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          next_node.push(next_cost.to_u64, e.target)",
      "        end",
      "      end",
      "    end",
      "",
      "    dist",
      "  end",
      "",
      "  # 始点 `start` から終点 `dest` への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(start: 2, dest: 0)",
      "  # dist # => 12",
      "  # ```",
      "  def shortest_path(start : Int, dest : Int)",
      "    shortest_path(start)[dest]",
      "  end",
      "",
      "  # 始点 `start` から終点 `dest` への最短経路の一例を返します。",
      "  #",
      "  # ```",
      "  # route = graph.shortest_path_route(start: 2, dest: 0)",
      "  # route # => [2, 7, 1, 0]",
      "  # ```",
      "  def shortest_path_route(start, dest)",
      "    prev = impl_memo_route(start)",
      "",
      "    res = Array(Int32).new",
      "    now : Int32? = dest.to_i32",
      "    until now.nil?",
      "      res << now.not_nil!",
      "      now = prev[now]",
      "    end",
      "",
      "    res.reverse",
      "  end",
      "",
      "  # 経路復元のための「どこから移動してきたか」を",
      "  # メモした配列を返します。",
      "  private def impl_memo_route(start)",
      "    dist = Array.new(@size){ OO }",
      "    dist[start] = 0_i64",
      "    prev = Array(Int32?).new(@size){ nil }",
      "    next_node = RadixHeap64(Int32).new",
      "    next_node.push(0_u64, start.to_i32)",
      "",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          prev[e.target] = source",
      "          next_node.push(next_cost.to_u64, e.target)",
      "        end",
      "      end",
      "    end",
      "",
      "    prev",
      "  end",
      "end"
    ],
    "description": "DijkstraGraph"
  },
  "StronglyConnectedComponents": {
    "prefix": "StronglyConnectedComponents",
    "body": [
      "class StronglyConnectedComponents",
      "  alias Graph = Array(Array(Int64))",
      "",
      "  getter leader : Array(Int64)",
      "  getter graph : Graph",
      "  getter groups : Array(Array(Int64))",
      "  @n : Int64",
      "  @order : Array(Int64)",
      "  @fwd : Graph",
      "  @bwd : Graph",
      "  @closed : Array(Bool)",
      "",
      "  def initialize(@fwd : Graph)",
      "    @n = @fwd.size.to_i64",
      "    @order = Array(Int64).new(@n)",
      "    @leader = Array.new(@n, -1_i64)",
      "    @bwd = Array.new(@n){ Array(Int64).new }",
      "    @n.times do |i|",
      "      @fwd[i].each do |j|",
      "        @bwd[j] << i",
      "      end",
      "    end",
      "",
      "    @closed = Array(Bool).new(@n, false)",
      "    @n.times{ |i| dfs(i) }",
      "    @order = @order.reverse",
      "    ptr = rdfs",
      "",
      "    @graph = Array.new(ptr){ Array(Int64).new }",
      "    @groups = Array.new(ptr){ Array(Int64).new }",
      "    @n.times do |i|",
      "      @groups[@leader[i]] << i",
      "      @fwd[i].each do |j|",
      "        x, y = @leader[i], @leader[j]",
      "        next if x == y",
      "        @graph[x] << y",
      "      end",
      "    end",
      "  end",
      "",
      "  def same(u : Int, v : Int)",
      "    leader[u] == leader[v]",
      "  end",
      "",
      "  def size",
      "    @groups.size",
      "  end",
      "",
      "  def size(v : Int)",
      "    @groups[leader[v]].size",
      "  end",
      "",
      "  private def dfs(i : Int)",
      "    return if @closed[i]",
      "    @closed[i] = true",
      "    @fwd[i].each{ |j| dfs(j) }",
      "    @order << i",
      "  end",
      "",
      "  private def rdfs",
      "    ptr = 0_i64",
      "    closed = Array.new(@n, false)",
      "    @order.each do |s|",
      "      next if closed[s]",
      "      que = Deque(Int64).new",
      "      que << s",
      "      closed[s] = true",
      "      @leader[s] = ptr",
      "      until que.empty?",
      "        now = que.shift",
      "        @bwd[now].each do |nxt|",
      "          next if closed[nxt]",
      "          closed[nxt] = true",
      "          @leader[nxt] = ptr",
      "          que << nxt",
      "        end",
      "      end",
      "      ptr += 1",
      "    end",
      "    ptr",
      "  end",
      "end"
    ],
    "description": "StronglyConnectedComponents"
  },
  "LCA": {
    "prefix": "LCA",
    "body": [
      "class LCA",
      "  alias Graph = Array(Array(Int64))",
      "  getter parent : Array(Array(Int64))",
      "  getter dist : Array(Int64)",
      "  @graph : Graph",
      "",
      "  def initialize(@graph : Graph, root = 0_i64)",
      "    n = graph.size",
      "    k = 1_i64",
      "    while ((1_i64 << k) < n)",
      "      k += 1",
      "    end",
      "",
      "    @parent = Array.new(k){ Array.new(n, -1_i64) }",
      "    @dist = Array.new(n, OO)",
      "    dfs(root, -1_i64, 0_i64)",
      "    (k - 1).times do |i|",
      "      n.times do |v|",
      "        if @parent[i][v] < 0",
      "          @parent[i + 1][v] = -1",
      "        else",
      "          @parent[i + 1][v] = @parent[i][@parent[i][v]]",
      "        end",
      "      end",
      "    end",
      "  end",
      "",
      "  def ancestor(u : Int, v : Int) : Int64",
      "    if @dist[u] < @dist[v]",
      "      u, v = v, u",
      "    end",
      "    n = @parent.size",
      "    n.times do |k|",
      "      u = @parent[k][u] if (dist[u] - dist[v]) >> k & 1 > 0",
      "    end",
      "    return u if u == v",
      "    n.times do |k|",
      "      if @parent[n-k-1][u] != @parent[n-k-1][v]",
      "        u, v = @parent[n-k-1][u], @parent[n-k-1][v]",
      "      end",
      "    end",
      "    @parent[0][u]",
      "  end",
      "",
      "  def distanceBetween(u : Int, v : Int) : Int64",
      "    dist[u] + dist[v] - dist[ancestor(u, v)] * 2",
      "  end",
      "",
      "  def on_path?(u : Int, v : Int, a : Int) : Bool",
      "    distanceBetween(u, a) + distanceBetween(a, v) == distanceBetween(u, v)",
      "  end",
      "",
      "  private def dfs(root : Int64, par : Int64, d : Int64)",
      "    @parent[0][root] = par",
      "    @dist[root] = d",
      "    @graph[root].each do |child|",
      "      dfs(child, root, d + 1) unless child == par",
      "    end",
      "  end",
      "end"
    ],
    "description": "LCA"
  },
  "Grid": {
    "prefix": "Grid",
    "body": [
      "class Grid",
      "  include Enumerable(Char)",
      " ",
      "  UP = {-1_i64, 0_i64}",
      "  LEFT = {0_i64, -1_i64}",
      "  DOWN = {1_i64, 0_i64}",
      "  RIGHT = {0_i64, 1_i64}",
      "  DYDX4 = [UP, LEFT, DOWN, RIGHT]",
      "",
      "  def self.add(v1 : {Int, Int}, v2 : {Int, Int}); {v1[0] + v2[0], v1[1] + v2[1]} end",
      "  def self.sub(v1 : {Int, Int}, v2 : {Int, Int}); {v1[0] - v2[0], v1[1] - v2[1]} end",
      "",
      "  DYDX8 = [",
      "    UP,",
      "    add(UP, RIGHT),",
      "    RIGHT,",
      "    add(DOWN, RIGHT),",
      "    DOWN,",
      "    add(DOWN, LEFT),",
      "    LEFT,",
      "    add(UP, LEFT),",
      "  ]",
      "",
      "  alias Pii = {Int64, Int64}",
      "  getter h : Int64, w : Int64",
      "  getter s : Array(Array(Char))",
      "  getter delta : Array(Pii)",
      "  def self.dydx4(h, w, s : Array(Array(Char))); new h, w, s, DYDX4 end",
      "  def self.dydx4(h, w, s : Array(String)); new h, w, s, DYDX4 end",
      "  def self.dydx8(h, w, s : Array(Array(Char))); new h, w, s, dydx8 end",
      "  def self.dydx8(h, w, s : Array(String)); new h, w, s, DYDX8 end",
      "  def initialize(@h, @w, @s : Array(Array(Char)), @delta); end",
      "  def initialize(@h, @w, ss : Array(String), @delta); @s = ss.map{ |e| e.chars }.to_a end",
      "  def over?(pos) : Bool; pos[0] < 0 || pos[0] >= @h || pos[1] < 0 || pos[1] >= @w end",
      "  def over?(y, x) : Bool; y < 0 || y >= @h || x < 0 || x >= @w end",
      "  def barred?(pos); over?(pos[0], pos[1]) || s[pos[0]][pos[1]] == '#' end",
      "  def barred?(y : Int, x : Int); over?(y, x) || s[y][x] == '#' end",
      "  def free?(pos); !barred?(pos) end",
      "  def free?(y : Int, x : Int); !barred?(y, x) end",
      "  def each(& : Char ->); i = 0; while i < h; j = 0; while j < w; yield s[i][j]; j += 1; end; i += 1; end; end",
      "  def each_with_index(& : {Char, Pii} ->)",
      "    i = 0_i64; while i < h; j = 0_i64; while j < w; t = {s[i][j], {i, j}}; yield t; j += 1; end; i += 1 end",
      "  end",
      "  def each_neighbor(y : Int, x : Int)",
      "    i = 0",
      "    while i < @delta.size",
      "      res = {y + @delta[i][0], x + @delta[i][1]}",
      "      yield res unless barred?(res)",
      "      i += 1",
      "    end",
      "  end",
      "",
      "  def [](pos : {Int, Int}); s[pos[0]][pos[1]] end",
      "  def [](y : Int, x : Int); s[y][x] end",
      "  def []=(pos : {Int, Int}, c : Char); s[pos[0]][pos[1]] = c end",
      "  def []=(y : Int, x : Int, c : Char); s[y][x] = c end",
      "end"
    ],
    "description": "Grid"
  },
  "bfs": {
    "prefix": "bfs",
    "body": [
      "que = Deque(Int64).new [${1:start}]",
      "dist = Array.new(n){ |i| i == ${1:start} ? 0_i64 : OO }",
      "until que.empty?",
      "  from = que.shift",
      "  graph[from].select{ |v| dist[v] == OO }.each do |to|",
      "    dist[to] = dist[from] + 1",
      "    que << to",
      "  end",
      "end"
    ],
    "description": "bfs"
  },
  "mazebfs": {
    "prefix": "mazebfs",
    "body": [
      "que = Deque.new [{${1:sy}, ${2:sx}}]",
      "dist = Array.new(h){ |i| Array.new(w){ |j| {i, j} == {${1:sy}, ${2:sx}} ? 0_i64 : OO } }",
      "grid = Grid.dydx4(h, w, s)",
      "until que.empty?",
      "  y, x = que.shift",
      "  grid.each_neighbor(y, x) do |ny, nx|",
      "    next if dist[ny][nx] != OO",
      "    dist[ny][nx] = dist[y][x] + 1",
      "    que << {ny, nx}",
      "  end",
      "end"
    ],
    "description": "mazebfs"
  },
  "dfs": {
    "prefix": "dfs",
    "body": [
      "dfs = uninitialized Proc(Int64, Nil)",
      "dfs = ->(from : Int64) do",
      "  graph[from].each do |to|",
      "    next if ${1:closed[to]}",
      "    closed[to] = true",
      "    dfs.call(to)",
      "  end",
      "  nil",
      "end"
    ],
    "description": "dfs"
  },
  "ReRootingTree": {
    "prefix": "ReRootingTree",
    "body": [
      "class ReRootingTree(T)",
      "  @n : Int64",
      "  getter graph : Array(Array(Int64))",
      "  @dp : Array(Array(T))",
      "  @ans : Array(T)",
      "",
      "  @merge : T, Int64 -> T",
      "  @e : -> T",
      "  @g : T, Int64 -> T",
      "",
      "  def initialize(@n : Int64, @f : T, T -> T, @merge : T, T -> T, @e : -> T, @g : T, Int64 -> T)",
      "    @graph = Array.new(@n){ Array(Int64).new }",
      "    @dp = Array.new(@n){ Array(T).new }",
      "    @ans = Array.new(@n){ @e.call }",
      "  end",
      "",
      "  def add_branch(u : Int, v : Int)",
      "    @graph[u] << v",
      "    @graph[v] << u",
      "  end",
      "",
      "  def grow",
      "    @dp = Array.new(@n){ |v| Array(T).new(@graph[v].size){ @e.call } }",
      "",
      "    dfs(0_i64, -1_i64)",
      "    bfs(0_i64, @e.call, -1_i64)",
      "",
      "    @n.times do |i|",
      "      @graph[i].each_with_index do |v, j|",
      "        @ans[i] = @merge.call(@ans[i], @f.call(@dp[i][j], v))",
      "      end",
      "      @ans[i] = @g.call(@ans[i], i)",
      "    end",
      "  end",
      "",
      "  def harvest(i : Int) : T",
      "    @ans[i]",
      "  end",
      "",
      "  def harvest?(i : Int) : T?",
      "    @ans[i]?",
      "  end",
      "",
      "  private def dfs(subroot : Int64, par : Int64) : T",
      "    res = @e.call",
      "    @graph[subroot].each_with_index do |child, i|",
      "      next if child == par",
      "      @dp[subroot][i] = dfs(child, subroot)",
      "      res = @merge.call(res, @f.call(@dp[subroot][i], child))",
      "    end",
      "    @g.call(res, subroot)",
      "  end",
      "",
      "  private def bfs(subroot : Int64, dp_p : T, par : Int64)",
      "    deg = @graph[subroot].size",
      "    deg.times.each do |i|",
      "      if @graph[subroot][i] == par",
      "        @dp[subroot][i] = dp_p",
      "        break",
      "      end",
      "    end",
      "",
      "    dp_l = Array.new(deg + 1){ @e.call }",
      "    dp_r = Array.new(deg + 1){ @e.call }",
      "    deg.times{ |i| dp_l[i + 1] = @merge.call(dp_l[i], @f.call(@dp[subroot][i], @graph[subroot][i])) }",
      "    (1..deg).reverse_each{ |i| dp_r[i - 1] = @merge.call(dp_r[i], @f.call(@dp[subroot][i - 1], @graph[subroot][i - 1])) }",
      "",
      "    deg.times do |i|",
      "      child = @graph[subroot][i]",
      "      next if child == par",
      "      val = @merge.call(dp_l[i], dp_r[i + 1])",
      "      bfs(child, @g.call(val, subroot), subroot)",
      "    end",
      "  end",
      "end"
    ],
    "description": "ReRootingTree"
  },
  "CycleDetection": {
    "prefix": "CycleDetection",
    "body": [
      "# グラフに対して、閉路を検出します。",
      "#",
      "# 有向グラフと無向グラフの場合で閉路の定義が異なることに注意してください。",
      "# （有向グラフの定義で無向グラフ閉路検出すると、すべての辺が閉路を成すことになる）",
      "class CycleDetection",
      "  getter size : Int32",
      "  @graph : Array(Array(Int32))",
      "  getter directed : Bool",
      "",
      "  # n 頂点の有向グラフとして閉路検出します。",
      "  #",
      "  # ```",
      "  # graph = CycleDetection.directed(n)",
      "  # ```",
      "  def self.directed(n : Int)",
      "    new n, true",
      "  end",
      "",
      "  # n 頂点の無向グラフとして閉路検出します。",
      "  #",
      "  # ```",
      "  # graph = CycleDetection.undirected(n)",
      "  # ```",
      "  def self.undirected(n : Int)",
      "    new n, false",
      "  end",
      "",
      "  def initialize(n : Int, @directed : Bool)",
      "    @size = n.to_i32",
      "    @graph = Array.new(@size){ Array(Int32).new }",
      "  end",
      "",
      "  # 辺 (u, v) を追加します。",
      "  #",
      "  # ```",
      "  # graph = CycleDetection.undirected(n)",
      "  # graph.add_edge(0, 2)",
      "  # graph.add_edge(u, v)",
      "  # ```",
      "  def add_edge(u : Int, v : Int)",
      "    @graph[u] << v",
      "    @graph[v] << u unless @directed",
      "  end",
      "",
      "  # グラフに閉路が存在するなら `true` を返します。",
      "  #",
      "  # ```",
      "  # graph = CycleDetection.undirected(n)",
      "  # m.tiems{ u, v = ints -1; graph.add_edge(u, v) }",
      "  # graph.cyclic? # => true (or false)",
      "  # ```",
      "  def cyclic?",
      "    case @directed",
      "    when true",
      "      raise NotImplementedError.new(\"有向グラフの実装はまだしていません (cf. scrapbox)\")",
      "    when false",
      "      closed = Array.new(@size){ false }",
      "      @size.times do |i|",
      "        next if closed[i]",
      "        stack = Deque({Int32, Int32}).new",
      "        stack << {i, -1}",
      "        until stack.empty?",
      "          v, par = stack.pop",
      "          @graph[v].each do |c|",
      "            next if c == par",
      "            return true if @closed[c]",
      "            closed[c] = true",
      "            stack << {c, v}",
      "          end",
      "        end",
      "      end",
      "      return false",
      "    end",
      "  end",
      "",
      "  # 閉路を成している頂点のリストを返します。",
      "  #",
      "  # NOTE: ∞の字をしているときの処理に困っています。",
      "  #",
      "  # ```",
      "  # graph = CycleDetection.undirected(n)",
      "  # m.tiems{ u, v = ints -1; graph.add_edge(u, v) }",
      "  # graph.cyclic_nodes # => [[0, 3, 2], [1, 5]]",
      "  # ```",
      "  def cyclic_nodes",
      "    case @directed",
      "    when true",
      "      raise NotImplementedError.new(\"有向グラフの実装はまだしていません (cf. scrapbox)\")",
      "    when false",
      "      raise NotImplementedError.new(\"無向グラフの実装はまだしていません (cf. scrapbox)\")",
      "    end",
      "  end",
      "end"
    ],
    "description": "CycleDetection"
  },

  //────────────────────────────────────────────────────
  // 数学系
  //────────────────────────────────────────────────────
  "Combination": {
    "prefix": "Combination",
    "body": [
      "class Combination",
      "  @fact : Array(Int64)",
      "  @finv : Array(Int64)",
      "  @inv : Array(Int64)",
      "  @mod : Int64",
      "",
      "  def self.mod1000000007(max : Int64)",
      "    new max, 1000000007_i64",
      "  end",
      "",
      "  def self.mod998244353(max : Int64)",
      "    new max, 998244353_i64",
      "  end",
      "",
      "  def initialize(@max : Int64, @mod : Int64)",
      "    @fact = Array.new(@max + 1, 0_i64)",
      "    @finv = Array.new(@max + 1, 0_i64)",
      "    @inv = Array.new(@max + 1, 0_i64)",
      "    @fact[0] = @fact[1] = 1_i64",
      "    @finv[0] = @finv[1] = 1_i64",
      "    @inv[1] = 1_i64",
      "    (2_i64..@max.to_i64).each do |i|",
      "      @fact[i] = @fact[i - 1] * i % @mod",
      "      @inv[i] = @mod - @inv[@mod % i] * (@mod // i) % @mod",
      "      @finv[i] = @finv[i - 1] * @inv[i] % @mod",
      "    end",
      "  end",
      "",
      "  def calc(n : Int, r : Int) : Int64",
      "    if n < r",
      "      0_i64",
      "    elsif n < 0 || r < 0",
      "      0_i64",
      "    else",
      "      @fact[n] * (@finv[r] * @finv[n - r] % @mod) % @mod",
      "    end",
      "  end",
      "",
      "  def [](n : Int, r : Int)",
      "    calc(n, r)",
      "  end",
      "end"
    ],
    "description": "Combination"
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "def modinv(a : Int64, mod : Int64) : Int64",
      "  b = mod",
      "  u = 1_i64",
      "  v = 0_i64",
      "  until b == 0",
      "    t = a // b",
      "    a -= t * b",
      "    a, b = b, a",
      "    u -= t * v",
      "    u, v = v, u",
      "  end",
      "  u % mod",
      "end",
      "",
      "def modpow(a : Int64, n : Int64, mod : Int64) : Int64",
      "  res = 1_i64",
      "  until n == 0",
      "    res = res * a % mod if n.odd?",
      "    a = a * a % mod",
      "    n >>= 1",
      "  end",
      "  res",
      "end",
      "",
      "macro static_modint(modint, mod)",
      "  struct {{ modint }}  ",
      "    include Comparable({{ modint }})",
      "",
      "    MOD = {{ mod }}",
      "    getter val : Int64",
      "",
      "    delegate popcount, to: val",
      "    delegate trailing_zeros_count, to: val",
      "",
      "    def initialize",
      "      @val = 0",
      "    end",
      "",
      "    def initialize(@val : Int64)",
      "      @val %= {{ mod }}",
      "    end",
      "",
      "    def + : self; self end",
      "    def - : self; {{ modint }}.new -@val end",
      "",
      "    def +(other : self) : self; {{ modint }}.new @val + other.val end",
      "    def -(other : self) : self; {{ modint }}.new @val - other.val end",
      "    def *(other : self) : self; {{ modint }}.new @val * other.val end",
      "    def /(other : self) : self; {{ modint }}.new @val * other.inv.val end",
      "    def //(other : self) : self; self / other end",
      "",
      "    def +(other : Int) : self; {{ modint }}.new @val + other end",
      "    def -(other : Int) : self; {{ modint }}.new @val - other end",
      "    def *(other : Int) : self; {{ modint }}.new @val * other end",
      "    def **(other : Int) : self; self.pow(other.to_i64) end",
      "    def /(other : Int) : self; {{ modint }}.new @val * modinv(other.to_i64, {{ mod }}) end",
      "    def //(other : Int) : self; self / other end",
      "",
      "    def <=>(other : self) : Int32; @val <=> other.val end",
      "    ",
      "    def inv : self",
      "      {{ modint }}.new modinv(@val, {{ mod }})",
      "    end",
      "",
      "    def pow(n : Int64) : self",
      "      {{ modint }}.new modpow(@val, n, {{ mod }})",
      "    end",
      "",
      "    def abs : self",
      "      self",
      "    end",
      "",
      "    def zero? : Bool",
      "      @val == 0_i64",
      "    end",
      "",
      "    def self.zero : self",
      "      {{ modint }}.new 0_i64",
      "    end",
      "",
      "    def clone",
      "      {{ modint }}.new @val",
      "    end",
      "",
      "    def to_i; @val.to_i end",
      "    def to_i32; @val.to_i32 end",
      "    def to_i64; @val.to_i64 end",
      "    def to_s(io : IO); io << @val end",
      "    def inspect(io : IO); to_s(io) end",
      "  end",
      "",
      "  struct Int",
      "    def to_m",
      "      {{ modint }}.new self.to_i64",
      "    end",
      "",
      "    def +(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} + other.val end",
      "    def -(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} - other.val end",
      "    def *(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} * other.val end",
      "    def /(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} * other.inv.val end",
      "    def //(other : {{ modint }}) : {{ modint }}; self.to_i64 / other end",
      "  end",
      "end",
      "# static_modint(ModInt1000000007, 1_000_000_007_i64)",
      "static_modint(ModInt998244353, 998_244_353_i64)",
      "alias ModInt = ModInt998244353"
    ],
    "description": "modint"
  },
  "Prime": {
    "prefix": "Prime",
    "body": [
      "class Prime",
      "  getter capacity : Int64",
      "  @table : Array(Bool)",
      "  @osak : Array(Int64)",
      "  @list : Array(Int64)",
      "  getter pi : Array(Int64)  # n 以下の 素数の個数",
      "",
      "  def initialize(@capacity : Int64)",
      "    @table = Array.new(@capacity + 1, true)",
      "    @osak = (0_i64..@capacity).to_a",
      "    @pi = Array.new(@capacity + 1, 0_i64)",
      "    if @capacity >= 0; @table[0] = false end",
      "    if @capacity >= 1; @table[1] = false end",
      "",
      "    i = 1_i64",
      "    while i**2 <= @capacity",
      "      i += 1",
      "      @pi[i] = @pi[i - 1]",
      "      next unless @table[i]",
      "      k = 2_i64*i",
      "      while k <= @capacity",
      "        @table[k] = false",
      "        @osak[k] = i",
      "        k += i",
      "      end",
      "      @pi[i] += 1",
      "    end",
      "",
      "    @list = Array(Int64).new",
      "    (1..@capacity).each do |i|",
      "      @pi[i] = @pi[i - 1] + (@table[i] ? 1_i64 : 0_i64)",
      "      if @table[i]",
      "        @list.push(i.to_i64)",
      "      end",
      "    end",
      "  end",
      "",
      "  # 素数であれば `true` を返します。",
      "  #",
      "  # 計算量 : `O(1)` if n <= capacity else `O(sqrt(N))`",
      "  #",
      "  # ```",
      "  # PRIME.is? 0 # => false",
      "  # PRIME.is? 1 # => false",
      "  # PRIME.is? 2 # => true",
      "  # ```",
      "  def is?(n : Int) : Bool",
      "    if n <= @capacity",
      "      @table[n]",
      "    elsif n <= 4",
      "      n == 2 || n == 3",
      "    elsif n % 2 == 0 || n % 3 == 0 || (n % 6 != 1 && n % 6 != 5)",
      "      false",
      "    else",
      "      i = 5",
      "      ok = true",
      "      while i**2 <= n",
      "        if n % i == 0 || n % (i + 2) == 0",
      "          ok = false",
      "          break",
      "        end",
      "        i += 6",
      "      end",
      "      ok",
      "    end",
      "  end",
      "",
      "  # 素因数分解の結果をハッシュで返します。",
      "  # `p**a` の `p` がキーで `a` が値です",
      "  #",
      "  # 計算量 : `O(log(N))` if n <= capacity else `O(sqrt(N))`",
      "  #",
      "  # ```",
      "  # PRIME.factor? 24 # => { 2 => 3, 3 => 1 }",
      "  # ```",
      "  def factor(n : Int) : Hash(Int64, Int64)",
      "    return { 1_i64 => 1_i64 } if n == 1",
      "    return factor_fast_impl(n) if n <= @capacity",
      "    res = Hash(Int64, Int64).new(0_i64)",
      "    i = 2_i64",
      "    while i * i <= n",
      "      while n % i == 0",
      "        res[i] += 1",
      "        n //= i",
      "      end",
      "      i += 1",
      "    end",
      "    res[n] = 1 if n != 1",
      "    res",
      "  end",
      "",
      "  private def factor_fast_impl(n : Int) : Hash(Int64, Int64)",
      "    res = Hash(Int64, Int64).new(0_i64)",
      "    until n == 1",
      "      prime = @osak[n]",
      "      res[prime] += 1",
      "      n //= prime",
      "    end",
      "    res",
      "  end",
      "",
      "  # *enumerable* の値が互いに素であれば `true` を返します。",
      "  #",
      "  # 計算量 : `O(ary.size * log(ary.max))`",
      "  #",
      "  # ```",
      "  # PRIME.to? [2, 3, 5] # => true",
      "  # PRIME.to? [2, 3, 4] # => false",
      "  # ```",
      "  def to?(elems : Enumerable(Int64)) : Bool",
      "    s = Set(Int64).new",
      "    elems.each do |n|",
      "      until n == 1",
      "        prime = @osak[n]",
      "        return false if s.includes? prime",
      "        s << prime",
      "        while n % prime == 0",
      "          n //= prime",
      "        end",
      "      end",
      "    end",
      "    true",
      "  end",
      "end",
      "",
      "PRIME = Prime.new ${1:10_i64**7}",
      "struct Int",
      "  def prime?",
      "    PRIME.is? self",
      "  end",
      "",
      "  def factor",
      "    PRIME.factor(self)",
      "  end",
      "end"
    ],
    "description": "Prime"
  },
  "divisors": {
    "prefix": "divisors",
    "body": [
      "struct Int",
      "  def divisors",
      "    lo = Array(Int64).new",
      "    hi = Array(Int64).new",
      "    i = 1_i64",
      "    while i**2 <= self",
      "      if self % i == 0",
      "        j = self // i",
      "        lo << i",
      "        if i != j",
      "          hi << j",
      "        end",
      "      end",
      "      i += 1",
      "    end",
      "    lo + hi",
      "  end",
      "end"
    ],
    "description": "divisors"
  },
  "Vec2": {
    "prefix": "Vec2",
    "body": [
      "record Vec2, x : Float64, y : Float64 do",
      "  def self.zero; new 0.0, 0.0 end",
      "  def length; Math.sqrt(x**2 + y**2) end",
      "  def lengthSquare; self.dot(self) end",
      "  def dot(other : Vec2); x * other.x + y * other.y end",
      "  def corss(other : Vec2); x * other.x - y * other.y end",
      "  def distanceFrom(other : Vec2); (other - self).length end",
      "  def normalized; self / length end",
      "  def zero?; x == 0.0 && y == 0.0 end",
      "  def +; self end",
      "  def -; Vec2.new(-x, -y) end",
      "  def +(other : Vec2); Vec2.new(x + other.x, y + other.y) end",
      "  def -(other : Vec2); Vec2.new(x - other.x, y - other.y) end",
      "  def *(s); Vec2.new(x * s, y * s) end",
      "  def /(s); Vec2.new(x / s, y / s) end",
      "end"
    ],
    "description": "Vec2"
  },
  "Matrix": {
    "prefix": "Matrix",
    "body": [
      "class Matrix(T)",
      "  include Enumerable(T)",
      "",
      "  class DimensionError < Exception",
      "    def initialize(message = \"Dimension Error.\")",
      "      super(message)",
      "    end",
      "",
      "    def initialize(h, w)",
      "      super(\"Dimension Error: #{h}x#{w}.\")",
      "    end",
      "",
      "    def initialize(h1, w1, h2, w2)",
      "      super(\"Dimension Error: (#{h1}x#{w1}) (#{h2}x#{w2}).\")",
      "    end",
      "  end",
      "",
      "  getter m : Array(T)",
      "  @n_rows : Int32",
      "  @n_cols : Int32",
      "",
      "  def column_size; @n_cols end",
      "  def row_size; @n_rows end",
      "  def size; {@n_rows, @n_cols} end",
      "",
      "  def initialize",
      "    @m = Array(T).new",
      "    @n_rows, @n_cols = 0, 0",
      "  end",
      "",
      "  def initialize(h : Int, w : Int)",
      "    @m = Array.new(h * w){ T.zero }",
      "    @n_rows, @n_cols = h.to_i, w.to_i",
      "  end",
      "",
      "  def initialize(h : Int, w : Int, val : T)",
      "    @m = Array.new(h * w){ val }",
      "    @n_rows, @n_cols = h.to_i, w.to_i",
      "  end",
      "",
      "  def initialize(ary : Array(Array(T)))",
      "    ArgumentError.new(\"ary.size must be greater than or equal to 1\") if ary.size <= 0",
      "    @n_rows, @n_cols = ary.size, ary[0].size",
      "    @m = Array.new(@n_rows * @n_cols){ T.zero }",
      "    ary.each_with_index do |v, i|",
      "      v.each_with_index do |x, j|",
      "        @m[@n_cols * i + j] = x",
      "      end",
      "    end",
      "  end",
      "",
      "  def self.new(h : Int, w : Int, &block : Int32, Int32 -> T)",
      "    Matrix(T).new(h, w).tap do |mat|",
      "      i, j = 0, 0",
      "      (mat.column_size * mat.row_size).times do |index|",
      "        mat[index] = yield i, j",
      "        j += 1",
      "        if i == h",
      "          i = 0",
      "          j += 1",
      "        end",
      "        if j == w",
      "          i += 1",
      "          j = 0",
      "        end",
      "      end",
      "    end",
      "  end",
      "",
      "  def self.zero(h : Int, w : Int)",
      "    new h, w, T.zero",
      "  end",
      "",
      "  def self.identity(h : Int, w : Int)",
      "    raise DimensionError.new(h, w) if h != w",
      "    Matrix(T).new(h, w) do |i, j|",
      "      i == j ? T.new(1_i64) : T.zero",
      "    end",
      "  end",
      "",
      "  def clone",
      "    Matrix(T).new(@n_rows, @n_cols) do |i, j|",
      "      at(i, j).clone",
      "    end",
      "  end",
      "",
      "  def at(i : Int, j : Int) : T",
      "    i += @n_rows if i < 0",
      "    j += @n_cols if j < 0",
      "    IndexError.new if over(i, j)",
      "    @m[@n_cols * i + j]",
      "  end",
      "",
      "  def at?(i : Int, j : Int) : T?",
      "    i += @n_rows if i < 0",
      "    j += @n_cols if j < 0",
      "    over(i, j) ? nil : @m[@n_cols * i + j]",
      "  end",
      "",
      "  def [](i : Int, j : Int) : T; at(i, j) end",
      "  def []?(i : Int, j : Int) : T?; at?(i, j) end",
      "",
      "  def at(index : Int) : T; @m[index] end",
      "  def at?(index : Int) : T?; @m[index]? end",
      "  def [](index : Int) : T; at(index) end",
      "  def []?(index : Int) : T; at?(index) end",
      "",
      "  def []=(i : Int, j : Int, val : T) : T",
      "    i += @n_rows if i < 0",
      "    j += @n_cols if j < 0",
      "    IndexError.new if over(i, j)",
      "    @m[@n_cols * i + j] = val",
      "  end",
      "",
      "  def []=(index : Int, val : T) : T",
      "    @m[index] = val",
      "  end",
      "",
      "  def each(& : T ->)",
      "    @m.each{ |x| yield x }",
      "  end",
      "",
      "  def each_with_index(& : T, {Int32, Int32} ->)",
      "    @n_rows.times do |i|",
      "      @n_cols.times do |j|",
      "        yield @m[@n_cols * i + j], {i, j}",
      "      end",
      "    end",
      "  end",
      "",
      "  def push_row(v : Array(T))",
      "    raise DimensionError.new(@n_row, @n_cols) if @n_cols != v.size",
      "    @m.concat(v)",
      "    @n_cols += 1",
      "  end",
      "",
      "  def push_col(v : Array(T))",
      "    raise NotImplementedError.new",
      "  end",
      "",
      "  {% for op in %i(+ - ^ | &) %}",
      "    def {{ op.id }}(other : Matrix(U)) forall U",
      "      raise DimensionError.new(@n_rows, @n_cols, other.row_size, other.column_size) unless @n_rows == other.row_size && @n_cols == other.column_size",
      "      res = Matrix(T | U).new(@n_rows, @n_cols)",
      "      (@n_rows * @n_cols).times{ |i| res[i] = at(i) {{ op.id }} other.at(i) }",
      "      res",
      "    end",
      "  {% end %}",
      "  ",
      "  def *(other : Matrix(U)) forall U",
      "    r0 = @n_rows",
      "    c = @n_cols",
      "    c0 = other.column_size",
      "    raise DimensionError.new(r0, c, other.row_size, c0) if c != other.row_size",
      "    res = Matrix(T | U).new(r0, c0)",
      "    r0.times do |i|",
      "      c.times do |k|",
      "        c0.times do |j|",
      "          res[i, j] += at(i, k) * other.at(k, j)",
      "        end",
      "      end",
      "    end",
      "    res",
      "  end",
      "",
      "  def /(other : Matrix(U)) forall U",
      "    self * other.inv",
      "  end",
      "",
      "  {% for op in %i(* / //) %}",
      "    def {{ op.id }}(k : T)",
      "      res = Matrix(T).new(@n_rows, @n_cols)",
      "      (@n_rows * @n_cols).times do |index|",
      "        res[index] = at(index) {{ op.id }} k",
      "      end",
      "      res",
      "    end",
      "  {% end %}",
      "",
      "  {% for op in %i(+ -) %}",
      "    def {{ op.id }}(k : T)",
      "      res = Matrix(T).new(@n_rows, @n_cols)",
      "      (@n_rows * @n_cols).times do |index|",
      "        res[index] = {{ op.id }} at(index)",
      "      end",
      "      res",
      "    end",
      "  {% end %}",
      "",
      "  def **(k : Int); pow(k) end",
      "",
      "  def pow(k : Int)",
      "    if k < -1",
      "      inv.pow(k.abs)",
      "    elsif k == -1",
      "      inv",
      "    elsif k == 0",
      "      Matrix(T).identity(@n_rows, @n_cols)",
      "    elsif k == 1",
      "      clone",
      "    else",
      "      pow_impl(k)",
      "    end",
      "  end",
      "",
      "  private def pow_impl(k : Int)",
      "    res = Matrix(T).identity(@n_rows, @n_cols)",
      "    a = clone",
      "    until k == 0",
      "      res *= a if k.odd?",
      "      a *= a",
      "      k >>= 1",
      "    end",
      "    res",
      "  end",
      "",
      "  def det : T",
      "    raise DimensionError.new(@n_rows, @n_cols) if @n_cols != @n_cols",
      "    n = @n_rows",
      "    case n",
      "    when 1",
      "      at(0, 0)",
      "    when 2",
      "      at(0, 0) * at(0, 2) - at(0, 1) * at(1, 0)",
      "    else",
      "      # TODO: study performance",
      "      ary = to_a",
      "      res = T.new(1_i64)",
      "      n.times do |i|",
      "        idx = -1",
      "        (i...n).reverse_each do |j|",
      "          unless ary[j][i].zero?",
      "            idx = j",
      "            break",
      "          end",
      "        end",
      "        return T.zero if idx == -1",
      "        if i != idx",
      "          res = -res",
      "          ary.swap(i, idx)",
      "        end",
      "        res *= ary[i][i]",
      "        v = ary[i][i]",
      "",
      "        n.times do |j|",
      "          if v.is_a? Float",
      "            ary[i][j] /= v",
      "          else",
      "            ary[i][j] //= v",
      "          end",
      "        end",
      "",
      "        (i + 1...n).each do |j|",
      "          a = ary[j][i]",
      "          n.times do |k|",
      "            ary[j][k] -= ary[i][k] * a",
      "          end",
      "        end",
      "      end",
      "      res",
      "    end",
      "  end",
      "",
      "  def det?",
      "    return nil if @n_cols != @n_cols",
      "    det",
      "  end",
      "",
      "  def inv : Matrix(T)",
      "    raise DimensionError.new(@n_rows, @n_cols) if @n_rows != @n_cols",
      "    ary = to_a",
      "    n = @n_rows",
      "    res = Array.new(n){ |i| Array(T).new(n){ |j| i == j ? T.new(1_i64) : T.new(0_i64) }}",
      "    rank = 0",
      "    n.times do |j|",
      "      # TODO: language update",
      "      pivot = -1",
      "      mx = T.zero",
      "      (rank...n).each do |i|",
      "        if mx < ary[i][j].abs",
      "          mx = ary[i][j].abs",
      "          pivot = i",
      "        end",
      "      end",
      "      next if pivot == -1",
      "",
      "      ary.swap(pivot, rank)",
      "      res.swap(pivot, rank)",
      "",
      "      fac = ary[rank][j]",
      "      n.times do |k|",
      "        if fac.is_a? Float",
      "          ary[rank][k] /= fac",
      "          res[rank][k] /= fac",
      "        else",
      "          ary[rank][k] //= fac",
      "          res[rank][k] //= fac",
      "        end",
      "      end",
      "",
      "      n.times do |i|",
      "        if i != rank && ary[i][j].abs > T.zero",
      "          fac = ary[i][j]",
      "          n.times do |k|",
      "            ary[i][k] -= ary[rank][k] * fac",
      "            res[i][k] -= res[rank][k] * fac",
      "          end",
      "        end",
      "      end",
      "      rank += 1",
      "    end",
      "    Matrix(T).new res",
      "  end",
      "",
      "  def inv?",
      "    return nil unless is_regular?",
      "    inv",
      "  end",
      "",
      "  def tr : T",
      "    raise DimensionError.new(@n_rows, @n_cols) if @n_rows != @n_cols",
      "    n = @n_rows",
      "    n.times.sum{ |i| at(i, i) }",
      "  end",
      "",
      "  def tr?",
      "    return nil if @n_rows != @n_cols",
      "    tr",
      "  end",
      "",
      "  def sweep(extended? : Bool = false) : Int32",
      "    ary = to_a",
      "    h, w = @n_rows, @n_cols",
      "    rank = 0",
      "    w.times do |j|",
      "      break if extended? && j == w - 1",
      "",
      "      # TODO: language update",
      "      pivot = -1",
      "      mx = T.zero",
      "      (rank...h).each do |i|",
      "        if mx < ary[i][j].abs",
      "          mx = ary[i][j].abs",
      "          pivot = i",
      "        end",
      "      end",
      "      next if pivot == -1",
      "",
      "      ary.swap(pivot, rank)",
      "",
      "      fac = ary[rank][j]",
      "      ",
      "      w.times do |k|",
      "        if fac.is_a? Float",
      "          ary[rank][k] /= fac",
      "        else",
      "          ary[rank][k] //= fac",
      "        end",
      "      end",
      "",
      "      h.times do |i|",
      "        if i != rank && ary[i][j].abs > T.zero",
      "          fac = ary[i][j]",
      "          w.times{ |k| ary[i][k] -= ary[rank][k] * fac }",
      "        end",
      "      end",
      "      rank += 1",
      "    end",
      "",
      "    h.times{ |i| w.times{ |j| @m[@n_cols * i + j] = ary[i][j] } }",
      "",
      "    rank",
      "  end",
      "",
      "  def zero? : Bool",
      "    all?{ |x| x == T.zero }",
      "  end",
      "",
      "  def is_square?",
      "    @n_rows == @n_cols",
      "  end",
      "",
      "  def is_regular?",
      "    det != T.zero",
      "  end",
      "",
      "  def to_a : Array(Array(T))",
      "    @n_rows.times.map do |i|",
      "      @n_cols.times.map do |j|",
      "        at(i, j)",
      "      end.to_a",
      "    end.to_a",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    w = @m.max_of{ |a| a.to_s.size }",
      "    io << \"Matrix([\"",
      "    @n_rows.times do |i|",
      "      io << \" \" * 8 if i != 0",
      "      io << \"[\"",
      "      @n_cols.times do |j|",
      "        io << \", \" if j != 0",
      "        io << printf(\"%#{w}s\", at(i, j).to_s)",
      "      end",
      "      io << \"]\"",
      "      io << \")\" if i == @n_rows - 1",
      "      io << \"\\n\" if i < @n_rows - 1",
      "    end",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      "",
      "  private def over(i : Int, j : Int)",
      "    i < 0 || i >= @n_rows || j < 0 || j >= @n_cols",
      "  end",
      "end",
      "",
      "struct Int",
      "  def *(mat : Matrix(T))",
      "    Matrix.new(mat.row_size, mat.column_size) do |i, j|",
      "      self * mat[i, j]",
      "    end",
      "  end",
      "end"
    ],
    "description": "Matrix"
  },
  "反転数": {
    "prefix": "inversion_number",
    "body": [
      "{% for int_type in Int.union_types %}",
      "  def inversion_number(v : Array({{ int_type.id }})) : Int32",
      "    n = v.size",
      "    csum = DynamicRangeSum(Int32).new(n)",
      "    (1...n).sum do |i|",
      "      csum.add(v[i - 1], 1)",
      "      i - csum[...v[i]]",
      "    end",
      "  end",
      "{% end %}"
    ],
    "description": "inversion_number"
  },

  //────────────────────────────────────────────────────
  // 動的計画法
  //────────────────────────────────────────────────────
  "部分和問題": {
    "prefix": "SubsetSumSolver",
    "body": [
      "class SubsetSumSolver",
      "  enum ProblemType",
      "    ZeroOne",
      "    Limited",
      "    Unlimited",
      "  end",
      "",
      "  @type : ProblemType",
      "  @seq : Enumerable(Int32)",
      "  @capacity : Int32",
      "  @mod_old : Int64?",
      "  getter exist : Array(Bool)",
      "  getter ways : Array(Int64)",
      "",
      "  # 0-1 部分和問題を解くためのソルバを生成します。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.zeroone([1, 1, 2, 3, 4], capacity: 30)",
      "  # ```",
      "  def self.zeroone(seq : Enumerable(Int), capacity : Int)",
      "    new ProblemType::ZeroOne, seq.map(&.to_i32), capacity",
      "  end",
      "",
      "  # 個数制限付き部分和問題を解くためのソルバを生成します。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.limited([1, 2, 4], [{0, 1}, {3, 5}, {2, 10}], capacity: 30)",
      "  # ```",
      "  def self.limited(seq : Enumerable(Int32), lim : Enumerable(Int32), capacity : Int)",
      "    raise NotImplementedError.new(\"TODO\")",
      "    new ProblemType::Limited, seq.map(&.to_i32), capacity",
      "  end",
      "",
      "  # 個数制限なし部分和問題を解くためのソルバを生成します。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.unlimited([1, 1, 2, 3, 4], capacity: 30)",
      "  # ```",
      "  def self.unlimited(seq : Enumerable(Int32), capacity : Int)",
      "    new ProblemType::Unlimited, seq.map(&.to_i32), capacity",
      "  end",
      "",
      "  def initialize(@type : ProblemType, @seq : Enumerable(Int32), capacity : Int)",
      "    @capacity = capacity.to_i32",
      "    @exist = Array(Bool).new",
      "    @ways = Array(Int64).new",
      "    @mod_old = nil",
      "  end",
      "",
      "  # 値 x が構成可能なら `true` を返します。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.zeroone([1, 1, 2, 3, 4], capacity: 30)",
      "  # ss.configurable?(0) # => true",
      "  # ss.configurable?(2) # => true",
      "  # ss.configurable?(30) # => false",
      "  # ```",
      "  def configurable?(x : Int)",
      "    unless @exist.empty?",
      "      return @exist[x]",
      "    end",
      "",
      "    case @type",
      "    when ProblemType::ZeroOne",
      "      @exist = Array.new(@capacity + 1){ |i| i == 0 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).reverse_each do |j|",
      "          @exist[j] |= @exist[j - ai]",
      "        end",
      "      end",
      "    when ProblemType::Limited",
      "    when ProblemType::Unlimited",
      "      @exist = Array.new(@capacity + 1){ |i| i == 0 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).each do |j|",
      "          @exist[j] |= @exist[j - ai]",
      "        end",
      "      end",
      "    end",
      "",
      "    @exist[x]",
      "  end",
      "",
      "  # 値 x の構成方法が何通りあるか返します。",
      "  #",
      "  # `mod` を指定すると `mod` で割ったあまりを返します。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.zeroone([1, 1, 2, 3, 4], capacity: 30)",
      "  # ss.n_ways?(0, 998244353) # => 1",
      "  # ss.n_ways?(2, 998244353) # => 2",
      "  # ss.n_ways?(30, 998244353) # => 0",
      "  # ```",
      "  def n_ways(x : Int, mod : Int64 = nil)",
      "    if !@ways.empty? && mod == old_mod",
      "      return @ways[x]",
      "    end",
      "",
      "    case @type",
      "    when ProblemType::ZeroOne",
      "      @ways = Array.new(@capacity + 1){ |i| i == 0 ? 1_i64 : 0_i64 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).reverse_each do |j|",
      "          @ways[j] += @ways[j - ai]",
      "          @ways[j] %= mod.not_nil! unless mod.nil?",
      "        end",
      "      end",
      "    when ProblemType::Limited",
      "    when ProblemType::Unlimited",
      "      @ways = Array.new(@capacity + 1){ |i| i == 0 ? 1_i64 : 0_i64 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).each do |j|",
      "          @ways[j] += @ways[j - ai]",
      "          @ways[j] %= mod.not_nil! unless mod.nil?",
      "        end",
      "      end",
      "    end",
      "",
      "    old_mod = mod",
      "",
      "    @ways[x]",
      "  end",
      "end"
    ],
    "description": "SubsetSumSolver"
  },
  "最長共通部分列": {
    "prefix": ["lcs", "longest_common_subsequence"],
    "body": [
      "{% for type in [Array, String] %}",
      "class {{ type }}",
      "  # 最長共通部部分列の長さを返します。",
      "  #",
      "  # ```",
      "  # \"mynavi\".lcs(\"monday\") # => 3",
      "  # [0, 1, 2].lcs([0, 2, 5, 8]) # => 2",
      "  # ```",
      "  def lcs(other : {{ type }}) : Int64",
      "    n = self.size",
      "    m = other.size",
      "    dp = Array.new(n + 1){ Array.new(m + 1){ 0_i64 } }",
      "",
      "    (1..n).each do |i|",
      "      (1..m).each do |j|",
      "        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])",
      "        dp[i][j] = dp[i - 1][j - 1] + 1 if self[i - 1] == other[j - 1]",
      "      end",
      "    end",
      "",
      "    dp[n][m]",
      "  end",
      "end",
      "{% end %}"
    ],
    "description": "lcs"
  },
  "メモ化再帰": {
    "prefix": "Memoized",
    "body": [
      "cache = Array.new",
      "dp = uninitialized Proc(Int64, Nil)",
      "dp = ->(arg : Int64) do",
      "  return cache[arg].not_nil! unless cache[arg].nil?",
      "",
      "  cache[arg] = dp.call(arg2)",
      "",
      "  cache[arg].not_nil!",
      "end"
    ],
    "description": "メモ化再帰"
  },
  "最長増加部分列": {
    "prefix": ["lis", "longest_increasing_subsequence"],
    "body": [
      "class Array(T)",
      "  # 最長増加部分列の長さを返します。",
      "  #",
      "  # `strict が `true` の場合、狭義単調増加として考えます。",
      "  #",
      "  # ```",
      "  # [1, 9, 1, 2, 3, 8].lis(strict: true) # => 3",
      "  # [1, 9, 1, 2, 3, 8].lis(strict: false) # => 4",
      "  # ```",
      "  def lis(strict : Bool) : Int64",
      "    dp = Array(T).new",
      "    each do |v|",
      "      i = dp.bsearch_index{ |e| strict ? e >= v : e > v }",
      "      if i.nil?",
      "        dp << v",
      "      else",
      "        dp[i.not_nil!] = v",
      "      end",
      "    end",
      "    dp.size.to_i64",
      "  end",
      "end"
    ],
    "description": "lis"
  },

  //────────────────────────────────────────────────────
  // データ構造
  //────────────────────────────────────────────────────
  "二分ヒープ": {
    "prefix": "Heap",
    "body": [
      "class Heap(T)",
      "  include Comparable(Heap(T))",
      "",
      "  delegate size, to: hp",
      "  delegate empty?, to: hp",
      "  getter hp : Array(T)",
      "",
      "  def <=>(other : Heap(T))",
      "    @hp <=> other.hp",
      "  end",
      "",
      "  def self.min",
      "    new { |a, b| a > b }",
      "  end",
      "",
      "  def self.max",
      "    new { |a, b| a < b }",
      "  end",
      "",
      "  def initialize",
      "    @cmp = ->(a : T, b : T) { a < b }",
      "    @hp = Array(T).new",
      "  end",
      "",
      "  def initialize(&@cmp : (T, T) -> Bool)",
      "    @hp = Array(T).new",
      "  end",
      "",
      "  def <<(value : T)",
      "    push(value)",
      "  end",
      "",
      "  def push(value : T)",
      "    @hp.push(value)",
      "    child = @hp.size - 1",
      "    v = @hp[child]",
      "    while child > 0",
      "      parent = (child - 1) // 2",
      "      unless @cmp.call @hp[parent], v",
      "        break",
      "      end",
      "      @hp.swap(parent, child)",
      "      child = parent",
      "    end",
      "    @hp[child] = v",
      "  end",
      "",
      "  def pop",
      "    len = @hp.size - 1",
      "    if len > 0",
      "      v = @hp[len]",
      "      @hp[len] = @hp[0]",
      "      parent = 0",
      "      child = 1",
      "      while child < len",
      "        if child + 1 < len && @cmp.call @hp[child], @hp[child + 1]",
      "          child += 1",
      "        end",
      "        unless @cmp.call v, @hp[child]",
      "          break",
      "        end",
      "        @hp.swap(parent, child)",
      "        parent = child",
      "        child = 2*parent + 1",
      "      end",
      "      @hp[parent] = v",
      "    end",
      "    @hp.pop",
      "  end",
      "",
      "  def peek",
      "    @hp.first",
      "  end",
      "",
      "  def clear",
      "    @hp.clear",
      "  end",
      "end"
    ],
    "description": "Heap"
  },
  "累積和": {
    "prefix": "StaticRangeSum",
    "body": [
      "class StaticRangeSum(T)",
      "  getter size : Int64",
      "  getter csum : Array(T)",
      "",
      "  def initialize(array : Array(T))",
      "    @size = array.size.to_i64",
      "    @csum = Array.new(@size + 1, T.zero)",
      "    @size.times { |i| @csum[i + 1] = @csum[i] + array[i] }",
      "  end",
      "",
      "  def get(left, right) : T",
      "    raise IndexError.new(\"`left` must be less than or equal to `right` (#{left}, #{right})\") unless left <= right",
      "    @csum[right] - @csum[left]",
      "  end",
      "",
      "  def get(range : Range(Int?, Int?)) : T",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    get(left, right)",
      "  end",
      "  ",
      "  def get?(left, right) : T?",
      "    return nil unless left <= right",
      "    get(left, right)",
      "  end",
      "",
      "  def get?(range : Range(Int?, Int?)) : T?",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    get?(left, right)",
      "  end",
      "",
      "  def get!(left, right) : T",
      "    @csum[right] - @csum[left]",
      "  end",
      "",
      "  def get!(range : Range(Int?, Int?)) : T",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    get!(left, right)",
      "  end",
      "",
      "  def [](left, right) : T; get(left, right) end",
      "  def [](range : Range(Int?, Int?)) : T; get(range) end",
      "  def []?(left, right) : T?; get?(left, right) end",
      "  def []?(range : Range(Int?, Int?)) : T?; get?(range) end",
      "end"
    ],
    "description": "StaticRangeSum"
  },
  "DynamicRangeSum": {
    "prefix": "DynamicRangeSum",
    "body": [
      "class DynamicRangeSum(T)",
      "  getter size : Int32",
      "  @data : Array(T)",
      "",
      "  def initialize(n : Int)",
      "    @data = Array(T).new(n){ T.zero }",
      "    @size = @data.size",
      "  end",
      "",
      "  def initialize(n : Int, val : T)",
      "    @data = Array(T).new(n){ val }",
      "    @size = @data.size",
      "  end",
      "",
      "  def initialize(elems : Enumerable(T))",
      "    @size = elems.size.to_i64",
      "    @data = Array(T).new(@size, T.zero)",
      "    elems.each_with_index{ |x, i| add(i, x) }",
      "  end",
      "",
      "  def get(left : Int, right : Int) : T",
      "    raise IndexError.new(\"`left` and `right` must be 0 <= left <= right <= self.size (#{left}, #{right})\") unless 0 <= left && left <= right && right <= @size",
      "    sum(right) - sum(left)",
      "  end",
      "",
      "  def get?(left : Int, right : Int) : T?",
      "    return nil unless 0 <= left && left <= right && right <= @size",
      "    get(left, right)",
      "  end",
      "",
      "  def get(i : Int) : T",
      "    get(i, i + 1)",
      "  end",
      "",
      "  def get?(i : Int) : T?",
      "    get?(i, i + 1)",
      "  end",
      "",
      "  {% begin %}",
      "    {% for int1 in Int.union_types + [Nil] %}",
      "      {% for int2 in Int.union_types + [Nil] %}",
      "        def get(range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get(left, right)",
      "        end",
      "",
      "        def get?(range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get?(left, right)",
      "        end",
      "",
      "        def [](range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get(left, right)",
      "        end",
      "",
      "        def []?(range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get?(left, right)",
      "        end",
      "      {% end %}",
      "    {% end %}",
      "  {% end %}",
      "",
      "  def [](i : Int) : T; get(i, i + 1) end",
      "  def []?(i : Int) : T?; get?(i, i + 1) end",
      "",
      "  def [](l : Int, r : Int) : T; get(l, r) end",
      "  def []?(l : Int, r : Int) : T?; get?(l, r) end",
      "",
      "  def []=(i : Int, x : T) : T; add(i, x - get(i)) end",
      "",
      "  def add(i : Int, x : T)",
      "    i += 1",
      "    while (i <= @size)",
      "      @data[i - 1] += x",
      "      i += i & -i",
      "    end",
      "    x",
      "  end",
      "",
      "  private def sum(r : Int) : T",
      "    s = T.zero",
      "    while r > 0",
      "      s += @data[r - 1]",
      "      r -= r & -r",
      "    end",
      "    s",
      "  end",
      "end"
    ],
    "description": "DynamicRangeSum"
  },
  "二次元累積和": {
    "prefix": "StaticRectangleSum",
    "body": [
      "class StaticRectangleSum(T)",
      "  getter height : Int32",
      "  getter width : Int32",
      "  getter csum : Array(Array(T))",
      "",
      "  def initialize(grid : Array(Array(T)))",
      "    @height = grid.size",
      "    @width = (grid[0]? || [] of T).size",
      "    @csum = Array.new(@height + 1){ Array.new(@width + 1){ T.zero } }",
      "    @height.times do |i|",
      "      @width.times do |j|",
      "        @csum[i + 1][j + 1] = @csum[i][j + 1] + @csum[i + 1][j] - @csum[i][j] + grid[i][j]",
      "      end",
      "    end",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T",
      "    raise IndexError.new(\"`y_begin` must be less than or equal to `y_end` (#{y_begin}, #{y_end})\") unless y_begin <= y_end",
      "    raise IndexError.new(\"`x_begin` must be less than or equal to `x_end` (#{x_begin}, #{x_end})\") unless x_begin <= x_end",
      "    @csum[y_end][x_end] - @csum[y_begin][x_end] - @csum[y_end][x_begin] + @csum[y_begin][x_begin]",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get?(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T?",
      "    return nil unless y_begin <= y_end",
      "    return nil unless x_begin <= x_end",
      "    @csum[y_end][x_end] - @csum[y_begin][x_end] - @csum[y_end][x_begin] + @csum[y_begin][x_begin]",
      "  end",
      "",
      "  # 累積和を取得します。",
      "  #",
      "  # Range(y_begin, y_end), Range(x_begin, x_end) で指定します。",
      "  #",
      "  # ```",
      "  # csum = StaticRectangleSum.new(a)",
      "  # csum.get(0...h, j..j + 2) # => 28",
      "  # ```",
      "  def get(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # ```",
      "  # csum = StaticRectangleSum.new(a)",
      "  # csum.get?(0...h, j..j + 2) # => 28",
      "  # csum.get?(0...100*h, j..j + 2) # => nil",
      "  # ```",
      "  def get?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get?(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  def [](y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    get(y_range, x_range)",
      "  end",
      "",
      "  def []?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    get?(y_range, x_range)",
      "  end",
      "end"
    ],
    "description": "二次元累積和"
  },
  "DynamicRectangleSum": {
    "prefix": "DynamicRectangleSum",
    "body": [
      "class DynamicRectangleSum(T)",
      "  getter height : Int32",
      "  getter width : Int32",
      "  getter csum : Array(Array(T))",
      "",
      "  def initialize(h : Int, w : Int)",
      "    @height = h.to_i32",
      "    @width = w.to_i32",
      "    @csum = Array.new(h + 1){ Array.new(w + 1, T.zero) }",
      "  end",
      "",
      "  def initialize(grid : Array(Array(T)))",
      "    @height = grid.size",
      "    @width = (grid[0]? || [] of T).size",
      "    @csum = Array.new(@height + 1){ Array.new(@width + 1){ T.zero } }",
      "    @height.times do |i|",
      "      @width.times do |j|",
      "        add(i, j, grid[i][j])",
      "      end",
      "    end",
      "  end",
      "",
      "  # (y, x) の要素に val を足します。",
      "  #",
      "  # 添字は 0-index です。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.add(y, x, val) # => val",
      "  # ```",
      "  def add(y : Int, x : Int, val : T) : T",
      "    raise IndexError.new(\"y = #{y} が配列外参照しています。 (@height = #{@height}\") if y < 0 || y >= @height",
      "    raise IndexError.new(\"x = #{x} が配列外参照しています。 (@height = #{@width}\") if x < 0 || x >= @width",
      "    i = y + 1",
      "    while i <= @height",
      "      j = x + 1",
      "      while j <= @width",
      "        @csum[i][j] += val",
      "        j += (j & -j)",
      "      end",
      "      i += (i & -i)",
      "    end",
      "    val",
      "  end",
      "",
      "  # (y, x) の要素に val を足します。",
      "  #",
      "  # 添字は 0-index です。",
      "  #",
      "  # 加算に成功した場合 `true` を返します。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.add?(y, x, x) # => true",
      "  # ```",
      "  def add?(y : Int, x : Int, val : T) : Bool",
      "    return false if y < 0 || y >= @height",
      "    return false if x < 0 || x >= @width",
      "    i = y + 1",
      "    while i <= @height",
      "      j = x + 1",
      "      while j <= @width",
      "        @csum[i][j] += val",
      "        j += (j & -j)",
      "      end",
      "      i += (i & -i)",
      "    end",
      "    true",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T",
      "    raise IndexError.new(\"`y_begin` must be less than or equal to `y_end` (#{y_begin}, #{y_end})\") unless y_begin <= y_end",
      "    raise IndexError.new(\"`x_begin` must be less than or equal to `x_end` (#{x_begin}, #{x_end})\") unless x_begin <= x_end",
      "    query(y_end, x_end) - query(y_end, x_begin) - query(y_begin, x_end) + query(y_begin, x_begin)",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get?(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T?",
      "    return nil unless y_begin <= y_end",
      "    return nil unless x_begin <= x_end",
      "    query(y_end, x_end) - query(y_end, x_begin) - query(y_begin, x_end) + query(y_begin, x_end)",
      "  end",
      "",
      "  # 累積和を取得します。",
      "  #",
      "  # Range(y_begin, y_end), Range(x_begin, x_end) で指定します。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.get(0...h, j..j + 2) # => 28",
      "  # ```",
      "  def get(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.get?(0...h, j..j + 2) # => 28",
      "  # csum.get?(0...100*h, j..j + 2) # => nil",
      "  # ```",
      "  def get?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get?(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  def [](y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    get(y_range, x_range)",
      "  end",
      "",
      "  def []?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    get?(y_range, x_range)",
      "  end",
      "",
      "  def []=(i : Int, j : Int, val : T)",
      "    add(i, j, val - get(i..i, j..j))",
      "  end",
      "",
      "  private def query(h : Int, w : Int) : T",
      "    acc = T.zero",
      "    i = h",
      "    while i > 0",
      "      j = w",
      "      while j > 0",
      "        acc += @csum[i][j]",
      "        j -= (j & -j)",
      "      end",
      "      i -= (i & -i)",
      "    end",
      "    acc",
      "  end",
      "end"
    ],
    "description": "DynamicRectangleSum"
  },
  "DisjointSet": {
    "prefix": "DisjointSet",
    "body": [
      "class DisjointSet",
      "  @n : Int64",
      "  @parent_or_size : Array(Int64)",
      "",
      "  def initialize",
      "    @n = 0",
      "    @parent_or_size = Array(Int64).new",
      "  end",
      "",
      "  def initialize(@n : Int64)",
      "    @parent_or_size = Array(Int64).new(n, -1_i64)",
      "  end",
      "",
      "  def unite(a : Int64, b : Int64) : Int64",
      "    x = leader(a)",
      "    y = leader(b)",
      "    return x.to_i64 if x == y",
      "    if -@parent_or_size[x] < -@parent_or_size[y]",
      "      x, y = y, x",
      "    end",
      "    @parent_or_size[x] += @parent_or_size[y]",
      "    @parent_or_size[y] = x",
      "    x.to_i64",
      "  end",
      "",
      "  def equiv?(a : Int64, b : Int64) : Bool",
      "    leader(a) == leader(b)",
      "  end",
      "",
      "  def leader(a : Int64) : Int64",
      "    return a.to_i64 if @parent_or_size[a] < 0",
      "    @parent_or_size[a] = leader(@parent_or_size[a])",
      "    @parent_or_size[a].to_i64",
      "  end",
      "",
      "  def size(a : Int64) : Int64",
      "    -@parent_or_size[leader(a)].to_i64",
      "  end",
      "",
      "  def groups : Array(Array(Int64)) | Nil",
      "    leader_buf = Array(Int64).new(@n, 0_i64)",
      "    group_size = Array(Int64).new(@n, 0_i64)",
      "    @n.times do |i|",
      "      leader_buf[i] = leader(i)",
      "      group_size[leader_buf[i]] += 1",
      "    end",
      "    res = Array.new(@n){ Array(Int64).new() }",
      "    @n.times do |i|",
      "      res[leader_buf[i]] << i.to_i64",
      "    end",
      "    res.delete([] of Int64)",
      "    res",
      "  end",
      "end"
    ],
    "description": "DisjointSet"
  },
  "MedQueue": {
    "prefix": "MedQueue",
    "body": [
      "# require \"Heap\"",
      "# return que[m // 2]",
      "class MedianQueue(T)",
      "  @lesser : Heap(T)",
      "  @greater : Heap(T)",
      "",
      "  def initialize",
      "    @lesser = Heap(T).max",
      "    @greater = Heap(T).min",
      "  end",
      "",
      "  def initialize(array : Array(T))",
      "    @lesser = Heap(T).max",
      "    @greater = Heap(T).min",
      "    array.each { |a| push(a) }",
      "  end",
      "",
      "  def push(x : T)",
      "    if @lesser.empty? && @greater.empty?",
      "      @greater << x",
      "    elsif @lesser.size == @greater.size",
      "      top = @lesser.peek",
      "      if x < top",
      "        @lesser << x",
      "        x = @lesser.pop # => top",
      "      end",
      "      @greater << x",
      "    else",
      "      top = @greater.peek",
      "      if x > top",
      "        @greater << x",
      "        x = @greater.pop # => top",
      "      end",
      "      @lesser << x",
      "    end",
      "  end",
      "",
      "  def <<(x : T)",
      "    push(x)",
      "  end",
      "",
      "  def pop : T",
      "    med = @greater.pop",
      "    if @lesser.size > @greater.size",
      "      @greater << @lesser.pop",
      "    end",
      "    med",
      "  end",
      "",
      "  def peek : T",
      "    @greater.peek",
      "  end",
      "end",
      ""
    ],
    "description": "MedQueue"
  },
  "AATreeSet": {
    "prefix": "AATreeSet",
    "body": [
      "class AATreeSet(T)",
      "  include Enumerable(T)",
      " ",
      "  private class Node(T)",
      "    property left : Node(T)?",
      "    property right : Node(T)?",
      "    property parent : Node(T)?",
      "    property key : T",
      "    property level : Int32",
      "    property size : Int32",
      " ",
      "    def initialize(val : T)",
      "      @left = @right = @parent = nil",
      "      @level = 1",
      "      @key = val",
      "      @size = 1",
      "    end",
      " ",
      "    def rotate_left : Node(T)",
      "      right = @right.not_nil!",
      "      mid = right.left",
      "      par = @parent",
      "      if right.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = right",
      "        else",
      "          par.not_nil!.right = right",
      "        end",
      "      end",
      "      mid.parent = self if @right = mid",
      "      right.left = self",
      "      @parent = right",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - right.size",
      "      right.size = sz",
      " ",
      "      right",
      "    end",
      " ",
      "    def rotate_right : Node(T)",
      "      left = @left.not_nil!",
      "      mid = left.right",
      "      par = @parent",
      " ",
      "      if left.not_nil!.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = left",
      "        else",
      "          par.not_nil!.right = left",
      "        end",
      "      end",
      "      mid.parent = self if @left = mid",
      "      left.not_nil!.right = self",
      "      @parent = left",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - left.size",
      "      left.size = sz",
      " ",
      "      left",
      "    end",
      " ",
      "    def left_side?(node : Node(T)?) : Bool",
      "      @left == node",
      "    end",
      " ",
      "    def assign(node : Node(T)) : T",
      "      @key = node.key",
      "    end",
      "  end",
      " ",
      "  @root : Node(T)?",
      " ",
      "  private def find_node(node : Node(T)?, val : T) : Node(T)?",
      "    return nil unless node",
      "    until val == node.not_nil!.key",
      "      if val < node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    node",
      "  end",
      "",
      "  private def skew(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    left = node.not_nil!.left",
      "    if left && node.not_nil!.level == left.not_nil!.level",
      "      return node.not_nil!.rotate_right",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def split(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    right = node.right",
      "    if right && right.not_nil!.right && node.level == right.not_nil!.right.not_nil!.level",
      "      r = node.rotate_left",
      "      r.level += 1",
      "      return r",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def begin_node : Node(T)?",
      "    return nil unless @root",
      "    node = @root",
      "    while node.not_nil!.left",
      "      node = node.not_nil!.left",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def next_node(node : Node(T)) : Node(T)?",
      "    if node.right",
      "      node = node.right",
      "      while node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      end",
      "      node",
      "    else",
      "      while node",
      "        par = node.not_nil!.parent",
      "        if par && par.not_nil!.left_side?(node)",
      "          return par",
      "        end",
      "        node = par",
      "      end",
      "      node",
      "    end",
      "  end",
      " ",
      "  private def level(node : Node(T)?)",
      "    node ? node.level : 0",
      "  end",
      " ",
      "  def initialize",
      "    @root = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(enumerable : Enumerable(T))",
      "    @root = nil",
      "    concat(enumerable)",
      "    self",
      "  end",
      " ",
      "  def concat(elems) : self",
      "    elems.each { |elem| self << elem }",
      "    self",
      "  end",
      " ",
      "  def includes?(val : T) : Bool",
      "    node = find_node(@root, val)",
      "    node.nil? ? false : node.key == val",
      "  end",
      " ",
      "  def clear",
      "    @root = nil",
      "  end",
      " ",
      "  def empty? : Bool",
      "    @root.nil?",
      "  end",
      " ",
      "  def at(k : Int) : T",
      "    raise IndexError.new unless 0 <= k && k < size",
      "    node = @root",
      "    k += 1",
      "    loop do",
      "      left_size = (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "      break if left_size == k",
      " ",
      "      if k < left_size",
      "        node = node.not_nil!.left",
      "      else",
      "        node = node.not_nil!.right",
      "        k -= left_size",
      "      end",
      "    end",
      "    node.not_nil!.key",
      "  end",
      " ",
      "  def at?(k : Int) : T?",
      "    return nil unless 0 <= k && k < size",
      "    at(k)",
      "  end",
      " ",
      "  def each(& : T ->)",
      "    node = begin_node",
      "    while node",
      "      yield node.not_nil!.key",
      "      node = next_node(node.not_nil!)",
      "    end",
      "  end",
      "",
      "  def add(val : T) : Nil",
      "    add?(val)",
      "    nil",
      "  end",
      " ",
      "  def add?(val : T) : Bool",
      "    unless @root",
      "      @root = Node.new(val)",
      "      return true",
      "    end",
      " ",
      "    node = find_node(@root, val)",
      "    return false if node.not_nil!.key == val # NOT multi",
      "",
      "    new_node = Node.new(val)",
      "    if val <= node.not_nil!.key",
      "      node.not_nil!.left = new_node",
      "    else",
      "      node.not_nil!.right = new_node",
      "    end",
      "    new_node.not_nil!.parent = node",
      " ",
      "    node = new_node",
      "    while node",
      "      node = split(skew(node))",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "      node.not_nil!.size += 1",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete(val : T) : Bool",
      "    return false unless @root",
      " ",
      "    node = find_node(@root, val)",
      "    return false unless node.not_nil!.key == val",
      " ",
      "    if node.not_nil!.left || node.not_nil!.right",
      "      child = find_node(node.not_nil!.left ? node.not_nil!.left : node.not_nil!.right, val)",
      "      node.not_nil!.assign(child.not_nil!)",
      "      node = child",
      "    end",
      " ",
      "    par = node.not_nil!.parent",
      "    if par",
      "      if par.not_nil!.left_side?(node)",
      "        par.left = nil",
      "      else",
      "        par.right = nil",
      "      end",
      "    else",
      "      @root = nil",
      "    end",
      "    node = par",
      " ",
      "    while node",
      "      new_level = { level(node.left), level(node.right) }.min + 1",
      "      if new_level < node.level",
      "        node.level = new_level",
      "        if new_level < level(node.right)",
      "          node.right.not_nil!.level = new_level",
      "        end",
      "      end",
      " ",
      "      node.size -= 1",
      "      node = skew(node).not_nil!",
      "      skew(node.right.not_nil!.right) if skew(node.right)",
      " ",
      "      node = split(node)",
      "      split(node.not_nil!.right)",
      " ",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete_at(k : Int) : Bool",
      "    delete(at(k))",
      "  end",
      " ",
      "  def delete_at?(k : Int) : Bool",
      "    val = at?(k)",
      "    if val",
      "      delete(val)",
      "    else",
      "      return false",
      "    end",
      "  end",
      " ",
      "  def lower_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val <= node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      " ",
      "  def upper_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val < node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      "",
      "  def less_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == 0 ? nil : index - 1",
      "  end",
      "",
      "  def less_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    val == at?(index) ? index : (index == 0 ? nil : index - 1)",
      "  end",
      "",
      "  def greater_index(val : T) : Int32?",
      "    index = upper_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def greater_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def first : T; at(0) end",
      "  def first? : T?; at?(0) end",
      "  def last : T; at(size - 1) end",
      "  def last? : T?; at?(size - 1) end",
      " ",
      "  def count(val : T) : Int32",
      "    upper_bound_index(val) - lower_bound_index(val)",
      "  end",
      " ",
      "  def size : Int32",
      "    @root ? @root.not_nil!.size : 0",
      "  end",
      " ",
      "  def to_a : Array(T)",
      "    res = Array(T).new",
      "    return res unless @root",
      "    dfs = uninitialized Proc(Node(T), Nil)",
      "    dfs = ->(node : Node(T)) do",
      "      dfs.call(node.left.not_nil!) if node.left",
      "      res << node.key",
      "      dfs.call(node.right.not_nil!) if node.right",
      "      nil",
      "    end",
      "    dfs.call(@root.not_nil!)",
      "    res",
      "  end",
      " ",
      "  def to_s(io : IO) : Nil",
      "    io << \"{\" + to_a.join(\", \") + \"}\"",
      "  end",
      "",
      "  def inspect(io : IO) : Nil",
      "    to_s(io)",
      "  end",
      "",
      "  def ==(other : AATreeSet(T)) : Bool; self.to_a == other.to_a end",
      "  def <<(val : T) : Bool; add?(val) end",
      "  def [](k : Int) : T; at(k) end",
      "  def []?(k : Int) : T | Nil; at?(k) end",
      "end"
    ],
    "description": "AATreeSet"
  },
  "AATreeMultiset": {
    "prefix": "AATreeMultiset",
    "body": [
      "class AATreeMultiset(T)",
      "  include Enumerable(T)",
      " ",
      "  private class Node(T)",
      "    property left : Node(T)?",
      "    property right : Node(T)?",
      "    property parent : Node(T)?",
      "    property key : T",
      "    property level : Int32",
      "    property size : Int32",
      " ",
      "    def initialize(val : T)",
      "      @left = @right = @parent = nil",
      "      @level = 1",
      "      @key = val",
      "      @size = 1",
      "    end",
      " ",
      "    def rotate_left : Node(T)",
      "      right = @right.not_nil!",
      "      mid = right.left",
      "      par = @parent",
      "      if right.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = right",
      "        else",
      "          par.not_nil!.right = right",
      "        end",
      "      end",
      "      mid.parent = self if @right = mid",
      "      right.left = self",
      "      @parent = right",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - right.size",
      "      right.size = sz",
      " ",
      "      right",
      "    end",
      " ",
      "    def rotate_right : Node(T)",
      "      left = @left.not_nil!",
      "      mid = left.right",
      "      par = @parent",
      " ",
      "      if left.not_nil!.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = left",
      "        else",
      "          par.not_nil!.right = left",
      "        end",
      "      end",
      "      mid.parent = self if @left = mid",
      "      left.not_nil!.right = self",
      "      @parent = left",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - left.size",
      "      left.size = sz",
      " ",
      "      left",
      "    end",
      " ",
      "    def left_side?(node : Node(T)?) : Bool",
      "      @left == node",
      "    end",
      " ",
      "    def assign(node : Node(T)) : T",
      "      @key = node.key",
      "    end",
      "  end",
      " ",
      "  @root : Node(T)?",
      " ",
      "  private def find_node(node : Node(T)?, val : T) : Node(T)?",
      "    return nil unless node",
      "    until val == node.not_nil!.key",
      "      if val < node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "",
      "    while node.not_nil!.left && node.not_nil!.left.not_nil!.key == val",
      "      node = node.not_nil!.left",
      "    end",
      "    while node.not_nil!.right && node.not_nil!.right.not_nil!.key == val",
      "      node = node.not_nil!.right",
      "    end",
      "",
      "    node",
      "  end",
      " ",
      "  private def find_node2(node : Node(T)?, val : T) : Node(T)?",
      "    return nil unless node",
      "    loop do",
      "      if val <= node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      " ",
      "    node",
      "  end",
      " ",
      "  private def skew(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    left = node.not_nil!.left",
      "    if left && node.not_nil!.level == left.not_nil!.level",
      "      return node.not_nil!.rotate_right",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def split(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    right = node.right",
      "    if right && right.not_nil!.right && node.level == right.not_nil!.right.not_nil!.level",
      "      r = node.rotate_left",
      "      r.level += 1",
      "      return r",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def begin_node : Node(T)?",
      "    return nil unless @root",
      "    node = @root",
      "    while node.not_nil!.left",
      "      node = node.not_nil!.left",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def next_node(node : Node(T)) : Node(T)?",
      "    if node.right",
      "      node = node.right",
      "      while node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      end",
      "      node",
      "    else",
      "      while node",
      "        par = node.not_nil!.parent",
      "        if par && par.not_nil!.left_side?(node)",
      "          return par",
      "        end",
      "        node = par",
      "      end",
      "      node",
      "    end",
      "  end",
      " ",
      "  private def level(node : Node(T)?)",
      "    node ? node.level : 0",
      "  end",
      " ",
      "  def initialize",
      "    @root = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(enumerable : Enumerable(T))",
      "    @root = nil",
      "    concat(enumerable)",
      "    self",
      "  end",
      " ",
      "  def concat(elems) : self",
      "    elems.each { |elem| self << elem }",
      "    self",
      "  end",
      " ",
      "  def includes?(val : T) : Bool",
      "    node = find_node(@root, val)",
      "    node.nil? ? false : node.key == val",
      "  end",
      " ",
      "  def clear",
      "    @root = nil",
      "  end",
      " ",
      "  def empty? : Bool",
      "    @root.nil?",
      "  end",
      " ",
      "  def at(k : Int) : T",
      "    raise IndexError.new unless 0 <= k && k < size",
      "    node = @root",
      "    k += 1",
      "    loop do",
      "      left_size = (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "      break if left_size == k",
      " ",
      "      if k < left_size",
      "        node = node.not_nil!.left",
      "      else",
      "        node = node.not_nil!.right",
      "        k -= left_size",
      "      end",
      "    end",
      "    node.not_nil!.key",
      "  end",
      " ",
      "  def at?(k : Int) : T?",
      "    return nil unless 0 <= k && k < size",
      "    at(k)",
      "  end",
      " ",
      "  def each(& : T ->)",
      "    node = begin_node",
      "    while node",
      "      yield node.not_nil!.key",
      "      node = next_node(node.not_nil!)",
      "    end",
      "  end",
      "",
      "  def add(val : T) : Nil",
      "    add?(val)",
      "    nil",
      "  end",
      " ",
      "  def add?(val : T) : Bool",
      "    unless @root",
      "      @root = Node.new(val)",
      "      return true",
      "    end",
      " ",
      "    node = find_node2(@root, val)",
      " ",
      "    new_node = Node.new(val)",
      "    if val <= node.not_nil!.key",
      "      node.not_nil!.left = new_node",
      "    else",
      "      node.not_nil!.right = new_node",
      "    end",
      "    new_node.not_nil!.parent = node",
      " ",
      "    node = new_node",
      "    while node",
      "      node = split(skew(node))",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "      node.not_nil!.size += 1",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete(val : T) : Bool",
      "    return false unless @root",
      " ",
      "    node = find_node(@root, val)",
      "    return false unless node.not_nil!.key == val",
      " ",
      "    if node.not_nil!.left || node.not_nil!.right",
      "      child = find_node(node.not_nil!.left ? node.not_nil!.left : node.not_nil!.right, val)",
      "      node.not_nil!.assign(child.not_nil!)",
      "      node = child",
      "    end",
      " ",
      "    par = node.not_nil!.parent",
      "    if par",
      "      if par.not_nil!.left_side?(node)",
      "        par.left = nil",
      "      else",
      "        par.right = nil",
      "      end",
      "    else",
      "      @root = nil",
      "    end",
      "    node = par",
      " ",
      "    while node",
      "      new_level = { level(node.left), level(node.right) }.min + 1",
      "      if new_level < node.level",
      "        node.level = new_level",
      "        if new_level < level(node.right)",
      "          node.right.not_nil!.level = new_level",
      "        end",
      "      end",
      " ",
      "      node.size -= 1",
      "      node = skew(node).not_nil!",
      "      skew(node.right.not_nil!.right) if skew(node.right)",
      " ",
      "      node = split(node)",
      "      split(node.not_nil!.right)",
      " ",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete_at(k : Int) : Bool",
      "    delete(at(k))",
      "  end",
      " ",
      "  def delete_at?(k : Int) : Bool",
      "    val = at?(k)",
      "    if val",
      "      delete(val)",
      "    else",
      "      return false",
      "    end",
      "  end",
      " ",
      "  def lower_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val <= node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      " ",
      "  def upper_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val < node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      "",
      "  def less_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == 0 ? nil : index - 1",
      "  end",
      "  ",
      "  def less_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    val == at?(index) ? index : (index == 0 ? nil : index - 1)",
      "  end",
      "  ",
      "  def greater_index(val : T) : Int32?",
      "    index = upper_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "  ",
      "  def greater_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def first : T; at(0) end",
      "  def first? : T?; at?(0) end",
      "  def last : T; at(size - 1) end",
      "  def last? : T?; at?(size - 1) end",
      " ",
      "  def count(val : T) : Int32",
      "    upper_bound_index(val) - lower_bound_index(val)",
      "  end",
      " ",
      "  def size : Int32",
      "    @root ? @root.not_nil!.size : 0",
      "  end",
      " ",
      "  def to_a : Array(T)",
      "    res = Array(T).new",
      "    return res unless @root",
      "    dfs = uninitialized Proc(Node(T), Nil)",
      "    dfs = ->(node : Node(T)) do",
      "      dfs.call(node.left.not_nil!) if node.left",
      "      res << node.key",
      "      dfs.call(node.right.not_nil!) if node.right",
      "      nil",
      "    end",
      "    dfs.call(@root.not_nil!)",
      "    res",
      "  end",
      " ",
      "  def to_s(io : IO) : Nil",
      "    io << \"{\" + to_a.join(\", \") + \"}\"",
      "  end",
      "",
      "  def inspect(io : IO) : Nil",
      "    to_s(io)",
      "  end",
      "",
      "  def ==(other : AATreeSet(T)) : Bool; self.to_a == other.to_a end",
      "  def <<(val : T) : Bool; add?(val) end",
      "  def [](k : Int) : T; at(k) end",
      "  def []?(k : Int) : T | Nil; at?(k) end",
      "end"
    ],
    "description": "AATreeMultiset"
  },
  "AATreeMap": {
    "prefix": "AATreeMap",
    "body": [
      "class AATreeMap(K, V)",
      "  include Enumerable({K, V})",
      " ",
      "  private class Node(K, V)",
      "    property left : Node(K, V)?",
      "    property right : Node(K, V)?",
      "    property parent : Node(K, V)?",
      "    property key : K",
      "    property value : V",
      "    property level : Int32",
      "    property size : Int32",
      " ",
      "    def initialize(item : {K, V})",
      "      @left = @right = @parent = nil",
      "      @level = 1",
      "      @key = item[0]",
      "      @value = item[1]",
      "      @size = 1",
      "    end",
      " ",
      "    def rotate_left : Node(K, V)",
      "      right = @right.not_nil!",
      "      mid = right.left",
      "      par = @parent",
      "      if right.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = right",
      "        else",
      "          par.not_nil!.right = right",
      "        end",
      "      end",
      "      mid.parent = self if @right = mid",
      "      right.left = self",
      "      @parent = right",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - right.size",
      "      right.size = sz",
      " ",
      "      right",
      "    end",
      " ",
      "    def rotate_right : Node(K, V)",
      "      left = @left.not_nil!",
      "      mid = left.right",
      "      par = @parent",
      " ",
      "      if left.not_nil!.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = left",
      "        else",
      "          par.not_nil!.right = left",
      "        end",
      "      end",
      "      mid.parent = self if @left = mid",
      "      left.not_nil!.right = self",
      "      @parent = left",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - left.size",
      "      left.size = sz",
      " ",
      "      left",
      "    end",
      " ",
      "    def left_side?(node : Node(K, V)?) : Bool",
      "      @left == node",
      "    end",
      " ",
      "    def assign(node : Node(K, V)) : V",
      "      @key = node.key",
      "      @value = node.value",
      "    end",
      "  end",
      " ",
      "  @root : Node(K, V)?",
      "  @default : V?",
      " ",
      "  private def find_node(node : Node(K, V)?, key : K) : Node(K, V)?",
      "    return nil unless node",
      "    until key == node.not_nil!.key",
      "      if key < node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    node",
      "  end",
      "",
      "  private def skew(node : Node(K, V)?) : Node(K, V)?",
      "    return nil unless node",
      "    left = node.not_nil!.left",
      "    if left && node.not_nil!.level == left.not_nil!.level",
      "      return node.not_nil!.rotate_right",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def split(node : Node(K, V)?) : Node(K, V)?",
      "    return nil unless node",
      "    right = node.right",
      "    if right && right.not_nil!.right && node.level == right.not_nil!.right.not_nil!.level",
      "      r = node.rotate_left",
      "      r.level += 1",
      "      return r",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def upsert(key : K, value : V) : Nil",
      "    unless @root",
      "      @root = Node.new({key, value})",
      "      return true",
      "    end",
      " ",
      "    node = find_node(@root, key)",
      "    if node.not_nil!.key == key",
      "      node.not_nil!.value = value",
      "      return",
      "    end",
      " ",
      "    new_node = Node.new({key, value})",
      "    if key < node.not_nil!.key",
      "      node.not_nil!.left = new_node",
      "    else",
      "      node.not_nil!.right = new_node",
      "    end",
      "    new_node.not_nil!.parent = node",
      " ",
      "    node = new_node",
      "    while node",
      "      node = split(skew(node))",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "      node.not_nil!.size += 1",
      "    end",
      "  end",
      " ",
      "  private def begin_node : Node(K, V)?",
      "    return nil unless @root",
      "    node = @root",
      "    while node.not_nil!.left",
      "      node = node.not_nil!.left",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def next_node(node : Node(K, V)) : Node(K, V)?",
      "    if node.right",
      "      node = node.right",
      "      while node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      end",
      "      node",
      "    else",
      "      while node",
      "        par = node.not_nil!.parent",
      "        if par && par.not_nil!.left_side?(node)",
      "          return par",
      "        end",
      "        node = par",
      "      end",
      "      node",
      "    end",
      "  end",
      " ",
      "  private def level(node : Node(K, V)?)",
      "    node ? node.level : 0",
      "  end",
      " ",
      "  def initialize",
      "    @root = nil",
      "    @default = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(@default : V)",
      "    @root = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(enumerable : Enumerable({ K, V }))",
      "    @root = nil",
      "    concat(enumerable)",
      "    self",
      "  end",
      " ",
      "  def concat(elems) : self",
      "    elems.each { |elem| self << elem }",
      "    self",
      "  end",
      " ",
      "  def includes?(key : K, value : V) : Bool",
      "    node = find_node(@root, key)",
      "    node.nil? ? false : node.key == key && node.value == value",
      "  end",
      " ",
      "  def clear",
      "    @root = nil",
      "  end",
      " ",
      "  def empty? : Bool",
      "    @root.nil?",
      "  end",
      " ",
      "  def at(k : Int) : {K, V}",
      "    k += size if k < 0",
      "    raise IndexError.new unless 0 <= k && k < size",
      "    node = @root",
      "    k += 1",
      "    loop do",
      "      left_size = (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "      break if left_size == k",
      " ",
      "      if k < left_size",
      "        node = node.not_nil!.left",
      "      else",
      "        node = node.not_nil!.right",
      "        k -= left_size",
      "      end",
      "    end",
      "    {node.not_nil!.key, node.not_nil!.value}",
      "  end",
      " ",
      "  def at?(k : Int) : {K, V}?",
      "    k += size if k < 0",
      "    return nil unless 0 <= k && k < size",
      "    at(k)",
      "  end",
      " ",
      "  def key_at(k : Int) : K; at(k)[0] end",
      "  def key_at?(k : Int) : K?; t = at?(k); t ? t[0] : nil end",
      "  def value_at(k : Int) : V; at(k)[1] end",
      "  def value_at?(k : Int) : V?; t = at?(k); t ? t[1] : nil end",
      " ",
      "  def each_key(& : K ->)",
      "    each do |key, _|",
      "      yield key",
      "    end",
      "  end",
      " ",
      "  def each_value(& : V ->)",
      "    each do |_, value|",
      "      yield value",
      "    end",
      "  end",
      " ",
      "  def each(& : {K, V} ->)",
      "    node = begin_node",
      "    while node",
      "      pr = {node.not_nil!.key, node.not_nil!.value}",
      "      yield pr",
      "      node = next_node(node.not_nil!)",
      "    end",
      "  end",
      " ",
      "  def keys : Array(K)",
      "    res = Array(K).new",
      "    each do |key, _|",
      "      res << key",
      "    end",
      "    res",
      "  end",
      " ",
      "  def values : Array(V)",
      "    res = Array(V).new",
      "    each do |_, value|",
      "      res << value",
      "    end",
      "    res",
      "  end",
      " ",
      "  def delete_key(key : K) : Bool",
      "    return false unless @root",
      " ",
      "    node = find_node(@root, key)",
      "    return false unless node.not_nil!.key == key",
      " ",
      "    if node.not_nil!.left || node.not_nil!.right",
      "      child = find_node(node.not_nil!.left ? node.not_nil!.left : node.not_nil!.right, key)",
      "      node.not_nil!.assign(child.not_nil!)",
      "      node = child",
      "    end",
      " ",
      "    par = node.not_nil!.parent",
      "    if par",
      "      if par.not_nil!.left_side?(node)",
      "        par.left = nil",
      "      else",
      "        par.right = nil",
      "      end",
      "    else",
      "      @root = nil",
      "    end",
      "    node = par",
      " ",
      "    while node",
      "      new_level = { level(node.left), level(node.right) }.min + 1",
      "      if new_level < node.level",
      "        node.level = new_level",
      "        if new_level < level(node.right)",
      "          node.right.not_nil!.level = new_level",
      "        end",
      "      end",
      " ",
      "      node.size -= 1",
      "      node = skew(node).not_nil!",
      "      skew(node.right.not_nil!.right) if skew(node.right)",
      " ",
      "      node = split(node)",
      "      split(node.not_nil!.right)",
      " ",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "    end",
      "    true",
      "  end",
      " ",
      "  # TODO: Improve performance",
      "  def delete_at(k : Int)",
      "    key = key_at(k)",
      "    delete_key(key)",
      "  end",
      " ",
      "  # TODO: Improve performance",
      "  def delete_at(k : Int)",
      "    key = key_at?(k)",
      "    return if key.nil?",
      "    delete_key(key)",
      "  end",
      " ",
      "  def has_key?(key : K) : Bool",
      "    return false unless @root",
      "    node = find_node(@root, key)",
      "    node.nil? ? false : node.key == key",
      "  end",
      " ",
      "  def lower_bound_index(key : K) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if key <= node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      " ",
      "  def upper_bound_index(key : K) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if key < node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      "",
      "  def less_index(key : K) : Int32?",
      "    index = lower_bound_index(key)",
      "    index == 0 ? nil : index - 1",
      "  end",
      "  ",
      "  def less_equal_index(key : K) : Int32?",
      "    index = lower_bound_index(key)",
      "    key == at?(index) ? index : (index == 0 ? nil : index - 1)",
      "  end",
      "  ",
      "  def greater_index(key : K) : Int32?",
      "    index = upper_bound_index(key)",
      "    index == size ? nil : index",
      "  end",
      "  ",
      "  def greater_equal_index(key : K) : Int32?",
      "    index = lower_bound_index(key)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def size : Int32",
      "    @root ? @root.not_nil!.size : 0",
      "  end",
      " ",
      "  def to_a : Array({K, V})",
      "    res = Array({K, V}).new",
      "    return res unless @root",
      "    dfs = uninitialized Proc(Node(K, V), Nil)",
      "    dfs = ->(node : Node(K, V)) do",
      "      dfs.call(node.left.not_nil!) if node.left",
      "      res << {node.key, node.value}",
      "      dfs.call(node.right.not_nil!) if node.right",
      "      nil",
      "    end",
      "    dfs.call(@root.not_nil!)",
      "    res",
      "  end",
      " ",
      "  def to_s(io : IO) : Nil",
      "    io << \"{\" + to_a.map{ |key, value| \"#{key} => #{value}\" }.join(\", \") + \"}\"",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      " ",
      "  def <<(item : {K, V}) : Nil; upsert(item[0], item[1]) end",
      " ",
      "  def [](key : K) : V",
      "    return @default.not_nil! if @root.nil? && !@default.nil?",
      "    raise KeyError.new \"Missing key: #{key.inspect}\" unless @root",
      "    node = find_node(@root, key)",
      "    return @default.not_nil! if node.not_nil!.key != key && !@default.nil?",
      "    raise KeyError.new \"Missing key: #{key.inspect}\" if node.not_nil!.key != key",
      "    node.not_nil!.value",
      "  end",
      " ",
      "  def []?(key : K) : V?",
      "    return @default if @root.nil?",
      "    node = find_node(@root, key)",
      "    return @default if node.not_nil!.key != key",
      "    node.not_nil!.value",
      "  end",
      " ",
      "  def []=(key : K, value : V) : V",
      "    upsert(key, value)",
      "    value",
      "  end",
      "end"
    ],
    "description": "AATreeMap"
  },
  "SegmentTree": {
    "prefix": "SegmentTree",
    "body": [
      "class SegmentTree(S)",
      "  include Enumerable(S)",
      "",
      "  getter size : Int32",
      "  delegate empty?, to: @nodes",
      "",
      "  @op : S, S -> S",
      "  @e : -> S",
      "",
      "  @log : Int32",
      "  @n : Int32",
      "  @nodes : Array(S)",
      "",
      "  def self.max(elems : Enumerable(S))",
      "    new elems, ->(x : S, y : S){ x > y ? x : y }, ->(){ S::MIN }",
      "  end",
      "",
      "  def self.min(elems : Enumerable(S))",
      "    new elems, ->(x : S, y : S){ x < y ? x : y }, ->(){ S::MAX }",
      "  end",
      "",
      "  def initialize(elems : Enumerable(S), @op : S, S -> S, @e : -> S)",
      "    @size = elems.size",
      "",
      "    @log = 0",
      "    while ((1 << @log) < @size)",
      "      @log += 1",
      "    end",
      "    @n = (1 << @log)",
      "",
      "    @nodes = Array.new(2 * @n){ e.call }",
      "",
      "    elems.each_with_index{ |x, i| @nodes[@n + i] = x}",
      "    (1..@n - 1).reverse_each{ |i| update(i) }",
      "  end",
      "",
      "  def set(i : Int, val : S) : Nil",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    @nodes[i] = val",
      "    (1..@log).each{ |j| update(i >> j) }",
      "  end",
      "",
      "  def at(i : Int) : S",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    @nodes[i + @n]",
      "  end",
      "",
      "  def at?(i : Int) : S?",
      "    return nil unless 0 <= i && i < @size",
      "    at(i)",
      "  end",
      "",
      "  def each(& : S ->)",
      "    @size.times do |i|",
      "      yield at(i)",
      "    end",
      "  end",
      "",
      "  def prod(l : Int, r : Int) : S",
      "    raise IndexError.new unless 0 <= l && l <= r && r <= @size",
      "    sml, smr = @e.call, @e.call",
      "    l += @n",
      "    r += @n",
      "    while l < r",
      "      sml = @op.call(sml, @nodes[(l += 1) - 1]) if l.odd?",
      "      smr = @op.call(@nodes[r -= 1], smr) if r.odd?",
      "      l >>= 1",
      "      r >>= 1",
      "    end",
      "    @op.call(sml, smr)",
      "  end",
      "",
      "  def prod(range : Range(Int, Int)) : S",
      "    prod(range.begin, range.exclusive? ? range.end : range.end + 1)",
      "  end",
      "",
      "  def prod?(l : Int, r : Int) : S?",
      "    return nil unless 0 <= l && l <= r && r <= @size",
      "  end",
      "",
      "  def prod?(range : Range(Int, Int)) : S?",
      "    prod?(range.begin, range.exclusive? ? range.end : range.end + 1)",
      "  end",
      "",
      "  def all_prod",
      "    @nodes[1]",
      "  end",
      "",
      "  def all_prod?",
      "    @nodes[1]?",
      "  end",
      "",
      "  def max_right(l : Int, ok : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= l && l <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless ok.call(@e.call)",
      "    return @size if l == @size",
      "    l += @n",
      "    sm = @e.call",
      "    loop do",
      "      while l.even?",
      "        l >>= 1",
      "      end",
      "      unless ok.call(@op.call(sm, @nodes[l]))",
      "        while l < @n",
      "          l = 2 * l",
      "          if ok.call(@op.call(sm, @nodes[l]))",
      "            sm = @op.call(sm, @nodes[l])",
      "            l += 1",
      "          end",
      "        end",
      "        return (l - @n).to_i",
      "      end",
      "      sm = @op.call(sm, @nodes[l])",
      "      l += 1",
      "      break if (l & -l) == l",
      "    end",
      "    @size",
      "  end",
      "",
      "  def max_right?(l : Int, ok : S -> Bool) : Int32?",
      "    return nil unless 0 <= l && l <= @size",
      "    return nil unless ok.call(@e.call)",
      "    max_right(l, ok)",
      "  end",
      "",
      "  def min_left(r : Int, ok : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= r && r <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless ok.call(@e.call)",
      "    return 0 if r == 0",
      "    r += @n",
      "    sm = @e.call",
      "    loop do",
      "      r -= 1",
      "      while r > 1 && r.odd?",
      "        r >>= 1",
      "      end",
      "      unless ok.call(@op.call(@nodes[r], sm))",
      "        while r < @n",
      "          r = 2 * r + 1",
      "          if ok.call(@op.call(@nodes[r], sm))",
      "            sm = @op.call(@nodes[r], sm)",
      "            r -= 1",
      "          end",
      "        end",
      "        return (r + 1 - @n).to_i",
      "      end",
      "      break if (r & -r) == r",
      "    end",
      "    0",
      "  end",
      "",
      "  def min_left?(r : Int, ok : S -> Bool) : Int32?",
      "    return nil unless 0 <= r && r <= @size",
      "    return nil unless ok.call(@e.call)",
      "    min_left(r, ok)",
      "  end",
      "",
      "  def [](i : Int); at(i) end",
      "  def []?(i : Int); at?(i) end",
      "  def []=(i : Int, val : S); set(i, val) end",
      "",
      "  def to_a : Array(S)",
      "    Array(S).new(@size){ |i| at(i) }",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    @size.times do |i|",
      "      io << \" \" unless i == 0",
      "      io << at(i)",
      "    end",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      "",
      "  private def update(k : Int)",
      "    @nodes[k] = @op.call(@nodes[2 * k], @nodes[2 * k + 1])",
      "  end",
      "end"
    ],
    "description": "SegmentTree"
  },
  "LazySegmentTree": {
    "prefix": "LazySegmentTree",
    "body": [
      "class LazySegmentTree(S, F)",
      "  include Enumerable(S)",
      "",
      "  getter size : Int32",
      "",
      "  @op : S, S -> S",
      "  @mapping : F, S -> S",
      "  @composition : F, F -> F",
      "",
      "  @log : Int32",
      "  @n : Int32",
      "  @nodes : Array(S)",
      "  @lazy_nodes : Array(F)",
      "",
      "  def initialize(elems : Enumerable(S), @op : S, S -> S, @e : -> S, @mapping : F, S -> S, @composition : F, F -> F, @id : -> F)",
      "    @size = elems.size",
      "",
      "    @log = 0",
      "    while ((1 << @log) < @size)",
      "      @log += 1",
      "    end",
      "    @n = (1 << @log)",
      "",
      "    @nodes = Array.new(2 * @n){ @e.call }",
      "    @lazy_nodes = Array.new(@n){ @id.call }",
      "    ",
      "    elems.each_with_index{ |x, i| @nodes[@n + i] = x }",
      "    (1...@n).reverse_each do |i|",
      "      update(i)",
      "    end",
      "  end",
      "",
      "  def self.range_add_range_min(elems : Enumerable(S))",
      "    op = ->(a : S, b : S){ a < b ? a : b }",
      "    e = ->(){ S::MAX // 2 }",
      "    mapping = ->(f : F, x : S){ f + x }",
      "    composition = ->(f : F, g : F){ f + g }",
      "    id = ->(){ F.zero }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  def self.range_add_range_max(elems : Enumerable(S))",
      "    op = ->(a : S, b : S){ a > b ? a : b }",
      "    e = ->(){ S::MIN // 2 }",
      "    mapping = ->(f : F, x : S){ f + x }",
      "    composition = ->(f : F, g : F){ f + g }",
      "    id = ->(){ F.zero }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  struct Intervalish(T)",
      "    property val : T",
      "    property size : Int64",
      "    def initialize(@val : T, @size : Int64)",
      "    end",
      "",
      "    def to_s(io : IO)",
      "      io << @val",
      "    end",
      "  end",
      "",
      "  # TODO",
      "  def self.range_add_range_sum(elems : Enumerable(ModInt))",
      "    op = ->(a : Intervalish(ModInt), b : Intervalish(ModInt)){ Intervalish(ModInt).new(a.val + b.val, a.size + b.size) }",
      "    e = ->(){ Intervalish(ModInt).new(ModInt.zero, 0_i64) }",
      "    mapping = ->(f : F, x : Intervalish(ModInt)){ Intervalish(ModInt).new(x.val + f * x.size, x.size) }",
      "    composition = ->(f : F, g : F){ f + g }",
      "    id = ->(){ F.zero }",
      "    new elems.map{ |elem| Intervalish(ModInt).new(elem, 1_i64) }, op, e, mapping, composition, id",
      "  end",
      "",
      "  def set(i : Int, val : S) : Nil",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    (1..@log).reverse_each{ |j| push(i >> j) }",
      "    @nodes[i] = val",
      "    (1..@log).each{ |j| update(i >> j)}",
      "  end",
      "",
      "  def at(i : Int) : S",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    (1..@log).reverse_each{ |j| push(i >> j) }",
      "    @nodes[i]",
      "  end",
      "",
      "  def at?(i : Int) : S?",
      "    return nil unless 0 <= i && i < @size",
      "    at(i)",
      "  end",
      "",
      "  def each(& : S ->)",
      "    @size.times do |i|",
      "      yield at(i)",
      "    end",
      "  end",
      "",
      "  def prod(l : Int, r : Int) : S",
      "    raise IndexError.new unless 0 <= l && l <= r && r <= @size",
      "    return @e.call if l == r",
      "",
      "    l += @n",
      "    r += @n",
      "",
      "    (1..@log).each do |i|",
      "      j = @log - i + 1",
      "      push(l >> j) if ((l >> j) << j) != l",
      "      push((r - 1) >> j) if ((r >> j) << j) != r",
      "    end",
      "",
      "    sml, smr = @e.call, @e.call",
      "    while l < r",
      "      sml = @op.call(sml, @nodes[(l += 1) - 1]) if l.odd?",
      "      smr = @op.call(@nodes[r -= 1], smr) if r.odd?",
      "      l >>= 1",
      "      r >>= 1",
      "    end",
      "",
      "    @op.call(sml, smr)",
      "  end",
      "",
      "  def prod?(l : Int, r : Int) : S?",
      "    return nil unless 0 <= l && l <= r && r <= @size",
      "    prod(l, r)",
      "  end",
      "",
      "  def prod(range : Range(Int, Int)) : S",
      "    prod(range.begin, range.exclusive? ? range.end : range.end + 1)",
      "  end",
      "",
      "  def prod?(range : Range(Int, Int)) : S?",
      "    prod?(range.begin, range.exclusive? ? range.end : range.end + 1)",
      "  end",
      "",
      "  def all_prod : S",
      "    @nodes[1]",
      "  end",
      "",
      "  def all_prod? : S?",
      "    @nodes[1]?",
      "  end",
      "",
      "  def apply(i : Int, f : F) : Nil",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    (1..@log).reverse_each{ |j| push(i >> j) }",
      "    @nodes[i] = @mapping.call(f, @nodes[i])",
      "    (1..@log).each{ |j| update(i >> j) }",
      "  end",
      "",
      "  def apply(l : Int, r : Int, f : F) : Nil",
      "    raise IndexError.new unless 0 <= l && l <= r && r <= @size",
      "    return if l == r",
      "",
      "    l += @n",
      "    r += @n",
      "",
      "    (1..@log).reverse_each do |i|",
      "      push(l >> i) if ((l >> i) << i) != l",
      "      push((r - 1) >> i) if ((r >> i) << i) != r",
      "    end",
      "",
      "    l2, r2 = l, r",
      "    while l < r",
      "      all_apply((l += 1) - 1, f) if l.odd?",
      "      all_apply(r -= 1, f) if r.odd?",
      "      l >>= 1",
      "      r >>= 1",
      "    end",
      "    l, r = l2, r2",
      "",
      "    (1..@log).each do |i|",
      "      update(l >> i) if ((l >> i) << i) != l",
      "      update((r - 1) >> i) if ((r >> i) << i) != r",
      "    end",
      "  end",
      "",
      "  def apply(range : Range(Int, Int), f : F)",
      "    apply(range.begin, range.exclusive? ? range.end : range.end + 1, f)",
      "  end",
      "",
      "  def apply?(i : Int, f : F) : Bool",
      "    return false unless 0 <= i && i < @size",
      "    apply(i, f)",
      "    true",
      "  end",
      "",
      "  def apply?(l : Int, r : Int, f : F) : Bool",
      "    return false unless 0 <= l && l <= r && r <= @size",
      "    apply(l, r, f)",
      "    true",
      "  end",
      "",
      "  def apply?(range : Range(Int, Int), f : F) : Bool",
      "    l = range.begin",
      "    r = range.exclusive? ? range.end : range.end + 1",
      "    return false unless 0 <= l && l <= r && r <= @size",
      "    apply(l, r, f)",
      "    true",
      "  end",
      "",
      "  def max_right(l : Int, ok : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= l && l <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless ok.call(@e.call)",
      "    return @size if l == @size",
      "    l += @n",
      "    (1..@log).each{ |i| push(l >> i) }",
      "    sm = @e.call",
      "    loop do",
      "      while l.even?",
      "        l >>= 1",
      "      end",
      "      unless ok.call(@op.call(sm, @nodes[l]))",
      "        while l < @n",
      "          push(l)",
      "          l = 2 * l",
      "          if ok.call(@op.call(sm, @nodes[l]))",
      "            sm = @op.call(sm, @nodes[l])",
      "            l += 1",
      "          end",
      "        end",
      "        return (l - @n).to_i",
      "      end",
      "      sm = @op.call(sm, @nodes[l])",
      "      l += 1",
      "      break if (l & -l) == l",
      "    end",
      "    @size",
      "  end",
      "",
      "  def max_right?(l : Int, ok : S -> Bool) : Int32?",
      "    return nil unless 0 <= l && l <= @size",
      "    return nil unless ok.call(@e.call)",
      "    max_right(l, ok)",
      "  end",
      "",
      "  def min_left(r : Int, ok : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= r && r <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless ok.call(@e.call)",
      "    return 0 if r == 0",
      "    r += @n",
      "    (1..@log).reverse_each{ |i| push((r - 1) >> i) }",
      "    sm = @e.call",
      "    loop do",
      "      r -= 1",
      "      while r > 1 && r.odd?",
      "        r >>= 1",
      "      end",
      "      unless ok.call(@op.call(@nodes[r], sm))",
      "        while r < @n",
      "          push(r)",
      "          r = 2 * r + 1",
      "          if ok.call(@op.call(@nodes[r], sm))",
      "            sm = @op.call(@nodes[r], sm)",
      "            r -= 1",
      "          end",
      "        end",
      "        return (r + 1 - @n).to_i",
      "      end",
      "      break if (r & -r) == r",
      "    end",
      "    0",
      "  end",
      "",
      "  def min_left?(r : Int, ok : S -> Bool) : Int32?",
      "    return nil unless 0 <= r && r <= @size",
      "    return nil unless ok.call(@e.call)",
      "    min_left(r, ok)",
      "  end",
      "",
      "  def [](i : Int); at(i) end",
      "  def []?(i : Int); at?(i) end",
      "  def []=(i : Int, val : S); set(i, val) end",
      "",
      "  def to_a : Array(S)",
      "    Array(S).new(@size){ |i| at(i) }",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    @size.times do |i|",
      "      io << \" \" unless i == 0",
      "      io << at(i)",
      "    end",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      "",
      "  private def update(k : Int) : Nil",
      "    @nodes[k] = @op.call(@nodes[2 * k], @nodes[2 * k + 1])",
      "  end",
      "",
      "  private def all_apply(k : Int, f : F) : Nil",
      "    @nodes[k] = @mapping.call(f, @nodes[k])",
      "    @lazy_nodes[k] = @composition.call(f, @lazy_nodes[k]) if k < @n",
      "  end",
      "",
      "  private def push(k : Int) : Nil",
      "    all_apply(2 * k, @lazy_nodes[k])",
      "    all_apply(2 * k + 1, @lazy_nodes[k])",
      "    @lazy_nodes[k] = @id.call",
      "  end",
      "end"
    ],
    "description": "LazySegmentTree"
  },
  "ConvexHullTrick": {
    "prefix": "ConvexHullTrick",
    "body": [
      "class ConvexHullTrick(T)",
      "  getter lines : Array({T, T})",
      "  @head : Int32",
      "",
      "  def initialize",
      "    @head = 0",
      "    @lines = Array({T, T}).new",
      "  end",
      "",
      "  def add(k : T, b : T)",
      "    line = {k, b}",
      "    while @lines.size - @head >= 2 && check(@lines[-2], @lines.last, line)",
      "      @lines.pop",
      "    end",
      "    @lines << line",
      "  end",
      "",
      "  def min(x : T)",
      "    while @lines.size - @head >= 2 && @lines[@head][0] * x + @lines[@head][1] >= @lines[@head + 1][0] * x + @lines[@head + 1][1]",
      "      @head += 1",
      "    end",
      "    @lines[@head][0] * x + @lines[@head][1]",
      "  end",
      "",
      "  private def check(l1 : {T, T}, l2 : {T, T}, l3 : {T, T})",
      "    (l2[0] - l1[0]) * (l3[1] - l2[1]) >= (l2[1] - l1[1]) * (l3[0] - l2[0])",
      "  end",
      "end"
    ],
    "description": "ConvexHullTrick"
  },
  "DoublyLinkedList": {
    "prefix": "DoublyLinkedList",
    "body": [
      "class DoublyLinkedList(T)",
      "  class Node(T)",
      "    protected property pred : Node(T)?",
      "    protected property next : Node(T)?",
      "    @val : T",
      "    protected property dummy : Bool",
      "",
      "    def initialize(@pred : Node(T)?, @next : Node(T)?, @val : T, @dummy : Bool = false)",
      "    end",
      "",
      "    getter(val){ dummy ? nil.not_nil! : val }",
      "    getter?(val){ dummy ? nil : val }",
      "    setter val",
      "  end",
      "",
      "  getter head : Node(T)",
      "  getter tail : Node(T)",
      "  getter size : Int32",
      "",
      "  def initialize",
      "    @head = Node(T).new(nil, nil, T.new, dummy: true)",
      "    @tail = @head",
      "    @size = 0",
      "  end",
      "",
      "",
      "  # リストに要素を右側（tail側）に挿入します。",
      "  #",
      "  # 挿入された右側のノードを返します。",
      "  #",
      "  # ```",
      "  # list = DoublyLinkedList(Int32).new",
      "  # it = list.insert_right(list.head, 10)",
      "  # it = list.insert_right(it, 20)",
      "  # it = list.insert_right(it, 30)",
      "  # list # => [10, 20, 30]",
      "  # ```",
      "  def insert_right(node : Node(T), val : T)",
      "    @size += 1",
      "    if @size == 1",
      "      @head = Node.new(nil, nil, val)",
      "      @tail = @head",
      "      return @head",
      "    else",
      "      if node.next.nil?",
      "        node.next = Node.new(pred: node, next: nil, val: val)",
      "        @tail = node.next.not_nil!",
      "        @tail.pred = node",
      "      else",
      "        tmp = node.next.not_nil!",
      "        node.next = Node.new(pred: node, next: tmp, val: val)",
      "        tmp.pred = node.next",
      "      end",
      "      return node.next.not_nil!",
      "    end",
      "  end",
      "",
      "  # リストに要素を左側（head側）に挿入します。",
      "  #",
      "  # 挿入された左側のノードを返します。",
      "  #",
      "  # ```",
      "  # list = DoublyLinkedList(Int32).new",
      "  # it = list.insert_left(list.head, 10)",
      "  # it = list.insert_left(it, 20)",
      "  # it = list.insert_left(it, 30)",
      "  # list # => [30, 20, 10]",
      "  # ```",
      "  def insert_left(node : Node(T), val : T)",
      "    @size += 1",
      "    if @size == 1",
      "      @head = Node.new(nil, nil, val)",
      "      @tail = @head",
      "      return @head",
      "    else",
      "      if node.pred.nil?",
      "        node.pred = Node.new(pred: nil, next: node, val: val)",
      "        @head = node.pred.not_nil!",
      "        @head.next = node",
      "      else",
      "        tmp = node.pred.not_nil!",
      "        node.pred = Node.new(pred: tmp, next: node, val: val)",
      "        tmp.next = node.pred",
      "      end",
      "      return node.pred.not_nil!",
      "    end",
      "  end",
      "",
      "  # ノードを削除します。",
      "  #",
      "  # 削除された右側のノードを返します。",
      "  #",
      "  # ```",
      "  # list = DoublyLinkedList(Int32).new [1, 2, 3]",
      "  # list # => [10, 20, 30]",
      "  # list.erase(list.head)",
      "  # list # => [20, 30]",
      "  # ```",
      "  def erase(node : Node(T))",
      "    raise Exception.new(\"無効なノードを削除しようとしています。\") if node.val?.nil?",
      "    if node == @head",
      "      @head = @head.next.nil? ? Node.new(nil, nil, nil) : @head.next",
      "      @tail = @head if @head.val?.nil?",
      "    elsif node == @head",
      "    else",
      "    end",
      "    pre = node.pred",
      "    nxt = node.next",
      "    pre.next = nxt",
      "    nxt.pred = pre",
      "  end",
      "",
      "",
      "  def to_s(io : IO)",
      "    return if @size == 0",
      "    node = @head",
      "    io << \"[\"",
      "    loop do",
      "      io << node.not_nil!.val",
      "      node = node.next",
      "      break if node.nil? || node.val?.nil?",
      "      io << \", \"",
      "    end",
      "    io << \"]\"",
      "  end",
      "end"
    ],
    "description": "双方向リスト [WIP]"
  },


  // マラソン
  "XorShift": {
    "prefix": "XorShift",
    "body": [
      "class XorShift",
      "  def initialize",
      "    @m1 = 1859738746",
      "    @m2 = 9707750167",
      "    @m3 = 2653432786",
      "    @m4 = 3463085849",
      "  end",
      "",
      "  def next_int32(n : Int32)",
      "    revolve",
      "    (@m4 % n).to_i32",
      "  end",
      "",
      "  def next_int32(a : Int32, b : Int32)",
      "    revolve",
      "    (@m4 % (b - a) + a).to_i32",
      "  end",
      "",
      "  def next_int32(range : Range(Int32, Int32))",
      "    next_int32(range.begin, range.end + (range.exclusive? ? 0 : 1))",
      "  end",
      "",
      "  def next_int64(n : Int64)",
      "    revolve",
      "    (@m4 % n).to_i64",
      "  end",
      "",
      "  def next_int64(a : Int64, b : Int64)",
      "    revolve",
      "    (@m4 % (b - a) + a).to_i64",
      "  end",
      "",
      "  def next_int64(range : Range(Int64, Int64))",
      "    next_int64(range.begin, range.end + (range.exclusive? ? 0 : 1))",
      "  end",
      "",
      "  private def revolve",
      "    t = @m1 ^ (@m1 << 11_u64)",
      "    @m1, @m2, @m3 = @m2, @m3, @m4",
      "    @m4 = (@m4 ^ (@m4 >> 19_u64)) ^ (t ^ (t >> 8_u64))",
      "  end",
      "end"
    ],
    "description": "XorShift"
  },
  "Stopwatch": {
    "prefix": "Stopwatch",
    "body": [
      "class Stopwatch",
      "  def initialize",
      "    @start = Time.utc",
      "  end",
      "",
      "  def reset",
      "    @start = Time.utc",
      "  end",
      "",
      "  def ms",
      "    Time.utc.to_unix_ms - @start.to_unix_ms",
      "  end",
      "",
      "  def sec",
      "    ms / 1000",
      "  end",
      "",
      "  def to_s(io)",
      "    io << ms << \"ms\"",
      "  end",
      "end"
    ],
    "description": "Stopwatch"
  },
}