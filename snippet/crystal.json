{
  //────────────────────────────────────────────────────
  // 楽をする・STL的な
  //────────────────────────────────────────────────────
  "YesNo出力": {
    "prefix": "yn",
    "body": "puts ${1:condition} ? \"Yes\" : \"No\"",
    "description": "yesno"
  },
  "整数複素数": {
    "prefix": "ComplexInt",
    "body": [
      "struct ComplexInt",
      "  getter real : Int64",
      "  getter imag : Int64",
      "",
      "  def initialize",
      "    @real = 0_i64",
      "    @imag = 0_i64",
      "  end",
      "",
      "  def self.zero; ComplexInt.new end",
      "",
      "  def initialize(@real : Int64, @imag : Int64)",
      "  end",
      "",
      "  def r; Math.sqrt((@real**2 + @imag**2).to_f64) end",
      "  def theta; Math.atan2(@real.to_f64, @imag.to_f64) end",
      "",
      "  def + : self; self end",
      "  def - : self; ComplexInt.new(-@real, -@imag) end",
      "",
      "  def +(other : self); ComplexInt.new(@real + other.real, @imag + other.imag) end",
      "  def -(other : self); ComplexInt.new(@real - other.real, @imag - other.imag) end",
      "  def *(other : self); ComplexInt.new(@real*other.real - @imag*other.imag, @real*other.imag + @imag*other.real) end",
      "  def /(other : self); self * ComplexInt.new(other.real, -other.imag) / (other.real**2 + other.imag**2) end",
      "",
      "  def +(other : Int); ComplexInt.new(@real + other, @imag) end",
      "  def -(other : Int); ComplexInt.new(@real - other, @imag) end",
      "  def *(other : Int); ComplexInt.new(@real*other, @imag*other) end",
      "  def /(other : Int); ComplexInt.new(@real / other, @imag / other) end",
      "  def //(other : Int); ComplexInt.new(@real // other, @imag // other) end",
      "",
      "  def <=>(other : self); {@real, @imag} <=> {other.real, other.imag} end",
      "end",
      "alias C = ComplexInt"
    ],
    "description": "ComplexInt"
  },
  "n次元配列生成": {
    "prefix": "make_array",
    "body": [
      "macro make_array(s, x)",
      "  Array.new({{ s[0] }}){",
      "    {% if s[1..s.size].empty? %}; {{ x }}",
      "    {% else %}; make_array({{ s[1..s.size] }}, {{ x }}) {% end %}",
      "  }",
      "end"
    ],
    "description": "make_array"
  },
  "座標圧縮": {
    "prefix": ["zaatu", "compress", "mapping"],
    "body": [
      "class Array(T)",
      "  def compress",
      "    b = clone.sort.uniq",
      "    map{ |s| b.bsearch_index{ |x| x >= s } || b.size }",
      "  end",
      "",
      "  def mapping",
      "    b = clone.sort.uniq",
      "    f, g = Hash(Int64, Int64).new, Hash(Int64, Int64).new",
      "    each do |s|",
      "      index = b.bsearch_index{ |x| x >= s } || b.size",
      "      f[s] = index",
      "      g[index] = s",
      "    end",
      "    {f, g}",
      "  end",
      "end"
    ],
    "description": "座標圧縮"
  },
  "next_permutation": {
    "prefix": ["next_permutation", "prev_permutation"],
    "body": [
      "class Array(T)",
      "  def next_permutation!",
      "    return nil if self.empty?",
      "",
      "    prev = self.last",
      "    i = self.rindex{ |v| v < prev || (prev = v; false) }",
      "",
      "    unless i",
      "      self.reverse!",
      "      return nil",
      "    end",
      "",
      "    key = self[i]",
      "    j = self.rindex{ |v| v > key }.not_nil!",
      "    self.swap(i, j)",
      "    self[i+1..-1] = self[i+1..-1].reverse!",
      "    return self",
      "  end",
      "",
      "  def prev_permutation!",
      "    return nil if self.empty?",
      "",
      "    prev = self.last",
      "    i = self.rindex{ |v| v > prev || (prev = v; false) }",
      "",
      "    unless i",
      "      self.reverse!",
      "      return nil",
      "    end",
      "",
      "    key = self[i]",
      "    j = self.rindex{ |v| v < key }.not_nil!",
      "    self.swap(i, j)",
      "    self[i+1..-1] = self[i+1..-1].reverse!",
      "    return self",
      "  end",
      "end"
    ],
    "description": "next_permutation"
  },

  //────────────────────────────────────────────────────
  // グラフ理論
  //────────────────────────────────────────────────────
  "幅優先探索": {
    "prefix": "BfsGraph",
    "body": [
      "class BfsGraph",
      "  getter size : Int32",
      "  getter graph : Array(Array(Int32))",
      "",
      "  # n 頂点 0 辺からなるグラフを作成します。",
      "  #",
      "  # ```",
      "  # graph = BfsGraph.new(n)",
      "  # ```",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @graph = Array.new(@size){ Array(Int32).new }",
      "  end",
      "",
      "  # 辺 (u, v) を追加します。",
      "  #",
      "  # `directed` が `true` の場合、",
      "  # 無向グラフとみなして、両端から辺を生やします。",
      "  #",
      "  # ```",
      "  # graph = BfsGraph.new(n)",
      "  # graph.add_edge(u, v) # => (u) <---w---> (v)",
      "  # graph.add_edge(u, v, directed: false) # => (u) ----w---> (v)",
      "  # ```",
      "  def add_edge(u : Int, v : Int, directed : Bool = true)",
      "    @graph[u.to_i32] << v.to_i32",
      "    @graph[v.to_i32] << u.to_i32 if directed",
      "  end",
      "",
      "  # 全点対間の最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dists = graph.shortest_path",
      "  # dists # => [[0, 1, 3], [1, 0, 2], [1, 1, 0]]",
      "  # ```",
      "  def shortest_path",
      "    (0...@size).map{ |s| shortest_path(s) }",
      "  end",
      "",
      "  # 始点 `start` から各頂点への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(start: 2)",
      "  # dist # => [3, 8, 0, 7, 1]",
      "  # ```",
      "  def shortest_path(start : Int)",
      "    queue = Deque.new([start.to_i32])",
      "    dist = Array.new(@size){ |i| i == start ? 0_i64 : OO }",
      "    until queue.empty?",
      "      from = queue.shift",
      "      @graph[from].each do |to|",
      "        next if dist[to] != OO",
      "        dist[to] = dist[from] + 1",
      "        queue << to",
      "      end",
      "    end",
      "    dist",
      "  end",
      "",
      "  # 始点 `start` から終点 `dest` への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(start: 2, dest: 0)",
      "  # dist # => 12",
      "  # ```",
      "  def shortest_path(start : Int, dest : Int)",
      "    shortest_path(start)[dest]",
      "  end",
      "end"
    ],
    "description": "BfsGraph"
  },
  "重み付き辺": {
    "prefix": "Edge",
    "body": [
      "struct Edge",
      "  @data : {Int64, Int64}",
      "  def initialize(t : Int64, w : Int64)",
      "    @data = {t, w}",
      "  end",
      "",
      "  def self.to; @data[0] end",
      "  def self.weight; @data[1] end",
      "  def [](i : Int); @data[i] end",
      "end",
      "alias Edges = Array(Edge)",
      "alias Graph = Array(Edges)"
    ],
    "description": "Edge"
  },
  "ダイクストラ法（基数ヒープ）": {
    "prefix": "RadixDijkstraGraph",
    "body": [
      "class DijkstraGraph",
      "  record Edge, target : Int32, weight : UInt64",
      "",
      "  # 基数ヒープ",
      "  class RadixHeap64(T)",
      "    @s : Int32",
      "    @last : UInt64",
      "    @bit : Int32",
      "    @vs : Array(Array({UInt64, T}))",
      "    @ms : Array(UInt64)",
      "",
      "    def initialize",
      "      @s = 0",
      "      @last = 0_u64",
      "      @bit = sizeof(UInt64) * 8",
      "      @vs = Array.new(@bit + 1){ [] of {UInt64, T} }",
      "      @ms = Array.new(@bit + 1){ -1.to_u64! }",
      "    end",
      "",
      "    def empty? : Bool",
      "      @s == 0",
      "    end",
      "",
      "    def size : Int32",
      "      s",
      "    end",
      "",
      "    @[AlwaysInline]",
      "    def get_bit(x : UInt64) : UInt64",
      "      64_u64 - x.leading_zeros_count",
      "    end",
      "",
      "    def push(key : UInt64, val : T) : Nil",
      "      @s += 1",
      "      b = get_bit(key ^ @last)",
      "      @vs[b] << {key, val}",
      "      @ms[b] = Math.min(@ms[b], key)",
      "    end",
      "",
      "    def pop : {UInt64, T}",
      "      if @ms[0] == -1.to_u64!",
      "        idx = @ms.index{ |m| m != -1.to_u64! }.not_nil!",
      "        @last = @ms[idx]",
      "        @vs[idx].each do |v|",
      "          b = get_bit(v[0] ^ @last)",
      "          @vs[b] << v",
      "          @ms[b] = Math.min(@ms[b], v[0])",
      "        end",
      "        @vs[idx].clear",
      "        @ms[idx] = -1.to_u64!",
      "      end",
      "",
      "      @s -= 1",
      "      res = @vs[0].last",
      "      @vs[0].pop",
      "      @ms[0] = -1.to_u64! if @vs[0].empty?",
      "",
      "      res",
      "    end",
      "  end",
      "",
      "  getter size : Int32",
      "  @graph : Array(Array(Edge))",
      "",
      "  # n 頂点 0 辺からなるグラフを作成します。",
      "  #",
      "  # ```",
      "  # graph = Dijkstra.new(n)",
      "  # ```",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @graph = Array.new(@size){ Array(Edge).new }",
      "  end",
      "",
      "  # 非負整数の重み w の辺 (u, v) を追加します。",
      "  #",
      "  # `directed` が `true` の場合、",
      "  # 無向グラフとみなして、両端から辺を生やします。",
      "  #",
      "  # ```",
      "  # graph = Dijkstra.new(n)",
      "  # graph.add_edge(u, v, w) # => (u) <---w---> (v)",
      "  # graph.add_edge(u, v, w, directed: false) # => (u) ----w---> (v)",
      "  # ```",
      "  def add_edge(u : Int, v : Int, w : Int, directed : Bool = true)",
      "    @graph[u.to_i32] << Edge.new(v.to_i32, w.to_u64)",
      "    @graph[v.to_i32] << Edge.new(u.to_i32, w.to_u64) if directed",
      "  end",
      "",
      "  # 全点対間の最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dists = graph.shortest_path",
      "  # dists # => [[0, 1, 3], [1, 0, 2], [1, 1, 0]]",
      "  # ```",
      "  def shortest_path",
      "    (0...@size).map{ |s| shortest_path(s) }",
      "  end",
      "",
      "  # 始点 `start` から各頂点への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(2)",
      "  # dist # => [3, 8, 0, 7, 1]",
      "  # ```",
      "  def shortest_path(start : Int)",
      "    dist = [OO] * @size",
      "    dist[start] = 0_i64",
      "    next_node = RadixHeap64(Int32).new",
      "    next_node.push(0_u64, start.to_i32)",
      "",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          next_node.push(next_cost.to_u64, e.target)",
      "        end",
      "      end",
      "    end",
      "",
      "    dist",
      "  end",
      "",
      "  # 始点 `start` から終点 `dest` への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(start: 2, dest: 0)",
      "  # dist # => 12",
      "  # ```",
      "  def shortest_path(start : Int, dest : Int)",
      "    shortest_path(start)[dest]",
      "  end",
      "",
      "  # 始点 `start` から終点 `dest` への最短経路の一例を返します。",
      "  #",
      "  # ```",
      "  # route = graph.shortest_path_route(start: 2, dest: 0)",
      "  # route # => [2, 7, 1, 0]",
      "  # ```",
      "  def shortest_path_route(start, dest)",
      "    prev = impl_memo_route(start)",
      "",
      "    res = Array(Int32).new",
      "    now : Int32? = dest.to_i32",
      "    until now.nil?",
      "      res << now.not_nil!",
      "      now = prev[now]",
      "    end",
      "",
      "    res.reverse",
      "  end",
      "",
      "  # 始点 `start` から最短路木を構築します。",
      "  #",
      "  # 最短路木は `start` からの最短経路のみを残した全域木です。",
      "  #",
      "  # ```",
      "  # route = graph.shortest_path_route(start: 2, dest: 0)",
      "  # route # => [2, 7, 1, 0]",
      "  # ```",
      "  def shortest_path_tree(start, directed : Bool = false) : Array(Array(Int32))",
      "    dist = [OO] * @size",
      "    dist[start] = 0_i64",
      "    next_node = RadixHeap64(Int32).new",
      "    next_node.push(0_u64, start.to_i32)",
      "",
      "    birth = [-1] * @size",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          next_node.push(next_cost.to_u64, e.target)",
      "          birth[e.target] = source",
      "        end",
      "      end",
      "    end",
      "",
      "    tree = Array.new(@size){ [] of Int32 }",
      "    @size.times do |target|",
      "      source = birth[target]",
      "      next if source == -1",
      "      tree[source] << target",
      "      tree[target] << source if directed",
      "    end",
      "",
      "    tree",
      "  end",
      "",
      "  # 経路復元のための「どこから移動してきたか」を",
      "  # メモした配列を返します。",
      "  private def impl_memo_route(start)",
      "    dist = [OO] * @size",
      "    dist[start] = 0_i64",
      "    prev = Array(Int32?).new(@size){ nil }",
      "    next_node = RadixHeap64(Int32).new",
      "    next_node.push(0_u64, start.to_i32)",
      "",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          prev[e.target] = source",
      "          next_node.push(next_cost.to_u64, e.target)",
      "        end",
      "      end",
      "    end",
      "",
      "    prev",
      "  end",
      "end"
    ],
    "description": "DijkstraGraph"
  },
  "ダイクストラ法（抽象化）": {
    "prefix": "AbstractDijkstraGraph",
    "body": [
      "record Weight, length : Int64, n_trees : Int64 do",
      "  include Comparable(Weight)",
      "",
      "  def self.zero",
      "    # Weight.new(0_i64, 0)",
      "  end",
      "",
      "  def self.inf",
      "    # Weight.new(OO, -OO)",
      "  end",
      "",
      "  def +(other : self)",
      "    # Weight.new(@length + other.length, @n_trees + other.n_trees)",
      "  end",
      "",
      "  def <=>(other : self)",
      "    # {@length, -@n_trees} <=> {other.length, -other.n_trees}",
      "  end",
      "end",
      "",
      "class DijkstraGraph(Weight)",
      "  record Edge(W), target : Int32, weight : W",
      "",
      "  getter size : Int32",
      "  @graph : Array(Array(Edge(Weight)))",
      "",
      "  # n 頂点 0 辺からなるグラフを作成します。",
      "  #",
      "  # ```",
      "  # graph = Dijkstra.new(n)",
      "  # ```",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @graph = Array.new(@size){ Array(Edge(Weight)).new }",
      "  end",
      "",
      "  # 非負整数の重み w の辺 (u, v) を追加します。",
      "  #",
      "  # `directed` が `true` の場合、",
      "  # 無向グラフとみなして、両端から辺を生やします。",
      "  #",
      "  # ```",
      "  # graph = Dijkstra.new(n)",
      "  # graph.add_edge(u, v, w) # => (u) <---w---> (v)",
      "  # graph.add_edge(u, v, w, directed: false) # => (u) ----w---> (v)",
      "  # ```",
      "  def add_edge(u : Int, v : Int, w : Weight, directed : Bool = true)",
      "    @graph[u.to_i32] << Edge.new(v.to_i32, w)",
      "    @graph[v.to_i32] << Edge.new(u.to_i32, w) if directed",
      "  end",
      "",
      "  # 全点対間の最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dists = graph.shortest_path",
      "  # dists # => [[0, 1, 3], [1, 0, 2], [1, 1, 0]]",
      "  # ```",
      "  def shortest_path : Array(Array(Weight))",
      "    (0...@size).map{ |s| shortest_path(s) }",
      "  end",
      "",
      "  # 始点 `start` から各頂点への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(2)",
      "  # dist # => [3, 8, 0, 7, 1]",
      "  # ```",
      "  def shortest_path(start : Int) : Array(Weight)",
      "    dist = [Weight.inf] * @size",
      "    dist[start] = Weight.zero",
      "    next_node = Heap({Weight, Int32}).min",
      "    next_node << {Weight.zero, start.to_i32}",
      "",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          next_node << {next_cost, e.target}",
      "        end",
      "      end",
      "    end",
      "",
      "    dist",
      "  end",
      "",
      "  # 始点 `start` から終点 `dest` への最短経路長を返します。",
      "  #",
      "  # ```",
      "  # dist = graph.shortest_path(start: 2, dest: 0)",
      "  # dist # => 12",
      "  # ```",
      "  def shortest_path(start : Int, dest : Int) : Weight",
      "    shortest_path(start)[dest]",
      "  end",
      "",
      "  # 始点 `start` から終点 `dest` への最短経路の一例を返します。",
      "  #",
      "  # ```",
      "  # route = graph.shortest_path_route(start: 2, dest: 0)",
      "  # route # => [2, 7, 1, 0]",
      "  # ```",
      "  def shortest_path_route(start, dest)",
      "    prev = impl_memo_route(start)",
      "",
      "    res = Array(Int32).new",
      "    now : Int32? = dest.to_i32",
      "    until now.nil?",
      "      res << now.not_nil!",
      "      now = prev[now]",
      "    end",
      "",
      "    res.reverse",
      "  end",
      "",
      "  # 始点 `start` から最短路木を構築します。",
      "  #",
      "  # 最短路木は `start` からの最短経路のみを残した全域木です。",
      "  #",
      "  # ```",
      "  # route = graph.shortest_path_route(start: 2, dest: 0)",
      "  # route # => [2, 7, 1, 0]",
      "  # ```",
      "  def shortest_path_tree(start, directed : Bool = false) : Array(Array(Int32))",
      "    dist = [Weight.inf] * @size",
      "    dist[start] = Weight.zero",
      "    next_node = Heap({Weight, Int32}).min",
      "    next_node << {Weight.zero, start.to_i32}",
      "",
      "    birth = [-1] * @size",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          next_node << {next_cost, e.target}",
      "          birth[e.target] = source",
      "        end",
      "      end",
      "    end",
      "",
      "    tree = Array.new(@size){ [] of Int32 }",
      "    @size.times do |target|",
      "      source = birth[target]",
      "      next if source == -1",
      "      tree[source] << target",
      "      tree[target] << source if directed",
      "    end",
      "",
      "    tree",
      "  end",
      "",
      "  # 経路復元のための「どこから移動してきたか」を",
      "  # メモした配列を返します。",
      "  private def impl_memo_route(start)",
      "    dist = [Weight.inf] * @size",
      "    dist[start] = Weight.zero",
      "    prev = Array(Int32?).new(@size){ nil }",
      "    next_node = Heap({Weight, Int32}).min",
      "    next_node << {Weight.zero, start.to_i32}",
      "",
      "    until next_node.empty?",
      "      d, source = next_node.pop",
      "      next if dist[source] < d",
      "      @graph[source].each do |e|",
      "        next_cost = dist[source] + e.weight",
      "        if next_cost < dist[e.target]",
      "          dist[e.target] = next_cost",
      "          prev[e.target] = source",
      "          next_node << {next_cost, e.target}",
      "        end",
      "      end",
      "    end",
      "",
      "    prev",
      "  end",
      "end"
    ],
    "description": "DijkstraGraph"
  },
  "StronglyConnectedComponents": {
    "prefix": "StronglyConnectedComponents",
    "body": [
      "class StronglyConnectedComponents",
      "  alias Graph = Array(Array(Int64))",
      "",
      "  getter leader : Array(Int64)",
      "  getter graph : Graph",
      "  getter groups : Array(Array(Int64))",
      "  @n : Int64",
      "  @order : Array(Int64)",
      "  @fwd : Graph",
      "  @bwd : Graph",
      "  @closed : Array(Bool)",
      "",
      "  def initialize(@fwd : Graph)",
      "    @n = @fwd.size.to_i64",
      "    @order = Array(Int64).new(@n)",
      "    @leader = Array.new(@n, -1_i64)",
      "    @bwd = Array.new(@n){ Array(Int64).new }",
      "    @n.times do |i|",
      "      @fwd[i].each do |j|",
      "        @bwd[j] << i",
      "      end",
      "    end",
      "",
      "    @closed = Array(Bool).new(@n, false)",
      "    @n.times{ |i| dfs(i) }",
      "    @order = @order.reverse",
      "    ptr = rdfs",
      "",
      "    @graph = Array.new(ptr){ Array(Int64).new }",
      "    @groups = Array.new(ptr){ Array(Int64).new }",
      "    @n.times do |i|",
      "      @groups[@leader[i]] << i",
      "      @fwd[i].each do |j|",
      "        x, y = @leader[i], @leader[j]",
      "        next if x == y",
      "        @graph[x] << y",
      "      end",
      "    end",
      "  end",
      "",
      "  def same(u : Int, v : Int)",
      "    leader[u] == leader[v]",
      "  end",
      "",
      "  def size",
      "    @groups.size",
      "  end",
      "",
      "  def size(v : Int)",
      "    @groups[leader[v]].size",
      "  end",
      "",
      "  private def dfs(i : Int)",
      "    return if @closed[i]",
      "    @closed[i] = true",
      "    @fwd[i].each{ |j| dfs(j) }",
      "    @order << i",
      "  end",
      "",
      "  private def rdfs",
      "    ptr = 0_i64",
      "    closed = Array.new(@n, false)",
      "    @order.each do |s|",
      "      next if closed[s]",
      "      que = Deque(Int64).new",
      "      que << s",
      "      closed[s] = true",
      "      @leader[s] = ptr",
      "      until que.empty?",
      "        now = que.shift",
      "        @bwd[now].each do |nxt|",
      "          next if closed[nxt]",
      "          closed[nxt] = true",
      "          @leader[nxt] = ptr",
      "          que << nxt",
      "        end",
      "      end",
      "      ptr += 1",
      "    end",
      "    ptr",
      "  end",
      "end"
    ],
    "description": "StronglyConnectedComponents"
  },
  "LCA": {
    "prefix": "LCA",
    "body": [
      "class LCA",
      "  alias Graph = Array(Array(Int64))",
      "  getter parent : Array(Array(Int64))",
      "  getter dist : Array(Int64)",
      "  @graph : Graph",
      "",
      "  def initialize(@graph : Graph, root = 0_i64)",
      "    n = graph.size",
      "    k = 1_i64",
      "    while ((1_i64 << k) < n)",
      "      k += 1",
      "    end",
      "",
      "    @parent = Array.new(k){ Array.new(n, -1_i64) }",
      "    @dist = Array.new(n, OO)",
      "    dfs(root, -1_i64, 0_i64)",
      "    (k - 1).times do |i|",
      "      n.times do |v|",
      "        if @parent[i][v] < 0",
      "          @parent[i + 1][v] = -1",
      "        else",
      "          @parent[i + 1][v] = @parent[i][@parent[i][v]]",
      "        end",
      "      end",
      "    end",
      "  end",
      "",
      "  def ancestor(u : Int, v : Int) : Int64",
      "    if @dist[u] < @dist[v]",
      "      u, v = v, u",
      "    end",
      "    n = @parent.size",
      "    n.times do |k|",
      "      u = @parent[k][u] if (dist[u] - dist[v]) >> k & 1 > 0",
      "    end",
      "    return u if u == v",
      "    n.times do |k|",
      "      if @parent[n-k-1][u] != @parent[n-k-1][v]",
      "        u, v = @parent[n-k-1][u], @parent[n-k-1][v]",
      "      end",
      "    end",
      "    @parent[0][u]",
      "  end",
      "",
      "  def distanceBetween(u : Int, v : Int) : Int64",
      "    dist[u] + dist[v] - dist[ancestor(u, v)] * 2",
      "  end",
      "",
      "  def on_path?(u : Int, v : Int, a : Int) : Bool",
      "    distanceBetween(u, a) + distanceBetween(a, v) == distanceBetween(u, v)",
      "  end",
      "",
      "  private def dfs(root : Int64, par : Int64, d : Int64)",
      "    @parent[0][root] = par",
      "    @dist[root] = d",
      "    @graph[root].each do |child|",
      "      dfs(child, root, d + 1) unless child == par",
      "    end",
      "  end",
      "end"
    ],
    "description": "LCA"
  },
  "Grid": {
    "prefix": "Grid",
    "body": [
      "struct Int; def self.bar; -1 end end",
      "struct Char; def self.bar; '#' end end",
      "class Grid(T)",
      "  include Enumerable(T)",
      "",
      "  def self.add(v1 : {Int, Int}, v2 : {Int, Int}); {v1[0] + v2[0], v1[1] + v2[1]} end",
      "  def self.sub(v1 : {Int, Int}, v2 : {Int, Int}); {v1[0] - v2[0], v1[1] - v2[1]} end",
      " ",
      "  UP = {-1, 0}",
      "  LEFT = {0, -1}",
      "  DOWN = {1, 0}",
      "  RIGHT = {0, 1}",
      "  DYDX2 = [DOWN, RIGHT]",
      "  DYDX4 = [UP, LEFT, DOWN, RIGHT]",
      "",
      "  DYDX8 = [",
      "    UP,",
      "    add(UP, RIGHT),",
      "    RIGHT,",
      "    add(DOWN, RIGHT),",
      "    DOWN,",
      "    add(DOWN, LEFT),",
      "    LEFT,",
      "    add(UP, LEFT),",
      "  ]",
      "",
      "  alias Pos = {Int32, Int32}",
      "  getter h : Int32, w : Int32",
      "  getter delta : Array(Pos)",
      "  @s : Array(T)",
      "  @bar : T",
      "",
      "  def self.dydx2(s : Array(Array(T)))",
      "    new(s, DYDX2)",
      "  end",
      "",
      "  def self.dydx4(s : Array(Array(T)))",
      "    new(s, DYDX4)",
      "  end",
      "",
      "  def self.dydx8(s : Array(Array(T)))",
      "    new(s, DYDX8)",
      "  end",
      "",
      "  def initialize(s : Array(Array(T)), @delta)",
      "    @h = s.size",
      "    @w = s[0].size",
      "    @s = s.flatten",
      "    @bar = T.bar",
      "  end",
      "",
      "  # 位置 `pos` がグリッドの範囲外なら `true` を返します。",
      "  #",
      "  # ```",
      "  # grid.over?({-1, 0}) # => true",
      "  # grid.over?({h + 10, w + 10}) # => true",
      "  # grid.over?({0, 0}) # => false",
      "  # ```",
      "  @[AlwaysInline]",
      "  def over?(pos) : Bool",
      "    over?(pos[0], pos[1])",
      "  end",
      "",
      "  # 位置 `(y, x)` がグリッドの範囲外なら `true` を返します。",
      "  #",
      "  # ```",
      "  # grid.over?(-1, 0) # => true",
      "  # grid.over?(h + 10, w + 10) # => true",
      "  # grid.over?(0, 0) # => false",
      "  # ```",
      "  @[AlwaysInline]",
      "  def over?(y, x) : Bool",
      "    y < 0 || y >= @h || x < 0 || x >= @w",
      "  end",
      "",
      "  # 位置 `pos` が進入禁止なら `true` を返します。",
      "  #",
      "  # ```",
      "  # ..",
      "  # .#",
      "  #",
      "  # grid.barrd?({0, 0}) # => false",
      "  # grid.barrd?({1, 1}) # => true",
      "  # ```",
      "  @[AlwaysInline]",
      "  def barred?(pos) : Bool",
      "    barred?(pos[0], pos[1])",
      "  end",
      "",
      "  # 位置 `(y, x)` が進入禁止なら `true` を返します。",
      "  #",
      "  # ```",
      "  # ..",
      "  # .#",
      "  #",
      "  # grid.barrd?(0, 0) # => false",
      "  # grid.barrd?(1, 1) # => true",
      "  # ```",
      "  @[AlwaysInline]",
      "  def barred?(y : Int, x : Int) : Bool",
      "    over?(y, x) || self[y, x] == @bar",
      "  end",
      "",
      "  # 位置 `pos` が通行可能なら `true` を返します。",
      "  #",
      "  # ```",
      "  # ..",
      "  # .#",
      "  #",
      "  # grid.free?({0, 0}) # => true",
      "  # grid.free?({1, 1}) # => false",
      "  # ```",
      "  @[AlwaysInline]",
      "  def free?(pos) : Bool",
      "    !barred?(pos)",
      "  end",
      "",
      "  # 位置 `(y, x)` が通行可能なら `true` を返します。",
      "  #",
      "  # ```",
      "  # ..",
      "  # .#",
      "  #",
      "  # grid.free?(0, 0) # => true",
      "  # grid.free?(1, 1) # => false",
      "  # ```",
      "  @[AlwaysInline]",
      "  def free?(y : Int, x : Int) : Bool",
      "    !barred?(y, x)",
      "  end",
      "",
      "  def each(& : T ->)",
      "    i = 0",
      "    while i < h",
      "      j = 0",
      "      while j < w",
      "        yield s[i][j]",
      "        j += 1",
      "      end",
      "      i += 1",
      "    end",
      "  end",
      "",
      "  def each_with_index(&)",
      "    i = 0_i64",
      "    while i < h",
      "      j = 0_i64",
      "      while j < w",
      "        yield s[i][j], {i, j}",
      "        j += 1",
      "      end",
      "      i += 1",
      "    end",
      "  end",
      "",
      "  # 位置 `(y, x)` の近傍で、侵入可能な位置を列挙します。",
      "  #",
      "  # ```",
      "  # grid = Grid.dydx([\".#.\", \"...\", \"...\")",
      "  #",
      "  # grid.each_neighbor(1, 1) do |ny, nx|",
      "  # end",
      "  # ```",
      "  def each_neighbor(y : Int, x : Int, &)",
      "    i = 0",
      "    while i < @delta.size",
      "      ny = y + @delta[i][0]",
      "      nx = x + @delta[i][1]",
      "      yield ny, nx if free?(ny, nx)",
      "      i += 1",
      "    end",
      "  end",
      "",
      "  # 位置 `(y, x)` の近傍で、侵入可能な位置を方向とともに列挙します。",
      "  #",
      "  # ```",
      "  # grid = Grid.dydx([\".#.\", \"...\", \"...\")",
      "  #",
      "  # grid.each_neighbor(1, 1) do |ny, nx, dir|",
      "  # end",
      "  # ```",
      "  def each_neighbor_with_direction(y : Int, x : Int, &)",
      "    i = 0",
      "    while i < @delta.size",
      "      ny = y + @delta[i][0]",
      "      nx = x + @delta[i][1]",
      "      yield ny, nx, i if free?(ny, nx)",
      "      i += 1",
      "    end",
      "  end",
      "",
      "  def fetch(y : Int, x : Int, default : T)",
      "    over?(y, x) ? default : self[y, x]",
      "  end",
      "",
      "  def to_a : Array(Array(T))",
      "    a = Array.new(@h) { Array(T).new(@w) }",
      "    @h.times do |i|",
      "      @w.times do |j|",
      "        a[i] << self[i, j]",
      "      end",
      "    end",
      "    a",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    @h.times do |i|",
      "      @w.times do |j|",
      "        io << ' ' if j != 0",
      "        io << self[i, j]",
      "      end",
      "      io << '\\n'",
      "    end",
      "    io",
      "  end",
      "",
      "  def [](pos : {Int, Int})",
      "    self[pos[0], pos[1]]",
      "  end",
      "",
      "  def [](y : Int, x : Int)",
      "    @s[y*@w + x]",
      "  end",
      "",
      "  def []=(pos : {Int, Int}, c : T)",
      "    self[pos[0], pos[1]] = c",
      "  end",
      "",
      "  def []=(y : Int, x : Int, c : T)",
      "    @s[y*@w + x] = c",
      "  end",
      "end"
    ],
    "description": "Grid"
  },
  "幅優先探索（生実装）": {
    "prefix": "bfs",
    "body": [
      "que = Deque(Int64).new [${1:start}]",
      "dist = Array.new(n){ |i| i == ${1:start} ? 0_i64 : OO }",
      "until que.empty?",
      "  from = que.shift",
      "  graph[from].select{ |v| dist[v] == OO }.each do |to|",
      "    dist[to] = dist[from] + 1",
      "    que << to",
      "  end",
      "end"
    ],
    "description": "bfs"
  },
  "迷路用BFS": {
    "prefix": "mazebfs",
    "body": [
      "que = Deque.new [{${1:sy}, ${2:sx}}]",
      "dist = Array.new(h){ |i| Array.new(w){ |j| {i, j} == {${1:sy}, ${2:sx}} ? 0_i64 : OO } }",
      "grid = Grid.dydx4(h, w, s)",
      "until que.empty?",
      "  y, x = que.shift",
      "  grid.each_neighbor(y, x) do |ny, nx|",
      "    next if dist[ny][nx] != OO",
      "    dist[ny][nx] = dist[y][x] + 1",
      "    que << {ny, nx}",
      "  end",
      "end"
    ],
    "description": "mazebfs"
  },
  "深さ優先探索": {
    "prefix": "dfs",
    "body": [
      "dfs = uninitialized Int64 -> Nil",
      "dfs = ->(from : Int64) do",
      "  graph[from].each do |to|",
      "    next if ${1:closed[to]}",
      "    closed[to] = true",
      "    dfs.call(to)",
      "  end",
      "  nil",
      "end"
    ],
    "description": "dfs"
  },
  "全方位木DP": {
    "prefix": "ReRootingTree",
    "body": [
      "class ReRootingTree(T)",
      "  @n : Int64",
      "  getter graph : Array(Array(Int64))",
      "  @dp : Array(Array(T))",
      "  @ans : Array(T)",
      "",
      "  @merge : T, Int64 -> T",
      "  @e : -> T",
      "  @g : T, Int64 -> T",
      "",
      "  def initialize(@n : Int64, @f : T, T -> T, @merge : T, T -> T, @e : -> T, @g : T, Int64 -> T)",
      "    @graph = Array.new(@n){ Array(Int64).new }",
      "    @dp = Array.new(@n){ Array(T).new }",
      "    @ans = Array.new(@n){ @e.call }",
      "  end",
      "",
      "  def add_branch(u : Int, v : Int)",
      "    @graph[u] << v",
      "    @graph[v] << u",
      "  end",
      "",
      "  def grow",
      "    @dp = Array.new(@n){ |v| Array(T).new(@graph[v].size){ @e.call } }",
      "",
      "    dfs(0_i64, -1_i64)",
      "    bfs(0_i64, @e.call, -1_i64)",
      "",
      "    @n.times do |i|",
      "      @graph[i].each_with_index do |v, j|",
      "        @ans[i] = @merge.call(@ans[i], @f.call(@dp[i][j], v))",
      "      end",
      "      @ans[i] = @g.call(@ans[i], i)",
      "    end",
      "  end",
      "",
      "  def harvest(i : Int) : T",
      "    @ans[i]",
      "  end",
      "",
      "  def harvest?(i : Int) : T?",
      "    @ans[i]?",
      "  end",
      "",
      "  private def dfs(subroot : Int64, par : Int64) : T",
      "    res = @e.call",
      "    @graph[subroot].each_with_index do |child, i|",
      "      next if child == par",
      "      @dp[subroot][i] = dfs(child, subroot)",
      "      res = @merge.call(res, @f.call(@dp[subroot][i], child))",
      "    end",
      "    @g.call(res, subroot)",
      "  end",
      "",
      "  private def bfs(subroot : Int64, dp_p : T, par : Int64)",
      "    deg = @graph[subroot].size",
      "    deg.times.each do |i|",
      "      if @graph[subroot][i] == par",
      "        @dp[subroot][i] = dp_p",
      "        break",
      "      end",
      "    end",
      "",
      "    dp_l = Array.new(deg + 1){ @e.call }",
      "    dp_r = Array.new(deg + 1){ @e.call }",
      "    deg.times{ |i| dp_l[i + 1] = @merge.call(dp_l[i], @f.call(@dp[subroot][i], @graph[subroot][i])) }",
      "    (1..deg).reverse_each{ |i| dp_r[i - 1] = @merge.call(dp_r[i], @f.call(@dp[subroot][i - 1], @graph[subroot][i - 1])) }",
      "",
      "    deg.times do |i|",
      "      child = @graph[subroot][i]",
      "      next if child == par",
      "      val = @merge.call(dp_l[i], dp_r[i + 1])",
      "      bfs(child, @g.call(val, subroot), subroot)",
      "    end",
      "  end",
      "end"
    ],
    "description": "ReRootingTree"
  },
  "最小全域木": {
    "prefix": "MSTGraph",
    "body": [
      "class MSTGraph(T)",
      "  getter size : Int64",
      "  @edges : Array({Int32, Int32, T})",
      "",
      "  def initialize(n)",
      "    @size = n.to_i64",
      "    @edges = [] of {Int32, Int32, T}",
      "    @cmp = ->(a : T, b : T) { a <=> b }",
      "  end",
      "",
      "  def initialize(n, &@cmp : (T, T) -> Int32)",
      "    @size = n.to_i64",
      "    @edges = [] of {Int32, Int32, T}",
      "  end",
      " ",
      "  # n 頂点 0 辺のグラフを生成します。",
      "  #",
      "  # 最小全域木を構築します。",
      "  def self.min(n)",
      "    new(n){ |a, b| a <=> b }",
      "  end",
      "",
      "  # n 頂点 0 辺のグラフを生成します。",
      "  #",
      "  # 最大全域木を構築します。",
      "  def self.max(n)",
      "    new(n){ |a, b| b <=> a }",
      "  end",
      "",
      "  # グラフに辺 (u, v, w) を追加します。",
      "  #",
      "  # ```",
      "  # graph = MSTGraph(Int64).new(n){ |a, b| a < b }",
      "  # m.times{ graph.add_edge(u, v, w) }",
      "  # ```",
      "  def add_edge(u : Int, v : Int, w : T)",
      "    @edges << {u.to_i32, v.to_i32, w}",
      "  end",
      "",
      "  # 最小全域木を構成したときの辺の重みの総和求めます。",
      "  #",
      "  # ```",
      "  # graph = MSTGraph(Int64).new(n){ |a, b| a < b }",
      "  # m.times{ graph.add_edge(u, v, w) }",
      "  # graph.sum",
      "  # ```",
      "  def sum",
      "    @edges.sort!{ |a, b| @cmp.call(a[2], b[2]) }",
      "    ut = DisjointSet.new(@size)",
      "    res = T.zero",
      "    @edges.each do |(u, v, w)|",
      "      next if ut.equiv?(u, v)",
      "      ut.unite(u, v)",
      "      res += w",
      "    end",
      "    res",
      "  end",
      "end"
    ],
    "description": "MSTGraph"
  },
  "トポロジカルソート": {
    "prefix": "topological_sort",
    "body": [
      "def topological_sort(graph : Array(Array(Int64))) : Array(Int64)",
      "  n = graph.size.to_i64",
      "  res = Array(Int64).new(n)",
      "  deg = [0] * n",
      "  graph.each do |outs|",
      "    outs.each do |to|",
      "      deg[to] += 1",
      "    end",
      "  end",
      "",
      "  que = Deque(Int64).new",
      "  n.times do |i|",
      "    que << i if deg[i] == 0",
      "  end",
      "",
      "  until que.empty?",
      "    from = que.shift",
      "    res << from",
      "    graph[from].each do |to|",
      "      deg[to] -= 1",
      "      que << to if deg[to] == 0",
      "    end",
      "  end",
      "",
      "  res",
      "end"
    ],
    "description": "topological_sort"
  },

  //────────────────────────────────────────────────────
  // ネットワークフロー
  //────────────────────────────────────────────────────
  "最大流": {
    "prefix": "MaxFlowGraph",
    "body": [
      "class MaxFlowGraph(Cap)",
      "  class Edge(T)",
      "    getter to : Int32",
      "    getter rev : Int32",
      "    property cap : T",
      "",
      "    def initialize(@to, @rev, @cap)",
      "    end",
      "  end",
      "",
      "  getter size : Int32",
      "  @graph : Array(Array(Edge(Cap)))",
      "  @pos : Array({Int32, Int32})",
      "",
      "  # 0 頂点 0 辺のグラフを作ります。",
      "  #",
      "  # ```",
      "  # graph = MaxFlowGraph(Int64).new",
      "  # ```",
      "  def initialize",
      "    @size = 0",
      "    @graph = [] of Array(Edge(Cap))",
      "    @pos = [] of {Int32, Int32}",
      "  end",
      "",
      "  # n 頂点 0 辺のグラフを作ります。",
      "  #",
      "  # ```",
      "  # n = 10",
      "  # graph = MaxFlowGraph(Int64).new(n)",
      "  # ```",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @graph = Array.new(n){ Array(Edge(Cap)).new }",
      "    @pos = [] of {Int32, Int32}",
      "  end",
      "",
      "  # 頂点 from から頂点 to へ最大容量 cap、流量 0 の辺を追加します。",
      "  #",
      "  # 何番目に追加された辺であるかを返します。",
      "  #",
      "  # ```",
      "  # n = 10",
      "  # graph = MaxFlowGraph(Int64).new(n)",
      "  # graph.add_edge(0, 1, 1) # => 0",
      "  # graph.add_edge(1, 3, 2) # => 1",
      "  # graph.add_edge(5, 6, 8) # => 2",
      "  # ```",
      "  def add_edge(from : Int, to : Int, cap : Cap) : Int32",
      "    m = @pos.size",
      "    @pos << {from.to_i32, @graph[from].size}",
      "    from_id = @graph[from].size",
      "    to_id = @graph[to].size",
      "    to_id += 1 if from == to",
      "    @graph[from] << Edge(Cap).new(to.to_i32, to_id, cap)",
      "    @graph[to] << Edge(Cap).new(from.to_i32, from_id, Cap.zero)",
      "    m",
      "  end",
      "",
      "  # 今の内部の辺の状態を返します。",
      "  #",
      "  # 辺の順番は add_edge での追加順と同じです。",
      "  def get_edge(i : Int)",
      "    m = @pos.size",
      "    e = @graph[@pos[i][0]][@pos[i][1]]",
      "    re = @graph[e.to][e.rev]",
      "    {from: @pos[i][0], to: e.to, cap: e.cap + re.cap, flow: re.cap}",
      "  end",
      "",
      "  # 今の内部の辺の状態を返します。",
      "  #",
      "  # 辺の順番は add_edge での追加順と同じです。",
      "  def edges",
      "    Array.new(@pos.size){ |i| get_edge(i) }",
      "  end",
      "",
      "  # i 番目に変更された辺の容量、流量をそれぞれ new_cap, new_flow に変更します。",
      "  #",
      "  # 他の辺の容量、流量は変更しません。",
      "  def change_edge(i : Int, new_cap : Cap, new_flow : Cap)",
      "    m = @pos.size",
      "    @graph[@pos[i].first][@pos[i].second].cap = new_cap - new_flow;",
      "    @graph[_e.to][_e.rev].cap = new_flow;",
      "  end",
      "",
      "  # 頂点 s から頂点 t へ流せるだけ流し、流せた量を返します。",
      "  #",
      "  # 複数回呼ぶことも可能ですが、同じ結果を返すわけではありません。",
      "  # 挙動については以下を参考にしてください。",
      "  # - https://atcoder.github.io/ac-library/document_ja/appendix.html",
      "  #",
      "  # ```",
      "  # n = 4",
      "  # graph = MaxFlowGraph(Int64).new(n)",
      "  # graph.add_edge(0, 1, 10) # => 0",
      "  # graph.add_edge(1, 2, 2) # => 1",
      "  # graph.add_edge(0, 2, 5) # => 2",
      "  # graph.add_edge(1, 3, 6) # => 3",
      "  # graph.add_edge(2, 3, 3) # => 4",
      "  #",
      "  # graph.flow(0, 3) # => 9",
      "  # ```",
      "  def flow(s : Int, t : Int)",
      "    flow(s, t, Cap::MAX)",
      "  end",
      "",
      "  # 頂点 s から頂点 t へ流せるだけ流し、流せた量を返します。",
      "  #",
      "  # 複数回呼ぶことも可能ですが、同じ結果を返すわけではありません。",
      "  # 挙動については以下を参考にしてください。",
      "  # - https://atcoder.github.io/ac-library/document_ja/appendix.html",
      "  #",
      "  # ```",
      "  # n = 4",
      "  # graph = MaxFlowGraph(Int64).new(n)",
      "  # graph.add_edge(0, 1, 10) # => 0",
      "  # graph.add_edge(1, 2, 2) # => 1",
      "  # graph.add_edge(0, 2, 5) # => 2",
      "  # graph.add_edge(1, 3, 6) # => 3",
      "  # graph.add_edge(2, 3, 3) # => 4",
      "  #",
      "  # graph.flow(0, 3, 6) # => 6",
      "  # graph.flow(0, 3, 100) # => 9  (本来の挙動であれば 3 を返します。)",
      "  # ```",
      "  def flow(s : Int, t : Int, flow_limit : Cap)",
      "    level = [0] * @size",
      "    iter = [0] * @size",
      "",
      "    bfs = -> {",
      "      level = [-1] * @size",
      "      level[s] = 0",
      "      que = Deque(Int32).new([s.to_i32])",
      "      until que.empty?",
      "        v = que.shift",
      "        @graph[v].each do |e|",
      "          next if e.cap == 0 || level[e.to] >= 0",
      "          level[e.to] = level[v] + 1",
      "          next if e.to == t",
      "          que << e.to",
      "        end",
      "      end",
      "    }",
      "",
      "    dfs = uninitialized Int32, Cap -> Cap",
      "    dfs = ->(v : Int32, up : Cap) {",
      "      return up if v == s",
      "      res = Cap.zero",
      "      level_v = level[v]",
      "      (iter[v]...@graph[v].size).each do |i|",
      "        e = @graph[v][i]",
      "        next if level_v <= level[e.to] || @graph[e.to][e.rev].cap == 0",
      "        d = dfs.call(e.to, Math.min(up - res, @graph[e.to][e.rev].cap))",
      "        next if d <= 0",
      "        @graph[v][i].cap += d",
      "        @graph[e.to][e.rev].cap -= d",
      "        res += d",
      "        return res if res == up",
      "      end",
      "      level[v] = @size",
      "      res",
      "    }",
      "",
      "    res = Cap.zero",
      "    while res < flow_limit",
      "      bfs.call",
      "      break if level[t] == -1",
      "      iter = [0] * @size",
      "      f = dfs.call(t.to_i32, flow_limit - res)",
      "      break if f == 0",
      "      res += f",
      "    end",
      "",
      "    res",
      "  end",
      "",
      "  # 長さ n の配列を返します。",
      "  # i 番目の要素には、頂点 s から i へ残余グラフで到達可能なとき、またその時のみ true を返します。",
      "  #",
      "  # flow(s, t) を flow_limit なしでちょうど一回呼んだ後に呼ぶと、",
      "  # 返り値は s, t 間の mincut に対応します。",
      "  def min_cut(s : Int)",
      "    closed = [false] * @size",
      "    que = Deque(Int32).new([s.to_i32])",
      "    unless que.empty?",
      "      now = que.shift",
      "      visited[now] = true",
      "      @graph[now].each do |e|",
      "        if e.cap != 0 && !visited[e.to]",
      "          visited[e.to] = true",
      "          que << e.to",
      "        end",
      "      end",
      "    end",
      "    visited",
      "  end",
      "end"
    ],
    "description": "MaxFlowGraph"
  },
  "最小費用流": {
    "prefix": "MinCostFlowGraph",
    "body": [
      "class MinCostFlowGraph(Cap, Cost)",
      "  class Edge(T, U)",
      "    getter from : Int32",
      "    getter to : Int32",
      "    getter cap : T",
      "    property flow : T",
      "    getter cost : U",
      "",
      "    def initialize(s : Int, t : Int, @cap : T, @flow : T, @cost : U)",
      "      @from = s.to_i32",
      "      @to = t.to_i32",
      "    end",
      "  end",
      "",
      "  class InternalEdge(T, U)",
      "    getter to : Int32",
      "    property rev : Int32",
      "    property cap : T",
      "    getter cost : U",
      "",
      "    def initialize",
      "      @to = 0",
      "      @rev = 0",
      "      @cap = T.zero",
      "      @cost = U.zero",
      "    end",
      "",
      "    def initialize(@to : Int32, @rev : Int32, @cap : T, @cost : U)",
      "    end",
      "  end",
      "",
      "  class SparseMatrix(E)",
      "    getter start : Array(Int32)",
      "    getter elist : Array(E)",
      "",
      "    def initialize(n : Int, edges : Array({Int32, E}))",
      "      @start = [0] * (n + 1)",
      "      @elist = Array.new(edges.size){ E.new }",
      "      edges.each { |e| @start[e[0] + 1] += 1 }",
      "      (1..n).each { |i| @start[i] += @start[i - 1] }",
      "      counter = start.clone",
      "      edges.each do |e|",
      "        @elist[counter[e[0]]] = e[1]",
      "        counter[e[0]] += 1",
      "      end",
      "    end",
      "  end",
      "",
      "  getter size : Int32",
      "  getter edges : Array(Edge(Cap, Cost))",
      "",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @edges = Array(Edge(Cap, Cost)).new",
      "  end",
      "",
      "  def add_edge(from : Int, to : Int, cap : Cap, cost : Cost) : Int32",
      "    m = @edges.size",
      "    @edges << Edge.new(from, to, cap, Cap.zero, cost)",
      "    m",
      "  end",
      "",
      "  def flow(s : Int, t : Int) : {Cap, Cost}",
      "    flow(s, t, Cap::MAX)",
      "  end",
      "",
      "  def flow(s : Int, t : Int, flow_limit : Cap) : {Cap, Cost}",
      "    slope(s, t, flow_limit).last",
      "  end",
      "",
      "  def slope(s : Int, t : Int) : Array({Cap, Cost})",
      "    slope(s, t, Cap::MAX)",
      "  end",
      "",
      "  def slope(s : Int, t : Int, flow_limit : Cap) : Array({Cap, Cost})",
      "    m = @edges.size",
      "    edge_index = [-1] * m",
      "",
      "    # calc g",
      "    degree = [0] * @size",
      "    redge_index = [-1] * m",
      "    elist = Array({Int32, InternalEdge(Cap, Cost)}).new(2 * m){ {-1, InternalEdge(Cap, Cost).new } }",
      "    m.times do |i|",
      "      e = @edges[i]",
      "      edge_index[i] = degree[e.from]",
      "      degree[e.from] += 1",
      "",
      "      redge_index[i] = degree[e.to]",
      "      degree[e.to] += 1",
      "",
      "      elist[2*i] = {e.from, InternalEdge(Cap, Cost).new(e.to, -1, e.cap - e.flow, e.cost)}",
      "      elist[2*i + 1] = {e.to, InternalEdge(Cap, Cost).new(e.from, -1, e.flow, -e.cost)}",
      "    end",
      "",
      "    g = SparseMatrix(InternalEdge(Cap, Cost)).new(@size, elist)",
      "    @edges.each_with_index do |e, i|",
      "      edge_index[i] += g.start[e.from]",
      "      redge_index[i] += g.start[e.to]",
      "      g.elist[edge_index[i]].rev = redge_index[i]",
      "      g.elist[redge_index[i]].rev = edge_index[i]",
      "    end",
      "",
      "    res = slope(g, s, t, flow_limit)",
      "    m.times do |i|",
      "      @edges[i].flow = @edges[i].cap - g.elist[edge_index[i]].cap",
      "    end",
      "",
      "    res",
      "  end",
      "",
      "  private def slope(g : SparseMatrix(InternalEdge), s : Int, t : Int, flow_limit : Cap)",
      "    dual_dist = [{Cost.zero, Cost.zero}] * @size",
      "    prev_e = [-1] * @size",
      "    dual_ref = ->() {",
      "      @size.times do |i|",
      "        dual_dist[i] = {dual_dist[i][0], Cost::MAX}",
      "      end",
      "",
      "      vis = [false] * @size",
      "",
      "      que_min = Array(Int32).new",
      "      que = Heap({Cost, Int32}).min",
      "",
      "      dual_dist[s] = {dual_dist[s][0], Cost.zero}",
      "      que_min << s.to_i32",
      "      until que_min.empty? && que.empty?",
      "        v = que_min.empty? ? que.pop[1] : que_min.pop",
      "",
      "        next if vis[v]",
      "        vis[v] = true",
      "        break if v == t",
      "",
      "        dual_v = dual_dist[v][0]",
      "        dist_v = dual_dist[v][1]",
      "        (g.start[v]...g.start[v + 1]).each do |i|",
      "          e = g.elist[i]",
      "          next if e.cap == Cap.zero",
      "          cost = e.cost - dual_dist[e.to][0] + dual_v",
      "          if dual_dist[e.to][1] - dist_v > cost",
      "            dist_to = dist_v + cost",
      "            dual_dist[e.to] = {dual_dist[e.to][0], dist_to}",
      "            prev_e[e.to] = e.rev",
      "            if dist_to == dist_v",
      "              que_min << e.to",
      "            else",
      "              que << {dist_to, e.to}",
      "            end",
      "          end",
      "        end",
      "      end",
      "",
      "      return false unless vis[t]",
      "",
      "      @size.times do |v|",
      "        next unless vis[v]",
      "        x = dual_dist[v][0] - dual_dist[t][1] + dual_dist[v][1]",
      "        dual_dist[v] = {x, dual_dist[v][1]}",
      "      end",
      "      true",
      "    }",
      "",
      "    flow = Cap.zero",
      "    cost = Cost.zero",
      "    prev_cost_pre_flow = Cost.zero.pred",
      "    result = [{Cap.zero, Cost.zero}]",
      "    while flow < flow_limit",
      "      break unless dual_ref.call",
      "      c = flow_limit - flow",
      "",
      "      v = t",
      "      while v != s",
      "        chmin(c, g.elist[g.elist[prev_e[v]].rev].cap)",
      "        v = g.elist[prev_e[v]].to",
      "      end",
      "",
      "      v = t",
      "      while v != s",
      "        e = g.elist[prev_e[v]]",
      "        e.cap += c",
      "        g.elist[e.rev].cap -= c",
      "        v = g.elist[prev_e[v]].to",
      "      end",
      "",
      "      d = -dual_dist[s][0]",
      "      flow += c",
      "      cost += d * c",
      "      if prev_cost_pre_flow == d",
      "        result.pop",
      "      end",
      "      result << {flow, cost}",
      "      prev_cost_pre_flow = d",
      "    end",
      "    result",
      "  end",
      "end"
    ],
    "description": "MinCostFlowGraph"
  },

  //────────────────────────────────────────────────────
  // 数学系
  //────────────────────────────────────────────────────
  "二分法": {
    "prefix": "bisect",
    "body": [
      "def bisect(ac : Float64, wa : Float64, error : Float64, & : Float64 -> Bool)",
      "  n_iters = Math.log((wa - ac).abs / error, 2).to_i + 2",
      "  n_iters.times do",
      "    wj = (ac + wa) / 2",
      "    if yield wj",
      "      ac = wj",
      "    else",
      "      wa = wj",
      "    end",
      "  end",
      "  ac",
      "end"
    ],
    "description": "bisect"
  },
  "二項係数": {
    "prefix": "Combination",
    "body": [
      "class Combination",
      "  @fact : Array(Int64)",
      "  @finv : Array(Int64)",
      "  @inv : Array(Int64)",
      "  @mod : Int64",
      "",
      "  def self.mod1000000007(max : Int64)",
      "    new max, 1000000007_i64",
      "  end",
      "",
      "  def self.mod998244353(max : Int64)",
      "    new max, 998244353_i64",
      "  end",
      "",
      "  def initialize(@max : Int64, @mod : Int64)",
      "    @fact = Array.new(@max + 1, 0_i64)",
      "    @finv = Array.new(@max + 1, 0_i64)",
      "    @inv = Array.new(@max + 1, 0_i64)",
      "    @fact[0] = @fact[1] = 1_i64",
      "    @finv[0] = @finv[1] = 1_i64",
      "    @inv[1] = 1_i64",
      "    (2_i64..@max.to_i64).each do |i|",
      "      @fact[i] = @fact[i - 1] * i % @mod",
      "      @inv[i] = @mod - @inv[@mod % i] * (@mod // i) % @mod",
      "      @finv[i] = @finv[i - 1] * @inv[i] % @mod",
      "    end",
      "  end",
      "",
      "  def calc(n : Int, r : Int) : Int64",
      "    if n < r",
      "      0_i64",
      "    elsif n < 0 || r < 0",
      "      0_i64",
      "    else",
      "      @fact[n] * (@finv[r] * @finv[n - r] % @mod) % @mod",
      "    end",
      "  end",
      "",
      "  def [](n : Int, r : Int)",
      "    calc(n, r)",
      "  end",
      "end"
    ],
    "description": "Combination"
  },
  "ModInt": {
    "prefix": "modint",
    "body": [
      "def modinv(a : Int64, mod : Int64) : Int64",
      "  b = mod",
      "  u = 1_i64",
      "  v = 0_i64",
      "  until b == 0",
      "    t = a // b",
      "    a -= t * b",
      "    a, b = b, a",
      "    u -= t * v",
      "    u, v = v, u",
      "  end",
      "  u % mod",
      "end",
      "",
      "def modpow(a : Int64, n : Int64, mod : Int64) : Int64",
      "  res = 1_i64",
      "  until n == 0",
      "    res = res * a % mod if n.odd?",
      "    a = a * a % mod",
      "    n >>= 1",
      "  end",
      "  res",
      "end",
      "",
      "macro static_modint(modint, mod)",
      "  struct {{ modint }}  ",
      "    include Comparable({{ modint }})",
      "",
      "    MOD = {{ mod }}",
      "    getter val : Int64",
      "",
      "    delegate popcount, to: val",
      "    delegate trailing_zeros_count, to: val",
      "",
      "    def initialize",
      "      @val = 0",
      "    end",
      "",
      "    def initialize(@val : Int64)",
      "      @val %= {{ mod }}",
      "    end",
      "",
      "    def + : self; self end",
      "    def - : self; {{ modint }}.new -@val end",
      "",
      "    def +(other : self) : self; {{ modint }}.new @val + other.val end",
      "    def -(other : self) : self; {{ modint }}.new @val - other.val end",
      "    def *(other : self) : self; {{ modint }}.new @val * other.val end",
      "    def /(other : self) : self; {{ modint }}.new @val * other.inv.val end",
      "    def //(other : self) : self; self / other end",
      "",
      "    def +(other : Int) : self; {{ modint }}.new @val + other end",
      "    def -(other : Int) : self; {{ modint }}.new @val - other end",
      "    def *(other : Int) : self; {{ modint }}.new @val * other end",
      "    def **(other : Int) : self; self.pow(other.to_i64) end",
      "    def /(other : Int) : self; {{ modint }}.new @val * modinv(other.to_i64, {{ mod }}) end",
      "    def //(other : Int) : self; self / other end",
      "",
      "    def <=>(other : self) : Int32; @val <=> other.val end",
      "    ",
      "    def inv : self",
      "      {{ modint }}.new modinv(@val, {{ mod }})",
      "    end",
      "",
      "    def pow(n : Int64) : self",
      "      {{ modint }}.new modpow(@val, n, {{ mod }})",
      "    end",
      "",
      "    def abs : self",
      "      self",
      "    end",
      "",
      "    def zero? : Bool",
      "      @val == 0_i64",
      "    end",
      "",
      "    def self.zero : self",
      "      {{ modint }}.new 0_i64",
      "    end",
      "",
      "    def clone",
      "      {{ modint }}.new @val",
      "    end",
      "",
      "    def to_i; @val.to_i end",
      "    def to_i32; @val.to_i32 end",
      "    def to_i64; @val.to_i64 end",
      "    def to_s(io : IO); io << @val end",
      "    def inspect(io : IO); to_s(io) end",
      "  end",
      "",
      "  struct Int",
      "    def to_m",
      "      {{ modint }}.new self.to_i64",
      "    end",
      "",
      "    def +(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} + other.val end",
      "    def -(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} - other.val end",
      "    def *(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} * other.val end",
      "    def /(other : {{ modint }}) : {{ modint }}; {{ modint }}.new self.to_i64 % {{ mod }} * other.inv.val end",
      "    def //(other : {{ modint }}) : {{ modint }}; self.to_i64 / other end",
      "  end",
      "end",
      "# static_modint(ModInt1000000007, 1_000_000_007_i64)",
      "static_modint(ModInt998244353, 998_244_353_i64)",
      "alias ModInt = ModInt998244353"
    ],
    "description": "modint"
  },
  "素数系ライブラリ": {
    "prefix": "Prime",
    "body": [
      "class Prime",
      "  getter capacity : Int64",
      "  @table : Array(Bool)",
      "  @osak : Array(Int64)",
      "  @list : Array(Int64)",
      "  getter pi : Array(Int64)  # n 以下の 素数の個数",
      "",
      "  def initialize(@capacity : Int64)",
      "    @table = Array.new(@capacity + 1, true)",
      "    @osak = (0_i64..@capacity).to_a",
      "    @pi = Array.new(@capacity + 1, 0_i64)",
      "    if @capacity >= 0; @table[0] = false end",
      "    if @capacity >= 1; @table[1] = false end",
      "",
      "    i = 1_i64",
      "    while i**2 <= @capacity",
      "      i += 1",
      "      @pi[i] = @pi[i - 1]",
      "      next unless @table[i]",
      "      k = 2_i64*i",
      "      while k <= @capacity",
      "        @table[k] = false",
      "        @osak[k] = i",
      "        k += i",
      "      end",
      "      @pi[i] += 1",
      "    end",
      "",
      "    @list = Array(Int64).new",
      "    (1..@capacity).each do |i|",
      "      @pi[i] = @pi[i - 1] + (@table[i] ? 1_i64 : 0_i64)",
      "      if @table[i]",
      "        @list.push(i.to_i64)",
      "      end",
      "    end",
      "  end",
      "",
      "  # 素数であれば `true` を返します。",
      "  #",
      "  # 計算量 : `O(1)` if n <= capacity else `O(sqrt(N))`",
      "  #",
      "  # ```",
      "  # PRIME.is? 0 # => false",
      "  # PRIME.is? 1 # => false",
      "  # PRIME.is? 2 # => true",
      "  # ```",
      "  def is?(n : Int) : Bool",
      "    if n <= @capacity",
      "      @table[n]",
      "    elsif n <= 4",
      "      n == 2 || n == 3",
      "    elsif n % 2 == 0 || n % 3 == 0 || (n % 6 != 1 && n % 6 != 5)",
      "      false",
      "    else",
      "      i = 5_i64",
      "      ok = true",
      "      while i**2 <= n",
      "        if n % i == 0 || n % (i + 2) == 0",
      "          ok = false",
      "          break",
      "        end",
      "        i += 6",
      "      end",
      "      ok",
      "    end",
      "  end",
      "",
      "  # 素因数分解の結果をハッシュで返します。",
      "  # `p**a` の `p` がキーで `a` が値です",
      "  #",
      "  # 計算量 : `O(log(N))` if n <= capacity else `O(sqrt(N))`",
      "  #",
      "  # ```",
      "  # PRIME.factor? 24 # => { 2 => 3, 3 => 1 }",
      "  # ```",
      "  def factor(n : Int) : Hash(Int64, Int64)",
      "    return { 1_i64 => 1_i64 } if n == 1",
      "    return factor_fast_impl(n) if n <= @capacity",
      "    res = Hash(Int64, Int64).new(0_i64)",
      "    i = 2_i64",
      "    while i * i <= n",
      "      while n % i == 0",
      "        res[i] += 1",
      "        n //= i",
      "      end",
      "      i += 1",
      "    end",
      "    res[n] = 1 if n != 1",
      "    res",
      "  end",
      "",
      "  private def factor_fast_impl(n : Int) : Hash(Int64, Int64)",
      "    res = Hash(Int64, Int64).new(0_i64)",
      "    until n == 1",
      "      prime = @osak[n]",
      "      res[prime] += 1",
      "      n //= prime",
      "    end",
      "    res",
      "  end",
      "",
      "  # *enumerable* の値が互いに素であれば `true` を返します。",
      "  #",
      "  # 計算量 : `O(ary.size * log(ary.max))`",
      "  #",
      "  # ```",
      "  # PRIME.to? [2, 3, 5] # => true",
      "  # PRIME.to? [2, 3, 4] # => false",
      "  # ```",
      "  def to?(elems : Enumerable(Int64)) : Bool",
      "    s = Set(Int64).new",
      "    elems.each do |n|",
      "      until n == 1",
      "        prime = @osak[n]",
      "        return false if s.includes? prime",
      "        s << prime",
      "        while n % prime == 0",
      "          n //= prime",
      "        end",
      "      end",
      "    end",
      "    true",
      "  end",
      "end",
      "",
      "PRIME = Prime.new ${1:10_i64**7}",
      "struct Int",
      "  def prime?",
      "    PRIME.is? self",
      "  end",
      "",
      "  def factor",
      "    PRIME.factor(self)",
      "  end",
      "end"
    ],
    "description": "Prime"
  },
  "約数列挙": {
    "prefix": "divisors",
    "body": [
      "struct Int",
      "  def divisors",
      "    lo = Array(Int64).new",
      "    hi = Array(Int64).new",
      "    i = 1_i64",
      "    while i**2 <= self",
      "      if self % i == 0",
      "        j = self // i",
      "        lo << i",
      "        if i != j",
      "          hi << j",
      "        end",
      "      end",
      "      i += 1",
      "    end",
      "    lo + hi",
      "  end",
      "end"
    ],
    "description": "divisors"
  },
  "行列": {
    "prefix": "Matrix",
    "body": [
      "class Matrix(T)",
      "  include Enumerable(T)",
      "",
      "  class DimensionError < Exception",
      "    def initialize(message = \"Dimension Error.\")",
      "      super(message)",
      "    end",
      "",
      "    def initialize(h, w)",
      "      super(\"Dimension Error: #{h}x#{w}.\")",
      "    end",
      "",
      "    def initialize(h1, w1, h2, w2)",
      "      super(\"Dimension Error: (#{h1}x#{w1}) (#{h2}x#{w2}).\")",
      "    end",
      "  end",
      "",
      "  getter m : Array(T)",
      "  @n_rows : Int32",
      "  @n_cols : Int32",
      "",
      "  def column_size; @n_cols end",
      "  def row_size; @n_rows end",
      "  def size; {@n_rows, @n_cols} end",
      "",
      "  def initialize",
      "    @m = Array(T).new",
      "    @n_rows, @n_cols = 0, 0",
      "  end",
      "",
      "  def initialize(h : Int, w : Int)",
      "    @m = Array.new(h * w){ T.zero }",
      "    @n_rows, @n_cols = h.to_i, w.to_i",
      "  end",
      "",
      "  def initialize(h : Int, w : Int, val : T)",
      "    @m = Array.new(h * w){ val }",
      "    @n_rows, @n_cols = h.to_i, w.to_i",
      "  end",
      "",
      "  def initialize(ary : Array(Array(T)))",
      "    ArgumentError.new(\"ary.size must be greater than or equal to 1\") if ary.size <= 0",
      "    @n_rows, @n_cols = ary.size, ary[0].size",
      "    @m = Array.new(@n_rows * @n_cols){ T.zero }",
      "    ary.each_with_index do |v, i|",
      "      v.each_with_index do |x, j|",
      "        @m[@n_cols * i + j] = x",
      "      end",
      "    end",
      "  end",
      "",
      "  def self.new(h : Int, w : Int, &block : Int32, Int32 -> T)",
      "    Matrix(T).new(h, w).tap do |mat|",
      "      i, j = 0, 0",
      "      (mat.column_size * mat.row_size).times do |index|",
      "        mat[index] = yield i, j",
      "        j += 1",
      "        if i == h",
      "          i = 0",
      "          j += 1",
      "        end",
      "        if j == w",
      "          i += 1",
      "          j = 0",
      "        end",
      "      end",
      "    end",
      "  end",
      "",
      "  def self.zero(h : Int, w : Int)",
      "    new h, w, T.zero",
      "  end",
      "",
      "  def self.identity(h : Int, w : Int)",
      "    raise DimensionError.new(h, w) if h != w",
      "    Matrix(T).new(h, w) do |i, j|",
      "      i == j ? T.new(1_i64) : T.zero",
      "    end",
      "  end",
      "",
      "  def clone",
      "    Matrix(T).new(@n_rows, @n_cols) do |i, j|",
      "      at(i, j).clone",
      "    end",
      "  end",
      "",
      "  def at(i : Int, j : Int) : T",
      "    i += @n_rows if i < 0",
      "    j += @n_cols if j < 0",
      "    IndexError.new if over(i, j)",
      "    @m[@n_cols * i + j]",
      "  end",
      "",
      "  def at?(i : Int, j : Int) : T?",
      "    i += @n_rows if i < 0",
      "    j += @n_cols if j < 0",
      "    over(i, j) ? nil : @m[@n_cols * i + j]",
      "  end",
      "",
      "  def [](i : Int, j : Int) : T; at(i, j) end",
      "  def []?(i : Int, j : Int) : T?; at?(i, j) end",
      "",
      "  def at(index : Int) : T; @m[index] end",
      "  def at?(index : Int) : T?; @m[index]? end",
      "  def [](index : Int) : T; at(index) end",
      "  def []?(index : Int) : T; at?(index) end",
      "",
      "  def []=(i : Int, j : Int, val : T) : T",
      "    i += @n_rows if i < 0",
      "    j += @n_cols if j < 0",
      "    IndexError.new if over(i, j)",
      "    @m[@n_cols * i + j] = val",
      "  end",
      "",
      "  def []=(index : Int, val : T) : T",
      "    @m[index] = val",
      "  end",
      "",
      "  def each(& : T ->)",
      "    @m.each{ |x| yield x }",
      "  end",
      "",
      "  def each_with_index(& : T, {Int32, Int32} ->)",
      "    @n_rows.times do |i|",
      "      @n_cols.times do |j|",
      "        yield @m[@n_cols * i + j], {i, j}",
      "      end",
      "    end",
      "  end",
      "",
      "  def push_row(v : Array(T))",
      "    raise DimensionError.new(@n_row, @n_cols) if @n_cols != v.size",
      "    @m.concat(v)",
      "    @n_cols += 1",
      "  end",
      "",
      "  def push_col(v : Array(T))",
      "    raise NotImplementedError.new",
      "  end",
      "",
      "  def swap_row(si : Int, ti : Int)",
      "    @n_cols.times { |j| @m.swap(@n_cols * si + j, @n_cols * ti + j) }",
      "  end",
      "",
      "  def swap_col(sj : Int, tj : Int)",
      "    @n_rows.times { |i| @m.swap(@n_cols * i + sj, @n_cols * i + tj) }",
      "  end",
      "",
      "  {% for op in %i(+ - ^ | &) %}",
      "    def {{ op.id }}(other : Matrix(U)) forall U",
      "      raise DimensionError.new(@n_rows, @n_cols, other.row_size, other.column_size) unless @n_rows == other.row_size && @n_cols == other.column_size",
      "      res = Matrix(T | U).new(@n_rows, @n_cols)",
      "      (@n_rows * @n_cols).times{ |i| res[i] = at(i) {{ op.id }} other.at(i) }",
      "      res",
      "    end",
      "  {% end %}",
      "  ",
      "  def *(other : Matrix(U)) forall U",
      "    r0 = @n_rows",
      "    c = @n_cols",
      "    c0 = other.column_size",
      "    raise DimensionError.new(r0, c, other.row_size, c0) if c != other.row_size",
      "    res = Matrix(T | U).new(r0, c0)",
      "    r0.times do |i|",
      "      c.times do |k|",
      "        c0.times do |j|",
      "          res[i, j] += at(i, k) * other.at(k, j)",
      "        end",
      "      end",
      "    end",
      "    res",
      "  end",
      "",
      "  def /(other : Matrix(U)) forall U",
      "    self * other.inv",
      "  end",
      "",
      "  {% for op in %i(* / //) %}",
      "    def {{ op.id }}(k : T)",
      "      res = Matrix(T).new(@n_rows, @n_cols)",
      "      (@n_rows * @n_cols).times do |index|",
      "        res[index] = at(index) {{ op.id }} k",
      "      end",
      "      res",
      "    end",
      "  {% end %}",
      "",
      "  {% for op in %i(+ -) %}",
      "    def {{ op.id }}(k : T)",
      "      res = Matrix(T).new(@n_rows, @n_cols)",
      "      (@n_rows * @n_cols).times do |index|",
      "        res[index] = {{ op.id }} at(index)",
      "      end",
      "      res",
      "    end",
      "  {% end %}",
      "",
      "  def **(k : Int); pow(k) end",
      "",
      "  def pow(k : Int)",
      "    if k < -1",
      "      inv.pow(k.abs)",
      "    elsif k == -1",
      "      inv",
      "    elsif k == 0",
      "      Matrix(T).identity(@n_rows, @n_cols)",
      "    elsif k == 1",
      "      clone",
      "    else",
      "      pow_impl(k)",
      "    end",
      "  end",
      "",
      "  private def pow_impl(k : Int)",
      "    res = Matrix(T).identity(@n_rows, @n_cols)",
      "    a = clone",
      "    until k == 0",
      "      res *= a if k.odd?",
      "      a *= a",
      "      k >>= 1",
      "    end",
      "    res",
      "  end",
      "",
      "  def det : T",
      "    raise DimensionError.new(@n_rows, @n_cols) if @n_cols != @n_cols",
      "    n = @n_rows",
      "    case n",
      "    when 1",
      "      at(0, 0)",
      "    when 2",
      "      at(0, 0) * at(0, 2) - at(0, 1) * at(1, 0)",
      "    else",
      "      # TODO: study performance",
      "      ary = to_a",
      "      res = T.new(1_i64)",
      "      n.times do |i|",
      "        idx = -1",
      "        (i...n).reverse_each do |j|",
      "          unless ary[j][i].zero?",
      "            idx = j",
      "            break",
      "          end",
      "        end",
      "        return T.zero if idx == -1",
      "        if i != idx",
      "          res = -res",
      "          ary.swap(i, idx)",
      "        end",
      "        res *= ary[i][i]",
      "        v = ary[i][i]",
      "",
      "        n.times do |j|",
      "          if v.is_a? Float",
      "            ary[i][j] /= v",
      "          else",
      "            ary[i][j] //= v",
      "          end",
      "        end",
      "",
      "        (i + 1...n).each do |j|",
      "          a = ary[j][i]",
      "          n.times do |k|",
      "            ary[j][k] -= ary[i][k] * a",
      "          end",
      "        end",
      "      end",
      "      res",
      "    end",
      "  end",
      "",
      "  def det?",
      "    return nil if @n_cols != @n_cols",
      "    det",
      "  end",
      "",
      "  def inv : Matrix(T)",
      "    raise DimensionError.new(@n_rows, @n_cols) if @n_rows != @n_cols",
      "    ary = to_a",
      "    n = @n_rows",
      "    res = Array.new(n){ |i| Array(T).new(n){ |j| i == j ? T.new(1_i64) : T.new(0_i64) }}",
      "    rank = 0",
      "    n.times do |j|",
      "      # TODO: language update",
      "      pivot = -1",
      "      mx = T.zero",
      "      (rank...n).each do |i|",
      "        if mx < ary[i][j].abs",
      "          mx = ary[i][j].abs",
      "          pivot = i",
      "        end",
      "      end",
      "      next if pivot == -1",
      "",
      "      ary.swap(pivot, rank)",
      "      res.swap(pivot, rank)",
      "",
      "      fac = ary[rank][j]",
      "      n.times do |k|",
      "        if fac.is_a? Float",
      "          ary[rank][k] /= fac",
      "          res[rank][k] /= fac",
      "        else",
      "          ary[rank][k] //= fac",
      "          res[rank][k] //= fac",
      "        end",
      "      end",
      "",
      "      n.times do |i|",
      "        if i != rank && ary[i][j].abs > T.zero",
      "          fac = ary[i][j]",
      "          n.times do |k|",
      "            ary[i][k] -= ary[rank][k] * fac",
      "            res[i][k] -= res[rank][k] * fac",
      "          end",
      "        end",
      "      end",
      "      rank += 1",
      "    end",
      "    Matrix(T).new res",
      "  end",
      "",
      "  def inv?",
      "    return nil unless is_regular?",
      "    inv",
      "  end",
      "",
      "  def tr : T",
      "    raise DimensionError.new(@n_rows, @n_cols) if @n_rows != @n_cols",
      "    n = @n_rows",
      "    n.times.sum{ |i| at(i, i) }",
      "  end",
      "",
      "  def tr?",
      "    return nil if @n_rows != @n_cols",
      "    tr",
      "  end",
      "",
      "  def sweep(extended? : Bool = false) : Int32",
      "    ary = to_a",
      "    h, w = @n_rows, @n_cols",
      "    rank = 0",
      "    w.times do |j|",
      "      break if extended? && j == w - 1",
      "",
      "      # TODO: language update",
      "      pivot = -1",
      "      mx = T.zero",
      "      (rank...h).each do |i|",
      "        if mx < ary[i][j].abs",
      "          mx = ary[i][j].abs",
      "          pivot = i",
      "        end",
      "      end",
      "      next if pivot == -1",
      "",
      "      ary.swap(pivot, rank)",
      "",
      "      fac = ary[rank][j]",
      "      ",
      "      w.times do |k|",
      "        if fac.is_a? Float",
      "          ary[rank][k] /= fac",
      "        else",
      "          ary[rank][k] //= fac",
      "        end",
      "      end",
      "",
      "      h.times do |i|",
      "        if i != rank && ary[i][j].abs > T.zero",
      "          fac = ary[i][j]",
      "          w.times{ |k| ary[i][k] -= ary[rank][k] * fac }",
      "        end",
      "      end",
      "      rank += 1",
      "    end",
      "",
      "    h.times{ |i| w.times{ |j| @m[@n_cols * i + j] = ary[i][j] } }",
      "",
      "    rank",
      "  end",
      "",
      "  def zero? : Bool",
      "    all?{ |x| x == T.zero }",
      "  end",
      "",
      "  def is_square?",
      "    @n_rows == @n_cols",
      "  end",
      "",
      "  def is_regular?",
      "    det != T.zero",
      "  end",
      "",
      "  def to_a : Array(Array(T))",
      "    @n_rows.times.map do |i|",
      "      @n_cols.times.map do |j|",
      "        at(i, j)",
      "      end.to_a",
      "    end.to_a",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    w = @m.max_of{ |a| a.to_s.size }",
      "    io << \"Matrix([\"",
      "    @n_rows.times do |i|",
      "      io << \" \" * 8 if i != 0",
      "      io << \"[\"",
      "      @n_cols.times do |j|",
      "        io << \", \" if j != 0",
      "        io << printf(\"%#{w}s\", at(i, j).to_s)",
      "      end",
      "      io << \"]\"",
      "      io << \")\" if i == @n_rows - 1",
      "      io << \"\\n\" if i < @n_rows - 1",
      "    end",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      "",
      "  private def over(i : Int, j : Int)",
      "    i < 0 || i >= @n_rows || j < 0 || j >= @n_cols",
      "  end",
      "end",
      "",
      "struct Int",
      "  def *(mat : Matrix(T))",
      "    Matrix.new(mat.row_size, mat.column_size) do |i, j|",
      "      self * mat[i, j]",
      "    end",
      "  end",
      "end"
    ],
    "description": "Matrix"
  },
  "反転数": {
    "prefix": "inversion_number",
    "body": [
      "module Indexable(T)",
      "  def inversion_number",
      "    n = size",
      "    csum = DynamicRangeSum(Int32).new(n)",
      "    (1...n).sum { |i|",
      "      csum.add(self[i - 1], 1)",
      "      i - csum[...self[i]]",
      "    }",
      "  end",
      "end"
    ],
    "description": "inversion_number"
  },
  "有理数": {
    "prefix": "Fraction",
    "body": [
      "struct Fraction",
      "  include Comparable(Fraction)",
      "",
      "  getter num : Int64",
      "  getter den : Int64",
      "",
      "  def self.zero",
      "    new",
      "  end",
      "",
      "  def self.infinity",
      "    new 1, 0",
      "  end",
      "",
      "  def initialize",
      "    @num = 0_i64",
      "    @den = 1_i64",
      "  end",
      "",
      "  def initialize(n : Int)",
      "    @num = n.to_i64",
      "    @den = 1_i64",
      "  end",
      "",
      "  def initialize(n : Int, d : Int)",
      "    @num = n.to_i64",
      "    @den = d.to_i64",
      "    reduce",
      "  end",
      "",
      "  def initialize(s : String)",
      "    pos = s.index(\".\")",
      "    if pos.nil?",
      "      @num = s.to_i64",
      "      @den = 1",
      "    else",
      "      @den = 1_i64",
      "      ten = 10_i64",
      "",
      "      m = s.size - 1 - pos",
      "      until m == 0",
      "        @den *= ten if m.bit(0) == 1",
      "        ten *= ten",
      "        m >>= 1",
      "      end",
      "",
      "      @num = 0",
      "      s.chars.each do |c|",
      "        @num = 10_i64 * @num + c.to_i if c != '.'",
      "      end",
      "    end",
      "    reduce",
      "  end",
      "",
      "  def infinity?",
      "    @den == 0",
      "  end",
      "",
      "  def inv : Fraction",
      "    Fraction.new(@den, @num)",
      "  end",
      "",
      "  def abs : Fraction",
      "    Fraction.new(@num.abs, @den.abs)",
      "  end",
      "",
      "  def num=(n : Int)",
      "    @num = n.to_i64",
      "    reduce",
      "  end",
      "",
      "  def den=(d : Int)",
      "    @den = d.to_i64",
      "    reduce",
      "  end",
      "",
      "  def +(other : Fraction)",
      "    l = infinity? || other.infinity? ? 1_i64 : @den.lcm(other.den)",
      "    n = @num * (l // @den) + other.num * (l // other.den)",
      "    Fraction.new(n, l)",
      "  end",
      "",
      "  def -(other : Fraction)",
      "    l = infinity? || other.infinity? ? 1_i64 : @den.lcm(other.den)",
      "    n = @num * (l // @den) - other.num * (l // other.den)",
      "    Fraction.new(n, l)",
      "  end",
      "",
      "  def *(other : Fraction)",
      "    g1 = @den.gcd(other.num)",
      "    g2 = @num.gcd(other.den)",
      "    n = (@num // g2) * (other.num // g1)",
      "    d = (@den // g1) * (other.den // g2)",
      "    Fraction.new(n, d)",
      "  end",
      "",
      "  def /(other : Fraction)",
      "    g1 = @den.gcd(other.num)",
      "    g2 = @num.gcd(other.den)",
      "    n = (@num // g2) * (other.den // g1)",
      "    d = (@den // g1) * (other.num // g2)",
      "    Fraction.new(n, d)",
      "  end",
      "",
      "  def //(other : Fraction)",
      "    self / other",
      "  end",
      "",
      "  def +(other : Int)",
      "    Fraction.new(@num + @den * other, @den)",
      "  end",
      "",
      "  def -(other : Int)",
      "    Fraction.new(@num - @den * other, @den)",
      "  end",
      "",
      "  def *(other : Int)",
      "    g = infinity? ? 1_i64 : @den.gcd(other)",
      "    Fraction.new(@num * (other // g), @den // g)",
      "  end",
      "",
      "  def /(other : Int)",
      "    g = infinity? ? 1_i64 : @num.gcd(other)",
      "    Fraction.new(@num // g, @den * (other // g))",
      "  end",
      "",
      "  def //(other : Int)",
      "    self / ther",
      "  end",
      "",
      "  def //(other : Fraction)",
      "    self // other",
      "  end",
      "",
      "  def +",
      "    self",
      "  end",
      "",
      "  def -",
      "    Fraction.new(-@num, @den)",
      "  end",
      "",
      "  # Note: オーバーフローの可能性があります。",
      "  def <=>(other : Fraction)",
      "    @num * other.den <=> @den * other.num",
      "  end",
      "",
      "  def to_f",
      "    @num / @den",
      "  end",
      "",
      "  def to_i",
      "    @num // @den",
      "  end",
      "",
      "  def to_i32",
      "    (@num // @den).to_i32",
      "  end",
      "",
      "  def to_i64",
      "    (@num // @den).to_i32",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    io << @num << '/' << @den",
      "  end",
      "",
      "  def inspect(io : IO)",
      "    to_s(io)",
      "  end",
      "",
      "  # 約分をします。",
      "  #",
      "  # 分数が負の場合は分子が負になるようにします。",
      "  #",
      "  # @num != 0 かつ @den != 0 かつ分母分子が互いに素でないとき `true` を返します。",
      "  def reduce : Bool",
      "    if @den < 0",
      "      @num *= -1",
      "      @den *= -1",
      "    end",
      "",
      "    if @num == 0",
      "      @den = 1",
      "      false",
      "    elsif @den == 0",
      "      @num = 1",
      "      false",
      "    else",
      "      g = @num.gcd(@den)",
      "      @num //= g",
      "      @den //= g",
      "      g != 1",
      "    end",
      "  end",
      "end",
      "",
      "struct Int",
      "  def to_frac",
      "    Fraction.new(self)",
      "  end",
      "end"
    ],
    "description": "Fraction"
  },
  "中国剰余定理": {
    "prefix": "crt",
    "body": [
      "module Math",
      "  def crt(rems : Array(Int64), mods : Array(Int64))",
      "    r0 = 0_i64",
      "    m0 = 1_i64",
      "    rems.zip(mods).each do |(r1, m1)|",
      "      r1 %= m1",
      "",
      "      if m0 < m1",
      "        r0, r1 = r1, r0",
      "        m0, m1 = m1, m0",
      "      end",
      "",
      "      if m0 % m1 == 0",
      "        return {0_i64, 0_i64} if r0 % m1 != r1",
      "        next",
      "      end",
      "",
      "      g, im = inv_gcd(m0, m1)",
      "",
      "      u1 = m1 // g",
      "      return {0_i64, 0_i64} if (r1 - r0) % g != 0",
      "",
      "      x = (r1 - r0) // g % u1 * im % u1",
      "      r0 += x * m0",
      "      m0 *= u1",
      "      r0 += m0 if r0 < 0",
      "    end",
      "",
      "    {r0, m0}",
      "  end",
      "",
      "  def inv_gcd(a : Int64, b : Int64)",
      "    a %= b",
      "    return {b, 0} if a == 0",
      "",
      "    s, t = b, a",
      "    m0, m1 = 0_i64, 1_i64",
      "",
      "    until t == 0",
      "      u = s // t",
      "      s -= t * u",
      "      m0 -= m1 * u",
      "      s, t = t, s",
      "      m0, m1 = m1, m0",
      "    end",
      "",
      "    m0 += b // s if m0 < 0",
      "    {s, m0}",
      "  end",
      "end"
    ],
    "description": "crt"
  },

  //────────────────────────────────────────────────────
  // 動的計画法
  //────────────────────────────────────────────────────
  "部分和問題": {
    "prefix": "SubsetSumSolver",
    "body": [
      "class SubsetSumSolver",
      "  enum ProblemType",
      "    ZeroOne",
      "    Limited",
      "    Unlimited",
      "  end",
      "",
      "  @type : ProblemType",
      "  @seq : Enumerable(Int32)",
      "  @capacity : Int32",
      "  @mod_old : Int64?",
      "  @exist : Array(Bool)",
      "  @ways : Array(Int64)",
      "",
      "  # 0-1 部分和問題を解くためのソルバを生成します。",
      "  #",
      "  # [0, capacity] の範囲で解きます。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.zeroone([1, 1, 2, 3, 4], capacity: 30)",
      "  # ```",
      "  def self.zeroone(seq : Enumerable(Int), capacity : Int)",
      "    new ProblemType::ZeroOne, seq.map(&.to_i32), capacity",
      "  end",
      "",
      "  # 個数制限付き部分和問題を解くためのソルバを生成します。",
      "  #",
      "  # [0, capacity] の範囲で解きます。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.limited([1, 2, 4], [{0, 1}, {3, 5}, {2, 10}], capacity: 30)",
      "  # ```",
      "  def self.limited(seq : Enumerable(Int32), lim : Enumerable(Int32), capacity : Int)",
      "    raise NotImplementedError.new(\"TODO\")",
      "    new ProblemType::Limited, seq.map(&.to_i32), capacity",
      "  end",
      "",
      "  # 個数制限なし部分和問題を解くためのソルバを生成します。",
      "  #",
      "  # [0, capacity] の範囲で解きます。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.unlimited([1, 1, 2, 3, 4], capacity: 30)",
      "  # ```",
      "  def self.unlimited(seq : Enumerable(Int), capacity : Int)",
      "    new ProblemType::Unlimited, seq.map(&.to_i32), capacity",
      "  end",
      "",
      "  def initialize(@type : ProblemType, @seq : Enumerable(Int32), capacity : Int)",
      "    @capacity = capacity.to_i32",
      "    @exist = Array(Bool).new",
      "    @ways = Array(Int64).new",
      "    @mod_old = nil",
      "  end",
      "",
      "  # 値 x が構成可能なら `true` を返します。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.zeroone([1, 1, 2, 3, 4], capacity: 30)",
      "  # ss.configurable?(0) # => true",
      "  # ss.configurable?(2) # => true",
      "  # ss.configurable?(30) # => false",
      "  # ```",
      "  def configurable?(x : Int)",
      "    unless @exist.empty?",
      "      return @exist[x]?.nil? ? false : @exist[x]",
      "    end",
      "",
      "    case @type",
      "    when ProblemType::ZeroOne",
      "      @exist = Array.new(@capacity + 1){ |i| i == 0 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).reverse_each do |j|",
      "          @exist[j] |= @exist[j - ai]",
      "        end",
      "      end",
      "    when ProblemType::Limited",
      "      raise NotImplementedError.new(\"TODO\")",
      "    when ProblemType::Unlimited",
      "      @exist = Array.new(@capacity + 1){ |i| i == 0 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).each do |j|",
      "          @exist[j] |= @exist[j - ai]",
      "        end",
      "      end",
      "    end",
      "",
      "    @exist[x]?.nil? ? false : @exist[x]",
      "  end",
      "",
      "  # 値 x が構成可能なら、構成例の1つを返します。",
      "  #",
      "  # 計算量が毎回 O(N * x) かかっていることに注意してください。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.zeroone([1, 1, 2, 3, 4], capacity: 30)",
      "  # ss.configurable?(0) # => true",
      "  # ss.configurable?(2) # => true",
      "  # ss.configurable?(30) # => false",
      "  # ```",
      "  def configure(x : Int) : Array(Int32)?",
      "    res = [] of Int32",
      "    case @type",
      "    when ProblemType::ZeroOne",
      "      a = @seq.to_a",
      "      n = @seq.size.to_i32",
      "      dp = Array.new(n + 1){ [false] * (x + 1) }",
      "      dp[0][0] = true",
      "      @seq.each_with_index(1) do |ai, i|",
      "        (0..x).each do |j|",
      "          dp[i][j] |= dp[i - 1][j]",
      "          dp[i][j] |= dp[i - 1][j - ai] if j >= ai",
      "        end",
      "      end",
      "",
      "      return nil unless dp[n][x]",
      "",
      "      cur = n",
      "      sum = x",
      "      until sum == 0",
      "        if sum >= a[cur - 1] && dp[cur - 1][sum - a[cur - 1]]",
      "          sum -= a[cur - 1]",
      "          res << cur - 1",
      "        end",
      "        cur -= 1",
      "      end",
      "",
      "      res.reverse!",
      "    when ProblemType::Limited",
      "      raise NotImplementedError.new(\"TODO\")",
      "    when ProblemType::Unlimited",
      "      a = @seq.to_a",
      "      n = @seq.size.to_i32",
      "      dp = Array.new(n + 1){ [false] * (x + 1) }",
      "      dp[0][0] = true",
      "      @seq.each_with_index(1) do |ai, i|",
      "        (0..x).each do |j|",
      "          dp[i][j] |= dp[i - 1][j]",
      "          dp[i][j] |= dp[i - 1][j - ai] if j >= ai",
      "          dp[i][j] |= dp[i][j - ai] if j >= ai",
      "        end",
      "      end",
      "",
      "      return nil unless dp[n][x]",
      "",
      "      cur = n",
      "      sum = x",
      "      until sum == 0",
      "        if a[cur - 1] != 0 && sum >= a[cur - 1] && dp[cur - 1][sum - a[cur - 1]]",
      "          while sum >= a[cur - 1] && dp[cur - 1][sum - a[cur - 1]]",
      "            sum -= a[cur - 1]",
      "            res << cur - 1",
      "          end",
      "        end",
      "        cur -= 1",
      "      end",
      "",
      "      res.reverse!",
      "    end",
      "",
      "    res",
      "  end",
      "",
      "  # 値 x の構成方法が何通りあるか返します。",
      "  #",
      "  # `mod` を指定すると `mod` で割ったあまりを返します。",
      "  #",
      "  # ```",
      "  # ss = SubsetSumSolver.zeroone([1, 1, 2, 3, 4], capacity: 30)",
      "  # ss.n_ways?(0, 998244353) # => 1",
      "  # ss.n_ways?(2, 998244353) # => 2",
      "  # ss.n_ways?(30, 998244353) # => 0",
      "  # ```",
      "  def n_ways(x : Int, mod : Int64 = nil)",
      "    if !@ways.empty? && mod == old_mod",
      "      return @ways[x]",
      "    end",
      "",
      "    case @type",
      "    when ProblemType::ZeroOne",
      "      @ways = Array.new(@capacity + 1){ |i| i == 0 ? 1_i64 : 0_i64 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).reverse_each do |j|",
      "          @ways[j] += @ways[j - ai]",
      "          @ways[j] %= mod.not_nil! unless mod.nil?",
      "        end",
      "      end",
      "    when ProblemType::Limited",
      "    when ProblemType::Unlimited",
      "      @ways = Array.new(@capacity + 1){ |i| i == 0 ? 1_i64 : 0_i64 }",
      "      @seq.each_with_index do |ai, i|",
      "        (ai..@capacity).each do |j|",
      "          @ways[j] += @ways[j - ai]",
      "          @ways[j] %= mod.not_nil! unless mod.nil?",
      "        end",
      "      end",
      "    end",
      "",
      "    old_mod = mod",
      "",
      "    @ways[x]",
      "  end",
      "end"
    ],
    "description": "部分和問題"
  },
  "最長共通部分列": {
    "prefix": ["lcs", "longest_common_subsequence"],
    "body": [
      "{% for type in [Array, String] %}",
      "class {{ type }}",
      "  # 最長共通部部分列の長さを返します。",
      "  #",
      "  # ```",
      "  # \"mynavi\".lcs(\"monday\") # => 3",
      "  # [0, 1, 2].lcs([0, 2, 5, 8]) # => 2",
      "  # ```",
      "  def lcs(other : {{ type }}) : Int64",
      "    n = self.size",
      "    m = other.size",
      "    dp = Array.new(n + 1){ Array.new(m + 1){ 0_i64 } }",
      "",
      "    (1..n).each do |i|",
      "      (1..m).each do |j|",
      "        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])",
      "        dp[i][j] = dp[i - 1][j - 1] + 1 if self[i - 1] == other[j - 1]",
      "      end",
      "    end",
      "",
      "    dp[n][m]",
      "  end",
      "end",
      "{% end %}"
    ],
    "description": "lcs"
  },
  "メモ化再帰": {
    "prefix": "Memoized",
    "body": [
      "cache = Array.new",
      "dp = uninitialized Int64 -> Nil",
      "dp = ->(arg : Int64) do",
      "  return cache[arg].not_nil! unless cache[arg].nil?",
      "",
      "  cache[arg] = dp.call(arg2)",
      "",
      "  cache[arg].not_nil!",
      "end"
    ],
    "description": "メモ化再帰"
  },
  "最長増加部分列": {
    "prefix": "lis",
    "body": [
      "class Array(T)",
      "  # 最長増加部分列の長さを返します。",
      "  #",
      "  # `strict が `true` の場合、狭義単調増加として考えます。",
      "  #",
      "  # ```",
      "  # [1, 9, 1, 2, 3, 8].lis(strict: true) # => 3",
      "  # [1, 9, 1, 2, 3, 8].lis(strict: false) # => 4",
      "  # ```",
      "  def lis(strict : Bool) : Int64",
      "    dp = Array(T).new",
      "    each do |v|",
      "      i = dp.bsearch_index{ |e| strict ? e >= v : e > v }",
      "      if i.nil?",
      "        dp << v",
      "      else",
      "        dp[i.not_nil!] = v",
      "      end",
      "    end",
      "    dp.size.to_i64",
      "  end",
      "",
      "  # 最長増加部分列の長さを返します。",
      "  #",
      "  # `strict が `true` の場合、狭義単調増加として考えます。",
      "  #",
      "  # ```",
      "  # [1, 9, 1, 2, 3, 8].lis_by(strict: true){ |x| x**2 } # => 3",
      "  # [1, 9, 1, 2, 3, 8].lis_by(strict: false){ |x| x**2 } # => 4",
      "  # ```",
      "  def lis_by(strict : Bool, & : T -> U) : Int64 forall U",
      "    dp = Array(U).new",
      "    map{ |v| yield v }.each do |v|",
      "      i = dp.bsearch_index{ |e| strict ? e >= v : e > v }",
      "      if i.nil?",
      "        dp << v",
      "      else",
      "        dp[i.not_nil!] = v",
      "      end",
      "    end",
      "    dp.size.to_i64",
      "  end",
      "end"
    ],
    "description": "lis"
  },
  "ダブリング": {
    "prefix": ["BinaryLifting", "Doubling"],
    "body": [
      "class BinaryLifting(T)",
      "  getter size : Int32",
      "  @lim : UInt64",
      "  @log : Int32",
      "  @table : Array(Array({Int32, T}))",
      "  @should_build : Bool",
      "",
      "  # n 頂点 0 辺のグラフを作ります。",
      "  #",
      "  # 移動回数の上限を limit で指定します。",
      "  # initial でノードの初期値を指定します。",
      "  #",
      "  # ```",
      "  # n = 10",
      "  # graph = BinaryLifting.new(n)",
      "  # ```",
      "  def initialize(n : Int, limit : Int = UInt64::MAX // 2, initial : T = T.zero)",
      "    @size = n.to_i32",
      "    @lim = limit.to_u64",
      "    @log = impl_log2(limit)",
      "    @table = Array.new(n){ Array.new(@log){ {-1, T.zero} } }",
      "    @should_build = true",
      "  end",
      "",
      "  # n 頂点 n 辺のグラフを作ります。",
      "  #",
      "  # ブロックで各 i に対する移動先と重みをタプルで返す必要があります。",
      "  #",
      "  # 移動回数の上限を limit で指定します。",
      "  # initial でノードの初期値を指定します。",
      "  #",
      "  # ```",
      "  # n = 10",
      "  # graph = BinaryLifting.new(n){ |i| {a[i].to_i32, 0} }",
      "  # ```",
      "  def initialize(n : Int, limit : Int = UInt64::MAX // 2, initial : T = T.zero, & : Int32 -> {Int32, T})",
      "    @size = n.to_i32",
      "    @lim = limit.to_u64",
      "    @log = impl_log2(limit)",
      "    @table = Array.new(n){ |i| Array.new(@log){ |j| j == 0 ? (yield i) : {-1, T.zero} } }",
      "    @should_build = true",
      "  end",
      "",
      "  # 頂点 s から頂点 t に重み weight の辺を追加します。",
      "  #",
      "  # ```",
      "  # n = 10",
      "  # graph = BinaryLifting.new(n){ |i| {a[i].to_i32, 0} }",
      "  # graph.add_edge(0, 1, 10)",
      "  # graph.add_edge(1, 5, 3)",
      "  # graph.add_edge(5, 1, 2)",
      "  # ```",
      "  def add_edge(s : Int, t : Int, weight : T = T.zero)",
      "    @table[s][0] = {t.to_i32, weight}",
      "    @should_build = true",
      "  end",
      "",
      "  # query　が高速にできるよう、データを構築します。",
      "  def build",
      "    (0...@log - 1).each do |k|",
      "      @size.times do |i|",
      "        pre = @table[i][k][0]",
      "        if pre == -1",
      "          @table[i][k + 1] = @table[i][k]",
      "        else",
      "          nxt = @table[pre][k][0]",
      "          w = @table[i][k][1] + @table[pre][k][1]",
      "          @table[i][k + 1] = {nxt, w}",
      "        end",
      "      end",
      "    end",
      "    @should_build = false",
      "  end",
      "",
      "  # 頂点 start から times 回移動したときいる場所を返します。",
      "  #",
      "  # ```",
      "  # n = 3",
      "  # graph = BinaryLifting.new(n)",
      "  # graph.add_edge(0, 1, 1)",
      "  # graph.add_edge(1, 2, 10)",
      "  # graph.add_edge(2, 1, 100)",
      "  #",
      "  # graph.where(start: 0, times: 5) # => 2",
      "  # graph.where(start: 1, times: 5) # => 0",
      "  # ```",
      "  def where(start : Int, times : Int)",
      "    build if @should_build",
      "    query(start, times)[1]",
      "  end",
      "",
      "  # 頂点 start から times 回移動したときいる場所を返します。",
      "  #",
      "  # build 済みかの確認を行いません。",
      "  #",
      "  # ```",
      "  # n = 3",
      "  # graph = BinaryLifting.new(n)",
      "  # graph.add_edge(0, 1, 1)",
      "  # graph.add_edge(1, 2, 10)",
      "  # graph.add_edge(2, 0, 100)",
      "  #",
      "  # graph.where!(start: 0, times: 5) # => 2",
      "  # graph.where!(start: 1, times: 5) # => 0",
      "  # ```",
      "  def where!(start : Int, times : Int)",
      "    query!(start, times)[1]",
      "  end",
      "",
      "  # 頂点 start から times 回移動する経路中の重みの総和を返します。",
      "  #",
      "  # ```",
      "  # n = 3",
      "  # graph = BinaryLifting.new(n)",
      "  # graph.add_edge(0, 1, 1)",
      "  # graph.add_edge(1, 2, 10)",
      "  # graph.add_edge(2, 0, 100)",
      "  #",
      "  # graph.weight_sum(start: 0, times: 5) # => 122",
      "  # graph.weight_sum(start: 1, times: 5) # => 221",
      "  # ```",
      "  def weight_sum(start : Int, times : Int)",
      "    build if @should_build",
      "    query(start, times)[0]",
      "  end",
      "",
      "  # 頂点 start から times 回移動する経路中の重みの総和を返します。",
      "  #",
      "  # build 済みかの確認を行いません。",
      "  #",
      "  # ```",
      "  # n = 3",
      "  # graph = BinaryLifting.new(n)",
      "  # graph.add_edge(0, 1, 1)",
      "  # graph.add_edge(1, 2, 10)",
      "  # graph.add_edge(2, 0, 100)",
      "  #",
      "  # graph.weight_sum!(start: 0, times: 5) # => 122",
      "  # graph.weight_sum!(start: 1, times: 5) # => 221",
      "  # ```",
      "  def weight_sum!(start : Int, times : Int)",
      "    query!(start, times)[0]",
      "  end",
      "",
      "  # 頂点 start から times 回移動する経路中の重みの総和と場所を返します。",
      "  #",
      "  # ```",
      "  # n = 3",
      "  # graph = BinaryLifting.new(n)",
      "  # graph.add_edge(0, 1, 1)",
      "  # graph.add_edge(1, 2, 10)",
      "  # graph.add_edge(2, 0, 100)",
      "  #",
      "  # graph.query(start: 0, times: 5) # => {2, 122}",
      "  # graph.query(start: 1, times: 5) # => {0, 221}",
      "  # ```",
      "  def query(start : Int, times : Int)",
      "    build if @should_build",
      "    query!(start, times)",
      "  end",
      "",
      "  # 頂点 start から times 回移動する経路中の重みの総和と場所を返します。",
      "  #",
      "  # build 済みかの確認を行いません。",
      "  #",
      "  # ```",
      "  # n = 3",
      "  # graph = BinaryLifting.new(n)",
      "  # graph.add_edge(0, 1, 1)",
      "  # graph.add_edge(1, 2, 10)",
      "  # graph.add_edge(2, 0, 100)",
      "  #",
      "  # graph.query!(start: 0, times: 5) # => {2, 122}",
      "  # graph.query!(start: 1, times: 5) # => {0, 221}",
      "  # ```",
      "  def query!(start : Int, times : Int)",
      "    acc = T.zero",
      "    (@log - 1).downto(0).each do |k|",
      "      if times.bit(k) == 1",
      "        acc += @table[start][k][1]",
      "        start = @table[start][k][0]",
      "      end",
      "      break if start == -1",
      "    end",
      "    {acc, start}",
      "  end",
      "",
      "  [AlwaysInline]",
      "  def impl_log2(x : Int) : Int32",
      "    Int32.new(sizeof(typeof(x)) * 8 - x.leading_zeros_count)",
      "  end",
      "end"
    ],
    "description": "BinaryLifting"
  },

  //────────────────────────────────────────────────────
  // 文字列
  //────────────────────────────────────────────────────
  "Zアルゴリズム": {
    "prefix": "z_algorithm",
    "body": [
      "class Array(T)",
      "  def z_algorithm",
      "    n = size",
      "    return [] of Int32 if n == 0",
      "    z = Array(Int32).new(n){ 0 }",
      "    z[0] = 0",
      "    i = 1",
      "    j = 0",
      "    while i < n",
      "      z[i] = (j + z[j] <= i) ? 0 : Math.min(j + z[j] - i, z[i - j])",
      "      while i + z[i] < n && self[z[i]] == self[i + z[i]]",
      "        z[i] += 1",
      "      end",
      "      j = i if j + z[j] < i + z[i]",
      "      i += 1",
      "    end",
      "    z[0] = n",
      "    z",
      "  end",
      "end",
      "",
      "class String",
      "  def z_algorithm",
      "    chars.z_algorithm",
      "  end",
      "end"
    ],
    "description": "z_algorithm"
  },
  "ローリングハッシュ": {
    "prefix": "RollingHash",
    "body": [
      "class RollingHash",
      "  MOD = (1_u64 << 61) - 1 ",
      "",
      "  getter size : Int32",
      "  @base : UInt64",
      "  @power : Array(UInt64)",
      "  @hash : Array(UInt64)",
      "",
      "  # 配列 a に対する、基数が base のロリハを構築します。",
      "  #",
      "  # base は指定しない場合、ランダムに生成されます。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new([1, 2, 5, 1, 2])",
      "  # ```",
      "  def initialize(a : Array(Int), base : UInt64? = nil)",
      "    initialize(a.size, a, base)",
      "  end",
      "",
      "  # 文字列 s に対する、基数が base のロリハを構築します。",
      "  #",
      "  # base は指定しない場合、ランダムに生成されます。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\")",
      "  # ```",
      "  def initialize(s : String, base : UInt64? = nil )",
      "    initialize(s.size, s.bytes, base)",
      "  end",
      "",
      "  # Enumerable な列 a に対する、基数が base のロリハを構築します。",
      "  #",
      "  # base は指定しない場合、ランダムに生成されます。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new([1, 2, 5, 1, 2])",
      "  # ```",
      "  def initialize(@size, a : Enumerable, base : UInt64? = nil)",
      "    base = RollingHash.create_base if base.nil?",
      "    @base = base.not_nil!",
      "",
      "    @power = [1_u64] * (@size + 1)",
      "    @hash = [0_u64] * (@size + 1)",
      "",
      "    a.each_with_index do |x, i|",
      "      @power[i + 1] = mul(@power[i], @base)",
      "      @hash[i + 1] = mul(@hash[i], @base) + x.to_u64",
      "      @hash[i + 1] -= MOD if @hash[i + 1] >= MOD",
      "    end",
      "  end",
      "",
      "  # ランダムに基底を生成します。",
      "  #",
      "  # ```",
      "  # base = RollingHash.create_base",
      "  # base # => 1729",
      "  # ```",
      "  def self.create_base",
      "    rand(628_u64..MOD - 2)",
      "  end",
      "",
      "  # 文字列 s のハッシュを返します。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\")",
      "  # rh.hash(\"is\") # => 339225237399054811",
      "  # rh.hash(\"abc\") # => 496222201481864933",
      "  # ```",
      "  def hash(s : String)",
      "    hash(s.bytes)",
      "  end",
      "",
      "  # 列 s のハッシュを返します。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\")",
      "  # rh.hash(\"is\") # => 339225237399054811",
      "  # rh.hash(\"abc\") # => 496222201481864933",
      "  # ```",
      "  def hash(s : Enumerable)",
      "    s.reduce(0_u64){ |acc, ti| mul(acc, @base) + ti.to_u64 }",
      "  end",
      "",
      "  # s[start...start + length] のハッシュを返します。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\")",
      "  # rh.substr(4, length: 2) # => 339225237399054811",
      "  # rh.substr(5, length: 2) # => 339225237399054811",
      "  # ```",
      "  def substr(start : Int, length : Int) : UInt64",
      "    res = @hash[start + length] + MOD - mul(@hash[start], @power[length])",
      "    res < MOD ? res : res - MOD",
      "  end",
      "",
      "  # rangeで指定した範囲 s[l...r] のハッシュを返します。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\")",
      "  # rh.slice(4..5) # => 339225237399054811",
      "  # rh.slice(5..6) # => 339225237399054811",
      "  # ```",
      "  def slice(range : Range(Int?, Int?)) : UInt64",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "  ",
      "    length = right - left",
      "",
      "    substr(start: left, length: length)",
      "  end",
      "",
      "  # rangeで指定した範囲 s[l...r] のハッシュを返します。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\")",
      "  # rh[4..5] # => 339225237399054811",
      "  # rh[5..6] # => 339225237399054811",
      "  # ```",
      "  def [](range : Range(Int?, Int?)) : UInt64",
      "    slice(range)",
      "  end",
      "",
      "  # ハッシュ値 h1 とハッシュ値 h2 を結合したときのハッシュ値を返します。",
      "  #",
      "  # ハッシュ値 h2 の元々の長さを渡す必要があります。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\")",
      "  # h1 = rh[1..2] # \"is\"",
      "  # h2 = rh[5..6] # \"si\"",
      "  # h = rh.concat(h1, h2, h2_len: 2)",
      "  # h == rh.[1..4] # => true",
      "  # ```",
      "  def concat(h1 : UInt64, h2 : UInt64, h2_len : Int) : UInt64",
      "    res = mul(h1, @power[h2_len]) + h2",
      "    res < MOD ? res : res - MOD",
      "  end",
      "",
      "  # s[i...] と other[j...] の最長共通接頭辞の長さを返します。",
      "  #",
      "  # other はデフォルトで自分自身を渡しています。",
      "  # 自分自身以外を渡す場合は (mod, base) が一致している必要があります。",
      "  #",
      "  # ```",
      "  # rh1 = RollingHash.new(\"missisippi\")",
      "  # rh1 = rh1.lcp(3, 5) # => 2",
      "  # rh1 = rh1.lcp(0, 1) # => 0",
      "  # ```",
      "  def lcp(i : Int, j : Int, other = self) : Int32",
      "    length = Math.min(@hash.size - i, @hash.size - j)",
      "",
      "    ok = length - (1..length).bsearch{ |len|",
      "      l = length - len",
      "      self.substr(start: i, length: l) == other.substr(start: j, length: l)",
      "    }.not_nil!",
      "",
      "    return ok.to_i32",
      "  end",
      "",
      "  # s[i...] と t[j...] の最長共通接頭辞の長さを返します。",
      "  #",
      "  # i, j はデフォルトで 0 を渡しています。",
      "  #",
      "  # ```",
      "  # rh1 = RollingHash.new(\"missisippi\", base: 628)",
      "  # rh2 = RollingHash.new(\"thisisapen\", base: 628)",
      "  # RollingHash.lcp(rh1, rh2) # => 0",
      "  # RollingHash.lcp(rh1, rh2, 4, 2) # => 3",
      "  # ```",
      "  def self.lcp(rh1 : self, rh2 : self, i : Int = 0, j : Int = 0) : Int32",
      "    rh1.lcp(i, j, rh2)",
      "  end",
      "",
      "  # 文字列検索を行います。",
      "  #",
      "  # s[offset..] から t と一致する初めての添字を返します。",
      "  # 添字は s が基準です。また、offset が加算された値が返ります。",
      "  #",
      "  # 存在しない場合は nil を返します。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\", base: 628)",
      "  # rh.index(\"is\") # => 1",
      "  # rh.index(\"is\", offset: 4) # => 4",
      "  # rh.index(\"mid\") # => nil",
      "  # rh.index(\"i\") # => 1",
      "  # rh.index(\"pi\") # => 8",
      "  # ```",
      "  def index(t : String, offset : Int = 0) : Int32?",
      "    index(t.bytes, offset)",
      "  end",
      "",
      "  # 検索を行います。",
      "  #",
      "  # s[offset..] から t と一致する初めての添字を返します。",
      "  # 添字は s が基準です。また、offset が加算された値が返ります。",
      "  #",
      "  # 存在しない場合は nil を返します。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\", base: 628)",
      "  # rh.index(\"is\") # => 1",
      "  # rh.index(\"is\", offset: 4) # => 4",
      "  # rh.index(\"mid\") # => nil",
      "  # rh.index(\"i\") # => 1",
      "  # rh.index(\"pi\") # => 8",
      "  # ```",
      "  def index(t : Enumerable, offset : Int = 0) : Int32?",
      "    ths = hash(t)",
      "    t_len = t.size",
      "    res = (offset..@size - t.size).index{ |i| ths == substr(i, t_len) }",
      "    res ? res.not_nil! + offset : nil",
      "  end",
      "",
      "  # 文字列検索を行います。",
      "  #",
      "  # s[offset..] から t と一致する初めての添字を返します。",
      "  # 添字は s が基準です。また、offset が加算された値が返ります。",
      "  #",
      "  # 存在しない場合は例外を投げます。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\", base: 628)",
      "  # rh.index!(\"is\") # => 1",
      "  # rh.index!(\"is\", offset: 4) # => 4",
      "  # rh.index!(\"mid\") # => Enumerable::NotFoundError",
      "  # rh.index!(\"i\") # => 1",
      "  # rh.index!(\"pi\") # => 8",
      "  # ```",
      "  def index!(t : String, offset : Int = 0) : Int32",
      "    index!(t.bytes, offset)",
      "  end",
      "",
      "  # 検索を行います。",
      "  #",
      "  # s[offset..] から t と一致する初めての添字を返します。",
      "  # 添字は s が基準です。また、offset が加算された値が返ります。",
      "  #21",
      "  # 存在しない場合は例外を投げます。",
      "  #",
      "  # ```",
      "  # rh = RollingHash.new(\"missisippi\", base: 628)",
      "  # rh.index!(\"is\") # => 1",
      "  # rh.index!(\"is\", offset: 4) # => 4",
      "  # rh.index!(\"mid\") # => Enumerable::NotFoundError",
      "  # rh.index!(\"i\") # => 1",
      "  # rh.index!(\"pi\") # => 8",
      "  # ```",
      "  def index!(t : Enumerable, offset : Int = 0) : Int32",
      "    ths = 0_u64",
      "    t.each{ |ti| ths = mul(ths, @base) + ti.to_u64 }",
      "    t_len = t.size",
      "    (offset..@size - t.size).index!{ |i| ths == substr(i, t_len) } + offset",
      "  end",
      "",
      "  @[AlwaysInline]",
      "  private def mul(a : UInt64, b : UInt64) : UInt64",
      "    t = a.to_u128 * b",
      "    t = (t >> 61) + (t & MOD)",
      "    (t < MOD ? t : t - MOD).to_u64",
      "  end",
      "end"
    ],
    "description": "RollingHash"
  },
  "ランレングス符号変換": {
    "prefix": "runLengthEncoding",
    "body": [
      "s.chars.slice_when{ |i, j| i != j }.map{ |a| { a[0], a.size} }.to_a"
    ],
    "description": "runLengthEncoding"
  },
  "編集距離": {
    "prefix": ["edit_distance", "levenshtein_distance"],
    "body": [
      "module Enumerable(T)",
      "  def edit_distance(other : Enumerable(T), del_cost : Int = 1, rep_cost : Int = 1, ins_cost : Int = 1)",
      "    n = self.size",
      "    m = other.size",
      "",
      "    dp = Array.new(n + 1){ |i| i * ins_cost }",
      "",
      "    other.each_with_index do |tj, j|",
      "      dp2 = dp.clone",
      "      dp2[0] += ins_cost",
      "      self.each_with_index do |si, i|",
      "        dp2[i + 1] = {",
      "          dp[i] + (si == tj ? 0 : rep_cost),",
      "          dp[i + 1] + ins_cost,",
      "          dp2[i] + del_cost,",
      "        }.min",
      "      end",
      "      dp = dp2",
      "    end",
      "",
      "    dp[n]",
      "  end",
      "end"
    ],
    "description": "編集距離"
  },

  //────────────────────────────────────────────────────
  // データ構造
  //────────────────────────────────────────────────────
  "全要素リセット付き配列": {
    "prefix": "AllAssignableArray",
    "body": [
      "class AllAssignableArray(T)",
      "  include Enumerable(T)",
      "",
      "  getter size : Int32",
      "  @data : Array(T)",
      "  @updated_time : Array(Int32)",
      "  @time : Int32",
      "  @last_k : T",
      "",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @data = Array.new(n){ T.zero }",
      "    @updated_time = Array.new(n){ 0 }",
      "    @time = 0",
      "    @last_k = T.zero",
      "  end",
      "",
      "  def initialize(n : Int, value : T)",
      "    @size = n.to_i32",
      "    @data = Array.new(n, value)",
      "    @updated_time = Array.new(n){ 0 }",
      "    @time = 0",
      "    @last_k = value",
      "  end",
      "",
      "  def initialize(n : Int, & : Int32 -> T)",
      "    @size = n.to_i32",
      "    @data = Array.new(n){ T.zero }",
      "    @updated_time = Array.new(n){ 0 }",
      "    @time = 0",
      "    @last_k = T.zero",
      "",
      "    @size.times do |i|",
      "      @data[i] = yield i",
      "    end",
      "  end",
      "",
      "  def each(& : T ->)",
      "    @size.times do |i|",
      "      yield self[i]",
      "    end",
      "  end",
      "",
      "  def [](i : Int)",
      "    @updated_time[i] < @time ? @last_k : @data[i]",
      "  end",
      "",
      "  def []?(i : Int)",
      "    return nil if i >= @size",
      "    @updated_time[i] < @time ? @last_k : @data[i]",
      "  end",
      "",
      "  def []=(i : Int, value : T)",
      "    @data[i] = value",
      "    @updated_time[i] = @time",
      "  end",
      "",
      "  def all_assign(value : T)",
      "    @time += 1",
      "    @last_k = value",
      "  end",
      "end"
    ],
    "description": "AllAssignableArray"
  },
  "二分ヒープ": {
    "prefix": "Heap",
    "body": [
      "class Heap(T)",
      "  include Comparable(Heap(T))",
      "",
      "  delegate size, to: hp",
      "  delegate empty?, to: hp",
      "  getter hp : Array(T)",
      "",
      "  def <=>(other : Heap(T))",
      "    @hp <=> other.hp",
      "  end",
      "",
      "  def self.min",
      "    new { |a, b| a > b }",
      "  end",
      "",
      "  def self.max",
      "    new { |a, b| a < b }",
      "  end",
      "",
      "  def initialize",
      "    @cmp = ->(a : T, b : T) { a < b }",
      "    @hp = Array(T).new",
      "  end",
      "",
      "  def initialize(&@cmp : (T, T) -> Bool)",
      "    @hp = Array(T).new",
      "  end",
      "",
      "  def <<(value : T)",
      "    push(value)",
      "  end",
      "",
      "  def push(value : T)",
      "    @hp.push(value)",
      "    child = @hp.size - 1",
      "    v = @hp[child]",
      "    while child > 0",
      "      parent = (child - 1) // 2",
      "      unless @cmp.call @hp[parent], v",
      "        break",
      "      end",
      "      @hp.swap(parent, child)",
      "      child = parent",
      "    end",
      "    @hp[child] = v",
      "  end",
      "",
      "  def pop",
      "    len = @hp.size - 1",
      "    if len > 0",
      "      v = @hp[len]",
      "      @hp[len] = @hp[0]",
      "      parent = 0",
      "      child = 1",
      "      while child < len",
      "        if child + 1 < len && @cmp.call @hp[child], @hp[child + 1]",
      "          child += 1",
      "        end",
      "        unless @cmp.call v, @hp[child]",
      "          break",
      "        end",
      "        @hp.swap(parent, child)",
      "        parent = child",
      "        child = 2*parent + 1",
      "      end",
      "      @hp[parent] = v",
      "    end",
      "    @hp.pop",
      "  end",
      "",
      "  def peek",
      "    @hp.first",
      "  end",
      "",
      "  def clear",
      "    @hp.clear",
      "  end",
      "end"
    ],
    "description": "Heap"
  },
  "累積和": {
    "prefix": "StaticRangeSum",
    "body": [
      "class StaticRangeSum(T)",
      "  getter size : Int64",
      "  getter csum : Array(T)",
      "",
      "  def initialize(array : Array(T))",
      "    @size = array.size.to_i64",
      "    @csum = Array.new(@size + 1, T.zero)",
      "    @size.times { |i| @csum[i + 1] = @csum[i] + array[i] }",
      "  end",
      "",
      "  def get(left, right) : T",
      "    raise IndexError.new(\"`left` must be less than or equal to `right` (#{left}, #{right})\") unless left <= right",
      "    @csum[right] - @csum[left]",
      "  end",
      "",
      "  def get(range : Range(Int?, Int?)) : T",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    get(left, right)",
      "  end",
      "  ",
      "  def get?(left, right) : T?",
      "    return nil unless left <= right",
      "    get(left, right)",
      "  end",
      "",
      "  def get?(range : Range(Int?, Int?)) : T?",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    get?(left, right)",
      "  end",
      "",
      "  def get!(left, right) : T",
      "    @csum[right] - @csum[left]",
      "  end",
      "",
      "  def get!(range : Range(Int?, Int?)) : T",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    get!(left, right)",
      "  end",
      "",
      "  def [](left, right) : T; get(left, right) end",
      "  def [](range : Range(Int?, Int?)) : T; get(range) end",
      "  def []?(left, right) : T?; get?(left, right) end",
      "  def []?(range : Range(Int?, Int?)) : T?; get?(range) end",
      "end"
    ],
    "description": "StaticRangeSum"
  },
  "動的累積和": {
    "prefix": "DynamicRangeSum",
    "body": [
      "class DynamicRangeSum(T)",
      "  getter size : Int32",
      "  @data : Array(T)",
      "",
      "  def initialize(n : Int)",
      "    @data = Array(T).new(n){ T.zero }",
      "    @size = @data.size",
      "  end",
      "",
      "  def initialize(n : Int, val : T)",
      "    @data = Array(T).new(n){ val }",
      "    @size = @data.size",
      "  end",
      "",
      "  def initialize(elems : Enumerable(T))",
      "    @size = elems.size.to_i32",
      "    @data = Array(T).new(@size, T.zero)",
      "    elems.each_with_index{ |x, i| add(i, x) }",
      "  end",
      "",
      "  def get(left : Int, right : Int) : T",
      "    raise IndexError.new(\"`left` and `right` must be 0 <= left <= right <= self.size (#{left}, #{right})\") unless 0 <= left && left <= right && right <= @size",
      "    sum(right) - sum(left)",
      "  end",
      "",
      "  def get?(left : Int, right : Int) : T?",
      "    return nil unless 0 <= left && left <= right && right <= @size",
      "    get(left, right)",
      "  end",
      "",
      "  def get(i : Int) : T",
      "    get(i, i + 1)",
      "  end",
      "",
      "  def get?(i : Int) : T?",
      "    get?(i, i + 1)",
      "  end",
      "",
      "  {% begin %}",
      "    {% for int1 in Int.union_types + [Nil] %}",
      "      {% for int2 in Int.union_types + [Nil] %}",
      "        def get(range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get(left, right)",
      "        end",
      "",
      "        def get?(range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get?(left, right)",
      "        end",
      "",
      "        def [](range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get(left, right)",
      "        end",
      "",
      "        def []?(range : Range({{ int1.id }}, {{ int2.id }})) : T",
      "          left = (range.begin || 0)",
      "          right = range.end ? range.end.not_nil! + (range.exclusive? ? 0 : 1) : @size",
      "          get?(left, right)",
      "        end",
      "      {% end %}",
      "    {% end %}",
      "  {% end %}",
      "",
      "  def [](i : Int) : T; get(i, i + 1) end",
      "  def []?(i : Int) : T?; get?(i, i + 1) end",
      "",
      "  def [](l : Int, r : Int) : T; get(l, r) end",
      "  def []?(l : Int, r : Int) : T?; get?(l, r) end",
      "",
      "  def []=(i : Int, x : T) : T; add(i, x - get(i)) end",
      "",
      "  def set(i : Int, x : T)",
      "    self[i] = x",
      "  end",
      "",
      "  def add(i : Int, x : T)",
      "    i += 1",
      "    while (i <= @size)",
      "      @data[i - 1] += x",
      "      i += i & -i",
      "    end",
      "    x",
      "  end",
      "",
      "  private def sum(r : Int) : T",
      "    s = T.zero",
      "    while r > 0",
      "      s += @data[r - 1]",
      "      r -= r & -r",
      "    end",
      "    s",
      "  end",
      "end"
    ],
    "description": "DynamicRangeSum"
  },
  "二次元累積和": {
    "prefix": "StaticRectangleSum",
    "body": [
      "class StaticRectangleSum(T)",
      "  getter height : Int32",
      "  getter width : Int32",
      "  getter csum : Array(Array(T))",
      "",
      "  def initialize(grid : Array(Array(T)))",
      "    @height = grid.size",
      "    @width = (grid[0]? || [] of T).size",
      "    @csum = Array.new(@height + 1){ Array.new(@width + 1){ T.zero } }",
      "    @height.times do |i|",
      "      @width.times do |j|",
      "        @csum[i + 1][j + 1] = @csum[i][j + 1] + @csum[i + 1][j] - @csum[i][j] + grid[i][j]",
      "      end",
      "    end",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T",
      "    raise IndexError.new(\"`y_begin` must be less than or equal to `y_end` (#{y_begin}, #{y_end})\") unless y_begin <= y_end",
      "    raise IndexError.new(\"`x_begin` must be less than or equal to `x_end` (#{x_begin}, #{x_end})\") unless x_begin <= x_end",
      "    @csum[y_end][x_end] - @csum[y_begin][x_end] - @csum[y_end][x_begin] + @csum[y_begin][x_begin]",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get?(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T?",
      "    return nil unless y_begin <= y_end",
      "    return nil unless x_begin <= x_end",
      "    @csum[y_end][x_end] - @csum[y_begin][x_end] - @csum[y_end][x_begin] + @csum[y_begin][x_begin]",
      "  end",
      "",
      "  # 累積和を取得します。",
      "  #",
      "  # Range(y_begin, y_end), Range(x_begin, x_end) で指定します。",
      "  #",
      "  # ```",
      "  # csum = StaticRectangleSum.new(a)",
      "  # csum.get(0...h, j..j + 2) # => 28",
      "  # ```",
      "  def get(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # ```",
      "  # csum = StaticRectangleSum.new(a)",
      "  # csum.get?(0...h, j..j + 2) # => 28",
      "  # csum.get?(0...100*h, j..j + 2) # => nil",
      "  # ```",
      "  def get?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get?(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  def [](y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    get(y_range, x_range)",
      "  end",
      "",
      "  def []?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    get?(y_range, x_range)",
      "  end",
      "end"
    ],
    "description": "二次元累積和"
  },
  "動的二次元累積和": {
    "prefix": "DynamicRectangleSum",
    "body": [
      "class DynamicRectangleSum(T)",
      "  getter height : Int32",
      "  getter width : Int32",
      "  getter csum : Array(Array(T))",
      "",
      "  def initialize(h : Int, w : Int)",
      "    @height = h.to_i32",
      "    @width = w.to_i32",
      "    @csum = Array.new(h + 1){ Array.new(w + 1, T.zero) }",
      "  end",
      "",
      "  def initialize(grid : Array(Array(T)))",
      "    @height = grid.size",
      "    @width = (grid[0]? || [] of T).size",
      "    @csum = Array.new(@height + 1){ Array.new(@width + 1){ T.zero } }",
      "    @height.times do |i|",
      "      @width.times do |j|",
      "        add(i, j, grid[i][j])",
      "      end",
      "    end",
      "  end",
      "",
      "  # (y, x) の要素に val を足します。",
      "  #",
      "  # 添字は 0-index です。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.add(y, x, val) # => val",
      "  # ```",
      "  def add(y : Int, x : Int, val : T) : T",
      "    raise IndexError.new(\"y = #{y} が配列外参照しています。 (@height = #{@height}\") if y < 0 || y >= @height",
      "    raise IndexError.new(\"x = #{x} が配列外参照しています。 (@height = #{@width}\") if x < 0 || x >= @width",
      "    i = y + 1",
      "    while i <= @height",
      "      j = x + 1",
      "      while j <= @width",
      "        @csum[i][j] += val",
      "        j += (j & -j)",
      "      end",
      "      i += (i & -i)",
      "    end",
      "    val",
      "  end",
      "",
      "  # (y, x) の要素に val を足します。",
      "  #",
      "  # 添字は 0-index です。",
      "  #",
      "  # 加算に成功した場合 `true` を返します。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.add?(y, x, x) # => true",
      "  # ```",
      "  def add?(y : Int, x : Int, val : T) : Bool",
      "    return false if y < 0 || y >= @height",
      "    return false if x < 0 || x >= @width",
      "    i = y + 1",
      "    while i <= @height",
      "      j = x + 1",
      "      while j <= @width",
      "        @csum[i][j] += val",
      "        j += (j & -j)",
      "      end",
      "      i += (i & -i)",
      "    end",
      "    true",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T",
      "    raise IndexError.new(\"`y_begin` must be less than or equal to `y_end` (#{y_begin}, #{y_end})\") unless y_begin <= y_end",
      "    raise IndexError.new(\"`x_begin` must be less than or equal to `x_end` (#{x_begin}, #{x_end})\") unless x_begin <= x_end",
      "    query(y_end, x_end) - query(y_end, x_begin) - query(y_begin, x_end) + query(y_begin, x_begin)",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # NOTE: このAPIは非推奨です。Rangeで指定することが推奨されます。",
      "  def get?(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int) : T?",
      "    return nil unless y_begin <= y_end",
      "    return nil unless x_begin <= x_end",
      "    query(y_end, x_end) - query(y_end, x_begin) - query(y_begin, x_end) + query(y_begin, x_end)",
      "  end",
      "",
      "  # 累積和を取得します。",
      "  #",
      "  # Range(y_begin, y_end), Range(x_begin, x_end) で指定します。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.get(0...h, j..j + 2) # => 28",
      "  # ```",
      "  def get(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  # 累積和を返します。",
      "  #",
      "  # [y_begin, y_end), [x_begin, x_end) で指定します。",
      "  #",
      "  # 範囲内に要素が存在しない場合 nil を返します。",
      "  #",
      "  # ```",
      "  # csum = DynamicRectangleSum.new(a)",
      "  # csum.get?(0...h, j..j + 2) # => 28",
      "  # csum.get?(0...100*h, j..j + 2) # => nil",
      "  # ```",
      "  def get?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    get?(y_begin, y_end, x_begin, x_end)",
      "  end",
      "",
      "  def [](y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T",
      "    get(y_range, x_range)",
      "  end",
      "",
      "  def []?(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?)) : T?",
      "    get?(y_range, x_range)",
      "  end",
      "",
      "  def []=(i : Int, j : Int, val : T)",
      "    add(i, j, val - get(i..i, j..j))",
      "  end",
      "",
      "  private def query(h : Int, w : Int) : T",
      "    acc = T.zero",
      "    i = h",
      "    while i > 0",
      "      j = w",
      "      while j > 0",
      "        acc += @csum[i][j]",
      "        j -= (j & -j)",
      "      end",
      "      i -= (i & -i)",
      "    end",
      "    acc",
      "  end",
      "end"
    ],
    "description": "DynamicRectangleSum"
  },
  "いもす法": {
    "prefix": "Imos",
    "body": [
      "class Imos(T)",
      "  include Enumerable(T)",
      "",
      "  getter size : Int32",
      "  @added : Array(T)",
      "  @sums : Array(T)",
      "  @should_build : Bool",
      "",
      "  def initialize()",
      "    @size = 0",
      "    @added = [] of T",
      "    @sums = [] of T",
      "    @should_build = true",
      "  end",
      "",
      "  def initialize(n : Int)",
      "    @size = n.to_i32",
      "    @added = Array.new(n + 2){ T.zero }",
      "    @sums = [] of T",
      "    @should_build = true",
      "  end",
      "",
      "  # [l, r) に val を加算します。",
      "  #",
      "  # NOTE: このAPIの使用は推奨されません。Rangeで指定してください。",
      "  def add(l : Int, r : Int, val : T) : T",
      "    @added[l] += val",
      "    @added[r] -= val",
      "    @should_build = true",
      "    val",
      "  end",
      "",
      "  # range の範囲に val を加算します。",
      "  #",
      "  # ```",
      "  # imos = Imos(Int32).new(n)",
      "  # imos.add(0..n, 10)",
      "  # ```",
      "  def add(range : Range(Int?, Int?), val : T) : T",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size + 1",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    add(left, right, val)",
      "  end",
      "",
      "  # 添字 i の値を取得します。",
      "  #",
      "  # ```",
      "  # imos = Imos(Int32).new(n)",
      "  # imos.add(0..n, 10)",
      "  # imos.add(0..n // 2, 10)",
      "  # imos.get(0) # => 20",
      "  # imos.get(n) # => 10",
      "  # ```",
      "  def get(i : Int) : T",
      "    build if @should_build",
      "    @sums[i]",
      "  end",
      "",
      "  # 添字 i の値を取得します。",
      "  #",
      "  # 配列が build 済みかの確認は行いません。",
      "  #",
      "  # ```",
      "  # imos = Imos(Int32).new(n)",
      "  # imos.add(0..n, 10)",
      "  # imos.add(0..n // 2, 10)",
      "  # imos.get(0) # => 20",
      "  # imos.get(n) # => 10",
      "  # ```",
      "  def get!(i : Int) : T",
      "    @sums[i]",
      "  end",
      "",
      "  # 添字 i の値を取得します。",
      "  #",
      "  # 配列外参照をした場合 nil が返ります。",
      "  #",
      "  # ```",
      "  # imos = Imos(Int32).new(n)",
      "  # imos.add(0..n, 10)",
      "  # imos.add(0..n // 2, 10)",
      "  # imos.get(0) # => 20",
      "  # imos.get(n) # => 10",
      "  # ```",
      "  def get?(i : Int) : T?",
      "    build if @should_build",
      "    @sums[i]?",
      "  end",
      "",
      "  def each(& : T -> )",
      "    build if @should_build",
      "    @sums.each { |s| yield s }",
      "  end",
      "",
      "  def [](i : Int) : T; get(i) end",
      "  def []?(i : Int) : T?; get?(i) end",
      "",
      "  def build",
      "    @sums = @added.dup",
      "    (@size + 1).times do |i|",
      "      @sums[i + 1] += @sums[i]",
      "    end",
      "    @sums.pop",
      "    @should_build = false",
      "  end",
      "end"
    ],
    "description": "Imos"
  },
  "二次元いもす法": {
    "prefix": "RectangleImos",
    "body": [
      "class RectangleImos(T)",
      "  getter height : Int32",
      "  getter width : Int32",
      "  @added : Array(Array(T))",
      "  @sums : Array(Array(T))",
      "  @should_build : Bool",
      "",
      "  def initialize()",
      "    @height = 0",
      "    @width = 0",
      "    @added = Array(Array(T)).new",
      "    @sums = Array(Array(T)).new",
      "    @should_build = true",
      "  end",
      "",
      "  def initialize(h : Int, w : Int)",
      "    @height = h.to_i32",
      "    @width = w.to_i32",
      "    @added = Array.new(h + 2){ Array.new(w + 2){ T.zero } }",
      "    @sums = Array(Array(T)).new",
      "    @should_build = true",
      "  end",
      "",
      "  # [y_begin, y_end), [x_begin, x_end) に val を加算します。",
      "  #",
      "  # NOTE: このAPIの使用は推奨されません。Rangeで指定してください。",
      "  def add(y_begin : Int, y_end : Int, x_begin : Int, x_end : Int, val : T = T.zero.succ) : T",
      "    @added[y_begin][x_begin] += val",
      "    @added[y_begin][x_end] -= val",
      "    @added[y_end][x_begin] -= val",
      "    @added[y_end][x_end] += val",
      "    @should_build = true",
      "    val",
      "  end",
      "",
      "  # range の範囲に val を加算します。",
      "  #",
      "  # ```",
      "  # imos = Imos(Int32).new(n)",
      "  # imos.add(0..n, 10)",
      "  # ```",
      "  def add(y_range : Range(Int?, Int?), x_range : Range(Int?, Int?), val : T = T.zero.succ) : T",
      "    y_begin = (y_range.begin || 0)",
      "    y_end = if y_range.end.nil?",
      "        @height + 1",
      "      else",
      "        y_range.end.not_nil! + (y_range.exclusive? ? 0 : 1)",
      "      end",
      "    x_begin = (x_range.begin || 0)",
      "    x_end = if x_range.end.nil?",
      "        @width + 1",
      "      else",
      "        x_range.end.not_nil! + (x_range.exclusive? ? 0 : 1)",
      "      end",
      "    add(y_begin, y_end, x_begin, x_end, val)",
      "  end",
      "",
      "  # 添字 (y, x) の値を取得します。",
      "  def get(y : Int, x : Int) : T",
      "    build if @should_build",
      "    @sums[y][x]",
      "  end",
      "",
      "  # 添字 (y, x) の値を取得します。",
      "  #",
      "  # build 済みであるかの確認は行いません。",
      "  def get!(y : Int, x : Int) : T",
      "    @sums[y][x]",
      "  end",
      "",
      "  # 添字 (y, x) の値を取得します。",
      "  #",
      "  # 配列外参照をした場合 nil が返ります。",
      "  def get?(y : Int, x : Int) : T?",
      "    build if @should_build",
      "    return nil if @sums.size >= y",
      "    @sums[y].not_nil![x]?",
      "  end",
      "",
      "  def [](y : Int, x : Int) : T; get(y, x) end",
      "  def []?(y : Int, x : Int) : T?; get?(y, x) end",
      "",
      "  def build",
      "    @sums = (0...@added.size).map{ |i| @added[i].dup }",
      "",
      "    (@height + 1).times do |i|",
      "      (1..@width).each do |j|",
      "        @sums[i][j] += @sums[i][j - 1]",
      "      end",
      "    end",
      "",
      "    (1..@height).each do |i|",
      "      (@width + 1).times do |j|",
      "        @sums[i][j] += @sums[i - 1][j]",
      "      end",
      "    end",
      "",
      "    @sums.pop",
      "    @sums.size.times{ |i| @sums[i].pop }",
      "",
      "    @should_build = false",
      "  end",
      "end"
    ],
    "description": "RectangleImos"
  },
  "素集合データ構造": {
    "prefix": "DisjointSet",
    "body": [
      "class DisjointSet",
      "  @n : Int32",
      "  @parent_or_size : Array(Int32)",
      "",
      "  def initialize",
      "    @n = 0",
      "    @parent_or_size = Array(Int32).new",
      "  end",
      "",
      "  def initialize(size : Int)",
      "    @n = size.to_i32",
      "    @parent_or_size = [-1] * size",
      "  end",
      "",
      "  def unite(a : Int, b : Int) : Int32",
      "    x = leader(a)",
      "    y = leader(b)",
      "    return x if x == y",
      "    if -@parent_or_size[x] < -@parent_or_size[y]",
      "      x, y = y, x",
      "    end",
      "    @parent_or_size[x] += @parent_or_size[y]",
      "    @parent_or_size[y] = x",
      "    x",
      "  end",
      "",
      "  def equiv?(a : Int, b : Int) : Bool",
      "    leader(a) == leader(b)",
      "  end",
      "",
      "  def leader(a : Int) : Int32",
      "    return a.to_i32 if @parent_or_size[a] < 0",
      "    @parent_or_size[a] = leader(@parent_or_size[a])",
      "    @parent_or_size[a]",
      "  end",
      "",
      "  def size(a : Int) : Int32",
      "    -@parent_or_size[leader(a)]",
      "  end",
      "",
      "  def groups : Array(Array(Int32)) | Nil",
      "    leader_buf = [0] * @n",
      "    group_size = [0] * @n",
      "    @n.times do |i|",
      "      leader_buf[i] = leader(i)",
      "      group_size[leader_buf[i]] += 1",
      "    end",
      "    res = Array.new(@n){ [] of Int32 }",
      "    @n.times do |i|",
      "      res[leader_buf[i]] << i",
      "    end",
      "    res.delete([] of Int32)",
      "    res",
      "  end",
      "end"
    ],
    "description": "DisjointSet"
  },
  "ポテンシャル付きDSU": {
    "prefix": "PotentializedDisjointSet",
    "body": [
      "class PotentializedDisjointSet(Abel)",
      "  @n : Int32",
      "  @parent_or_size : Array(Int32)",
      "  @potentials : Array(Abel)",
      "",
      "  # 0 頂点 0 辺の無向グラフを作ります。",
      "  #",
      "  # ```",
      "  # ut = PotentializedDisjointSet(Abel).new",
      "  # ```",
      "  def initialize",
      "    @n = 0",
      "    @parent_or_size = Array(Int32).new",
      "    @potentials = Array(Abel).new",
      "  end",
      "",
      "  # n 頂点 0 辺の無向グラフを作ります。",
      "  #",
      "  # ```",
      "  # n = int",
      "  # ut = PotentializedDisjointSet(Abel).new(n)",
      "  # ```",
      "  def initialize(size : Int)",
      "    @n = size.to_i32",
      "    @parent_or_size = [-1] * size",
      "    @potentials = Array.new(size){ Abel.zero }",
      "  end",
      "",
      "  # w[high] - w[low] = diff となるように、",
      "  # 頂点 low と頂点 high を接続します。",
      "  #",
      "  # （w[low] + diff = w[high] と捉えても良いです。） ",
      "  #",
      "  # 接続後のリーダーを返します。",
      "  #",
      "  # diff は符号付きであることに注意してください。",
      "  # また、low と high がすでに接続されている場合の動作は未定義です。",
      "  #",
      "  # ```",
      "  # n = int",
      "  # ut = PotentializedDisjointSet(Abel).new(n)",
      "  # ut.unite(low: a, high: b, diff: w) # => leader(a) or leader(b)",
      "  # ```",
      "  def unite(low : Int, high : Int, diff : Abel) : Int64",
      "    diff += weight(low) - weight(high)",
      "    x = leader(low)",
      "    y = leader(high)",
      "    return x.to_i64 if x == y",
      "    if -@parent_or_size[x] < -@parent_or_size[y]",
      "      x, y = y, x",
      "      diff = -diff",
      "    end",
      "    @parent_or_size[x] += @parent_or_size[y]",
      "    @parent_or_size[y] = x.to_i32",
      "    @potentials[y] = diff",
      "    x.to_i64",
      "  end",
      "",
      "  # 頂点 a と頂点 b が同じ連結成分に属しているなら `true` を返します。",
      "  #",
      "  # ```",
      "  # n = int",
      "  # ut = PotentializedDisjointSet(Abel).new(n)",
      "  # ut.equiv?(u, v) # => true",
      "  # ```",
      "  def equiv?(a : Int, b : Int) : Bool",
      "    leader(a) == leader(b)",
      "  end",
      "",
      "  # 頂点 a の属する連結成分のリーダーを返します。",
      "  #",
      "  # ```",
      "  # n = int",
      "  # ut = PotentializedDisjointSet(Abel).new(n)",
      "  # ut.unite(2, 3, 0)",
      "  # ut.leader(0) # => 0",
      "  # ut.leader(3) # => 2  (3 の可能性もある)",
      "  # ```",
      "  def leader(a : Int) : Int64",
      "    return a.to_i64 if @parent_or_size[a] < 0",
      "    l = leader(@parent_or_size[a]).to_i32",
      "    @potentials[a] += @potentials[@parent_or_size[a]]",
      "    @parent_or_size[a] = l",
      "    @parent_or_size[a].to_i64",
      "  end",
      "",
      "  # w[high] - w[low] を返します。",
      "  #",
      "  # low と high が同じ連結成分に属していない場合 Abel.zero を返します。",
      "  #",
      "  # ```",
      "  # ut = PotentializedDisjointSet(Abel).new(size: 10)",
      "  # ut.unite(2, 1, 1)",
      "  # ut.unite(2, 3, 5)",
      "  # ut.unite(3, 4, 2)",
      "  # ut.diff(1, 2) # => -1",
      "  # ut.diff(2, 1) # => 1",
      "  # ut.diff(2, 3) # => 5",
      "  # ut.diff(2, 4) # => 7",
      "  # ut.diff(0, 9) # => Abel.zero",
      "  # ```",
      "  def diff(low : Int, high : Int) : Abel",
      "    weight(high) - weight(low)",
      "  end",
      "",
      "  # w[high] - w[low] を返します。",
      "  #",
      "  # low と high が同じ連結成分に属していない場合 nil を返します。",
      "  #",
      "  # ```",
      "  # ut = PotentializedDisjointSet(Abel).new(size: 10)",
      "  # ut.unite(2, 1, 1)",
      "  # ut.unite(2, 3, 5)",
      "  # ut.unite(3, 4, 2)",
      "  # ut.diff(1, 2) # => -1",
      "  # ut.diff(2, 1) # => 1",
      "  # ut.diff(2, 3) # => 5",
      "  # ut.diff(2, 4) # => 7",
      "  # ut.diff(0, 9) # => nil",
      "  # ```",
      "  def diff?(low : Int, high : Int) : Abel?",
      "    return nil unless equiv?(low, high)",
      "    weight(high) - weight(low)",
      "  end",
      "",
      "  # 頂点 a が属する連結成分の大きさを返します。",
      "  def size(a : Int) : Int64",
      "    -@parent_or_size[leader(a)].to_i64",
      "  end",
      "",
      "  # グラフを連結成分に分け、その情報を返します。",
      "  #",
      "  # 返り値は「「一つの連結成分の頂点番号のリスト」のリスト」です。",
      "  # （内側外側限らず）Array 内でどの順番で頂点が格納されているかは未定義です。",
      "  def groups : Array(Array(Int64)) | Nil",
      "    leader_buf = Array(Int64).new(@n, 0_i64)",
      "    group_size = Array(Int64).new(@n, 0_i64)",
      "    @n.times do |i|",
      "      leader_buf[i] = leader(i)",
      "      group_size[leader_buf[i]] += 1",
      "    end",
      "    res = Array.new(@n){ Array(Int64).new() }",
      "    @n.times do |i|",
      "      res[leader_buf[i]] << i.to_i64",
      "    end",
      "    res.delete([] of Int64)",
      "    res",
      "  end",
      "",
      "  private def weight(a : Int) : Abel",
      "    leader(a)",
      "    @potentials[a]",
      "  end",
      "end"
    ],
    "description": "PotentializedDisjointSet"
  },
  "中央値取り出しキュー": {
    "prefix": "MedQueue",
    "body": [
      "# require \"Heap\"",
      "# return que[m // 2]",
      "class MedianQueue(T)",
      "  @lesser : Heap(T)",
      "  @greater : Heap(T)",
      "",
      "  def initialize",
      "    @lesser = Heap(T).max",
      "    @greater = Heap(T).min",
      "  end",
      "",
      "  def initialize(array : Array(T))",
      "    @lesser = Heap(T).max",
      "    @greater = Heap(T).min",
      "    array.each { |a| push(a) }",
      "  end",
      "",
      "  def push(x : T)",
      "    if @lesser.empty? && @greater.empty?",
      "      @greater << x",
      "    elsif @lesser.size == @greater.size",
      "      top = @lesser.peek",
      "      if x < top",
      "        @lesser << x",
      "        x = @lesser.pop # => top",
      "      end",
      "      @greater << x",
      "    else",
      "      top = @greater.peek",
      "      if x > top",
      "        @greater << x",
      "        x = @greater.pop # => top",
      "      end",
      "      @lesser << x",
      "    end",
      "  end",
      "",
      "  def <<(x : T)",
      "    push(x)",
      "  end",
      "",
      "  def pop : T",
      "    med = @greater.pop",
      "    if @lesser.size > @greater.size",
      "      @greater << @lesser.pop",
      "    end",
      "    med",
      "  end",
      "",
      "  def peek : T",
      "    @greater.peek",
      "  end",
      "end",
      ""
    ],
    "description": "MedQueue"
  },
  "順序付き集合": {
    "prefix": "AATreeSet",
    "body": [
      "class AATreeSet(T)",
      "  include Enumerable(T)",
      " ",
      "  private class Node(T)",
      "    property left : Node(T)?",
      "    property right : Node(T)?",
      "    property parent : Node(T)?",
      "    property key : T",
      "    property level : Int32",
      "    property size : Int32",
      " ",
      "    def initialize(val : T)",
      "      @left = @right = @parent = nil",
      "      @level = 1",
      "      @key = val",
      "      @size = 1",
      "    end",
      " ",
      "    def rotate_left : Node(T)",
      "      right = @right.not_nil!",
      "      mid = right.left",
      "      par = @parent",
      "      if right.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = right",
      "        else",
      "          par.not_nil!.right = right",
      "        end",
      "      end",
      "      mid.parent = self if @right = mid",
      "      right.left = self",
      "      @parent = right",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - right.size",
      "      right.size = sz",
      " ",
      "      right",
      "    end",
      " ",
      "    def rotate_right : Node(T)",
      "      left = @left.not_nil!",
      "      mid = left.right",
      "      par = @parent",
      " ",
      "      if left.not_nil!.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = left",
      "        else",
      "          par.not_nil!.right = left",
      "        end",
      "      end",
      "      mid.parent = self if @left = mid",
      "      left.not_nil!.right = self",
      "      @parent = left",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - left.size",
      "      left.size = sz",
      " ",
      "      left",
      "    end",
      " ",
      "    def left_side?(node : Node(T)?) : Bool",
      "      @left == node",
      "    end",
      " ",
      "    def assign(node : Node(T)) : T",
      "      @key = node.key",
      "    end",
      "  end",
      " ",
      "  @root : Node(T)?",
      " ",
      "  private def find_node(node : Node(T)?, val : T) : Node(T)?",
      "    return nil unless node",
      "    until val == node.not_nil!.key",
      "      if val < node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    node",
      "  end",
      "",
      "  private def skew(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    left = node.not_nil!.left",
      "    if left && node.not_nil!.level == left.not_nil!.level",
      "      return node.not_nil!.rotate_right",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def split(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    right = node.right",
      "    if right && right.not_nil!.right && node.level == right.not_nil!.right.not_nil!.level",
      "      r = node.rotate_left",
      "      r.level += 1",
      "      return r",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def begin_node : Node(T)?",
      "    return nil unless @root",
      "    node = @root",
      "    while node.not_nil!.left",
      "      node = node.not_nil!.left",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def next_node(node : Node(T)) : Node(T)?",
      "    if node.right",
      "      node = node.right",
      "      while node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      end",
      "      node",
      "    else",
      "      while node",
      "        par = node.not_nil!.parent",
      "        if par && par.not_nil!.left_side?(node)",
      "          return par",
      "        end",
      "        node = par",
      "      end",
      "      node",
      "    end",
      "  end",
      " ",
      "  private def level(node : Node(T)?)",
      "    node ? node.level : 0",
      "  end",
      " ",
      "  def initialize",
      "    @root = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(enumerable : Enumerable(T))",
      "    @root = nil",
      "    concat(enumerable)",
      "    self",
      "  end",
      " ",
      "  def concat(elems) : self",
      "    elems.each { |elem| self << elem }",
      "    self",
      "  end",
      " ",
      "  def includes?(val : T) : Bool",
      "    node = find_node(@root, val)",
      "    node.nil? ? false : node.key == val",
      "  end",
      " ",
      "  def clear",
      "    @root = nil",
      "  end",
      " ",
      "  def empty? : Bool",
      "    @root.nil?",
      "  end",
      " ",
      "  def at(k : Int) : T",
      "    raise IndexError.new unless 0 <= k && k < size",
      "    node = @root",
      "    k += 1",
      "    loop do",
      "      left_size = (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "      break if left_size == k",
      " ",
      "      if k < left_size",
      "        node = node.not_nil!.left",
      "      else",
      "        node = node.not_nil!.right",
      "        k -= left_size",
      "      end",
      "    end",
      "    node.not_nil!.key",
      "  end",
      " ",
      "  def at?(k : Int) : T?",
      "    return nil unless 0 <= k && k < size",
      "    at(k)",
      "  end",
      " ",
      "  def each(& : T ->)",
      "    node = begin_node",
      "    while node",
      "      yield node.not_nil!.key",
      "      node = next_node(node.not_nil!)",
      "    end",
      "  end",
      "",
      "  def add(val : T) : Nil",
      "    add?(val)",
      "    nil",
      "  end",
      " ",
      "  def add?(val : T) : Bool",
      "    unless @root",
      "      @root = Node.new(val)",
      "      return true",
      "    end",
      " ",
      "    node = find_node(@root, val)",
      "    return false if node.not_nil!.key == val # NOT multi",
      "",
      "    new_node = Node.new(val)",
      "    if val <= node.not_nil!.key",
      "      node.not_nil!.left = new_node",
      "    else",
      "      node.not_nil!.right = new_node",
      "    end",
      "    new_node.not_nil!.parent = node",
      " ",
      "    node = new_node",
      "    while node",
      "      node = split(skew(node))",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "      node.not_nil!.size += 1",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete(val : T) : Bool",
      "    return false unless @root",
      " ",
      "    node = find_node(@root, val)",
      "    return false unless node.not_nil!.key == val",
      " ",
      "    if node.not_nil!.left || node.not_nil!.right",
      "      child = find_node(node.not_nil!.left ? node.not_nil!.left : node.not_nil!.right, val)",
      "      node.not_nil!.assign(child.not_nil!)",
      "      node = child",
      "    end",
      " ",
      "    par = node.not_nil!.parent",
      "    if par",
      "      if par.not_nil!.left_side?(node)",
      "        par.left = nil",
      "      else",
      "        par.right = nil",
      "      end",
      "    else",
      "      @root = nil",
      "    end",
      "    node = par",
      " ",
      "    while node",
      "      new_level = { level(node.left), level(node.right) }.min + 1",
      "      if new_level < node.level",
      "        node.level = new_level",
      "        if new_level < level(node.right)",
      "          node.right.not_nil!.level = new_level",
      "        end",
      "      end",
      " ",
      "      node.size -= 1",
      "      node = skew(node).not_nil!",
      "      skew(node.right.not_nil!.right) if skew(node.right)",
      " ",
      "      node = split(node)",
      "      split(node.not_nil!.right)",
      " ",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete_at(k : Int) : Bool",
      "    delete(at(k))",
      "  end",
      " ",
      "  def delete_at?(k : Int) : Bool",
      "    val = at?(k)",
      "    if val",
      "      delete(val)",
      "    else",
      "      return false",
      "    end",
      "  end",
      " ",
      "  def lower_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val <= node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      " ",
      "  def upper_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val < node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      "",
      "  def less_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == 0 ? nil : index - 1",
      "  end",
      "",
      "  def less_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    val == at?(index) ? index : (index == 0 ? nil : index - 1)",
      "  end",
      "",
      "  def greater_index(val : T) : Int32?",
      "    index = upper_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def greater_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def first : T; at(0) end",
      "  def first? : T?; at?(0) end",
      "  def last : T; at(size - 1) end",
      "  def last? : T?; at?(size - 1) end",
      " ",
      "  def count(val : T) : Int32",
      "    upper_bound_index(val) - lower_bound_index(val)",
      "  end",
      " ",
      "  def size : Int32",
      "    @root ? @root.not_nil!.size : 0",
      "  end",
      " ",
      "  def to_a : Array(T)",
      "    res = Array(T).new",
      "    return res unless @root",
      "    dfs = uninitialized Node(T) -> Nil",
      "    dfs = ->(node : Node(T)) do",
      "      dfs.call(node.left.not_nil!) if node.left",
      "      res << node.key",
      "      dfs.call(node.right.not_nil!) if node.right",
      "      nil",
      "    end",
      "    dfs.call(@root.not_nil!)",
      "    res",
      "  end",
      " ",
      "  def to_s(io : IO) : Nil",
      "    io << \"{\" + to_a.join(\", \") + \"}\"",
      "  end",
      "",
      "  def inspect(io : IO) : Nil",
      "    to_s(io)",
      "  end",
      "",
      "  def ==(other : AATreeSet(T)) : Bool; self.to_a == other.to_a end",
      "  def <<(val : T) : Bool; add?(val) end",
      "  def [](k : Int) : T; at(k) end",
      "  def []?(k : Int) : T | Nil; at?(k) end",
      "end"
    ],
    "description": "AATreeSet"
  },
  "順序付き重複集合": {
    "prefix": "AATreeMultiset",
    "body": [
      "class AATreeMultiset(T)",
      "  include Enumerable(T)",
      " ",
      "  private class Node(T)",
      "    property left : Node(T)?",
      "    property right : Node(T)?",
      "    property parent : Node(T)?",
      "    property key : T",
      "    property level : Int32",
      "    property size : Int32",
      " ",
      "    def initialize(val : T)",
      "      @left = @right = @parent = nil",
      "      @level = 1",
      "      @key = val",
      "      @size = 1",
      "    end",
      " ",
      "    def rotate_left : Node(T)",
      "      right = @right.not_nil!",
      "      mid = right.left",
      "      par = @parent",
      "      if right.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = right",
      "        else",
      "          par.not_nil!.right = right",
      "        end",
      "      end",
      "      mid.parent = self if @right = mid",
      "      right.left = self",
      "      @parent = right",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - right.size",
      "      right.size = sz",
      " ",
      "      right",
      "    end",
      " ",
      "    def rotate_right : Node(T)",
      "      left = @left.not_nil!",
      "      mid = left.right",
      "      par = @parent",
      " ",
      "      if left.not_nil!.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = left",
      "        else",
      "          par.not_nil!.right = left",
      "        end",
      "      end",
      "      mid.parent = self if @left = mid",
      "      left.not_nil!.right = self",
      "      @parent = left",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - left.size",
      "      left.size = sz",
      " ",
      "      left",
      "    end",
      " ",
      "    def left_side?(node : Node(T)?) : Bool",
      "      @left == node",
      "    end",
      " ",
      "    def assign(node : Node(T)) : T",
      "      @key = node.key",
      "    end",
      "  end",
      " ",
      "  @root : Node(T)?",
      " ",
      "  private def find_node(node : Node(T)?, val : T) : Node(T)?",
      "    return nil unless node",
      "    until val == node.not_nil!.key",
      "      if val < node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "",
      "    while node.not_nil!.left && node.not_nil!.left.not_nil!.key == val",
      "      node = node.not_nil!.left",
      "    end",
      "    while node.not_nil!.right && node.not_nil!.right.not_nil!.key == val",
      "      node = node.not_nil!.right",
      "    end",
      "",
      "    node",
      "  end",
      " ",
      "  private def find_node2(node : Node(T)?, val : T) : Node(T)?",
      "    return nil unless node",
      "    loop do",
      "      if val <= node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      " ",
      "    node",
      "  end",
      " ",
      "  private def skew(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    left = node.not_nil!.left",
      "    if left && node.not_nil!.level == left.not_nil!.level",
      "      return node.not_nil!.rotate_right",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def split(node : Node(T)?) : Node(T)?",
      "    return nil unless node",
      "    right = node.right",
      "    if right && right.not_nil!.right && node.level == right.not_nil!.right.not_nil!.level",
      "      r = node.rotate_left",
      "      r.level += 1",
      "      return r",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def begin_node : Node(T)?",
      "    return nil unless @root",
      "    node = @root",
      "    while node.not_nil!.left",
      "      node = node.not_nil!.left",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def next_node(node : Node(T)) : Node(T)?",
      "    if node.right",
      "      node = node.right",
      "      while node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      end",
      "      node",
      "    else",
      "      while node",
      "        par = node.not_nil!.parent",
      "        if par && par.not_nil!.left_side?(node)",
      "          return par",
      "        end",
      "        node = par",
      "      end",
      "      node",
      "    end",
      "  end",
      " ",
      "  private def level(node : Node(T)?)",
      "    node ? node.level : 0",
      "  end",
      " ",
      "  def initialize",
      "    @root = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(enumerable : Enumerable(T))",
      "    @root = nil",
      "    concat(enumerable)",
      "    self",
      "  end",
      " ",
      "  def concat(elems) : self",
      "    elems.each { |elem| self << elem }",
      "    self",
      "  end",
      " ",
      "  def includes?(val : T) : Bool",
      "    node = find_node(@root, val)",
      "    node.nil? ? false : node.key == val",
      "  end",
      " ",
      "  def clear",
      "    @root = nil",
      "  end",
      " ",
      "  def empty? : Bool",
      "    @root.nil?",
      "  end",
      " ",
      "  def at(k : Int) : T",
      "    raise IndexError.new unless 0 <= k && k < size",
      "    node = @root",
      "    k += 1",
      "    loop do",
      "      left_size = (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "      break if left_size == k",
      " ",
      "      if k < left_size",
      "        node = node.not_nil!.left",
      "      else",
      "        node = node.not_nil!.right",
      "        k -= left_size",
      "      end",
      "    end",
      "    node.not_nil!.key",
      "  end",
      " ",
      "  def at?(k : Int) : T?",
      "    return nil unless 0 <= k && k < size",
      "    at(k)",
      "  end",
      " ",
      "  def each(& : T ->)",
      "    node = begin_node",
      "    while node",
      "      yield node.not_nil!.key",
      "      node = next_node(node.not_nil!)",
      "    end",
      "  end",
      "",
      "  def add(val : T) : Nil",
      "    add?(val)",
      "    nil",
      "  end",
      " ",
      "  def add?(val : T) : Bool",
      "    unless @root",
      "      @root = Node.new(val)",
      "      return true",
      "    end",
      " ",
      "    node = find_node2(@root, val)",
      " ",
      "    new_node = Node.new(val)",
      "    if val <= node.not_nil!.key",
      "      node.not_nil!.left = new_node",
      "    else",
      "      node.not_nil!.right = new_node",
      "    end",
      "    new_node.not_nil!.parent = node",
      " ",
      "    node = new_node",
      "    while node",
      "      node = split(skew(node))",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "      node.not_nil!.size += 1",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete(val : T) : Bool",
      "    return false unless @root",
      " ",
      "    node = find_node(@root, val)",
      "    return false unless node.not_nil!.key == val",
      " ",
      "    if node.not_nil!.left || node.not_nil!.right",
      "      child = find_node(node.not_nil!.left ? node.not_nil!.left : node.not_nil!.right, val)",
      "      node.not_nil!.assign(child.not_nil!)",
      "      node = child",
      "    end",
      " ",
      "    par = node.not_nil!.parent",
      "    if par",
      "      if par.not_nil!.left_side?(node)",
      "        par.left = nil",
      "      else",
      "        par.right = nil",
      "      end",
      "    else",
      "      @root = nil",
      "    end",
      "    node = par",
      " ",
      "    while node",
      "      new_level = { level(node.left), level(node.right) }.min + 1",
      "      if new_level < node.level",
      "        node.level = new_level",
      "        if new_level < level(node.right)",
      "          node.right.not_nil!.level = new_level",
      "        end",
      "      end",
      " ",
      "      node.size -= 1",
      "      node = skew(node).not_nil!",
      "      skew(node.right.not_nil!.right) if skew(node.right)",
      " ",
      "      node = split(node)",
      "      split(node.not_nil!.right)",
      " ",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "    end",
      "    true",
      "  end",
      " ",
      "  def delete_at(k : Int) : Bool",
      "    delete(at(k))",
      "  end",
      " ",
      "  def delete_at?(k : Int) : Bool",
      "    val = at?(k)",
      "    if val",
      "      delete(val)",
      "    else",
      "      return false",
      "    end",
      "  end",
      " ",
      "  def lower_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val <= node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      " ",
      "  def upper_bound_index(val : T) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if val < node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      "",
      "  def less_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == 0 ? nil : index - 1",
      "  end",
      "  ",
      "  def less_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    val == at?(index) ? index : (index == 0 ? nil : index - 1)",
      "  end",
      "  ",
      "  def greater_index(val : T) : Int32?",
      "    index = upper_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "  ",
      "  def greater_equal_index(val : T) : Int32?",
      "    index = lower_bound_index(val)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def first : T; at(0) end",
      "  def first? : T?; at?(0) end",
      "  def last : T; at(size - 1) end",
      "  def last? : T?; at?(size - 1) end",
      " ",
      "  def count(val : T) : Int32",
      "    upper_bound_index(val) - lower_bound_index(val)",
      "  end",
      " ",
      "  def size : Int32",
      "    @root ? @root.not_nil!.size : 0",
      "  end",
      " ",
      "  def to_a : Array(T)",
      "    res = Array(T).new",
      "    return res unless @root",
      "    dfs = uninitialized Node(T) -> Nil",
      "    dfs = ->(node : Node(T)) do",
      "      dfs.call(node.left.not_nil!) if node.left",
      "      res << node.key",
      "      dfs.call(node.right.not_nil!) if node.right",
      "      nil",
      "    end",
      "    dfs.call(@root.not_nil!)",
      "    res",
      "  end",
      " ",
      "  def to_s(io : IO) : Nil",
      "    io << \"{\" + to_a.join(\", \") + \"}\"",
      "  end",
      "",
      "  def inspect(io : IO) : Nil",
      "    to_s(io)",
      "  end",
      "",
      "  def ==(other : AATreeSet(T)) : Bool; self.to_a == other.to_a end",
      "  def <<(val : T) : Bool; add?(val) end",
      "  def [](k : Int) : T; at(k) end",
      "  def []?(k : Int) : T | Nil; at?(k) end",
      "end"
    ],
    "description": "AATreeMultiset"
  },
  "順序付き連想配列": {
    "prefix": "AATreeMap",
    "body": [
      "class AATreeMap(K, V)",
      "  include Enumerable({K, V})",
      " ",
      "  private class Node(K, V)",
      "    property left : Node(K, V)?",
      "    property right : Node(K, V)?",
      "    property parent : Node(K, V)?",
      "    property key : K",
      "    property value : V",
      "    property level : Int32",
      "    property size : Int32",
      " ",
      "    def initialize(item : {K, V})",
      "      @left = @right = @parent = nil",
      "      @level = 1",
      "      @key = item[0]",
      "      @value = item[1]",
      "      @size = 1",
      "    end",
      " ",
      "    def rotate_left : Node(K, V)",
      "      right = @right.not_nil!",
      "      mid = right.left",
      "      par = @parent",
      "      if right.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = right",
      "        else",
      "          par.not_nil!.right = right",
      "        end",
      "      end",
      "      mid.parent = self if @right = mid",
      "      right.left = self",
      "      @parent = right",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - right.size",
      "      right.size = sz",
      " ",
      "      right",
      "    end",
      " ",
      "    def rotate_right : Node(K, V)",
      "      left = @left.not_nil!",
      "      mid = left.right",
      "      par = @parent",
      " ",
      "      if left.not_nil!.parent = par",
      "        if par.not_nil!.left == self",
      "          par.not_nil!.left = left",
      "        else",
      "          par.not_nil!.right = left",
      "        end",
      "      end",
      "      mid.parent = self if @left = mid",
      "      left.not_nil!.right = self",
      "      @parent = left",
      " ",
      "      sz = @size",
      "      @size += (mid ? mid.size : 0) - left.size",
      "      left.size = sz",
      " ",
      "      left",
      "    end",
      " ",
      "    def left_side?(node : Node(K, V)?) : Bool",
      "      @left == node",
      "    end",
      " ",
      "    def assign(node : Node(K, V)) : V",
      "      @key = node.key",
      "      @value = node.value",
      "    end",
      "  end",
      " ",
      "  @root : Node(K, V)?",
      "  @default : V?",
      " ",
      "  private def find_node(node : Node(K, V)?, key : K) : Node(K, V)?",
      "    return nil unless node",
      "    until key == node.not_nil!.key",
      "      if key < node.not_nil!.key",
      "        break unless node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      else",
      "        break unless node.not_nil!.right",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    node",
      "  end",
      "",
      "  private def skew(node : Node(K, V)?) : Node(K, V)?",
      "    return nil unless node",
      "    left = node.not_nil!.left",
      "    if left && node.not_nil!.level == left.not_nil!.level",
      "      return node.not_nil!.rotate_right",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def split(node : Node(K, V)?) : Node(K, V)?",
      "    return nil unless node",
      "    right = node.right",
      "    if right && right.not_nil!.right && node.level == right.not_nil!.right.not_nil!.level",
      "      r = node.rotate_left",
      "      r.level += 1",
      "      return r",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def upsert(key : K, value : V) : Nil",
      "    unless @root",
      "      @root = Node.new({key, value})",
      "      return true",
      "    end",
      " ",
      "    node = find_node(@root, key)",
      "    if node.not_nil!.key == key",
      "      node.not_nil!.value = value",
      "      return",
      "    end",
      " ",
      "    new_node = Node.new({key, value})",
      "    if key < node.not_nil!.key",
      "      node.not_nil!.left = new_node",
      "    else",
      "      node.not_nil!.right = new_node",
      "    end",
      "    new_node.not_nil!.parent = node",
      " ",
      "    node = new_node",
      "    while node",
      "      node = split(skew(node))",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "      node.not_nil!.size += 1",
      "    end",
      "  end",
      " ",
      "  private def begin_node : Node(K, V)?",
      "    return nil unless @root",
      "    node = @root",
      "    while node.not_nil!.left",
      "      node = node.not_nil!.left",
      "    end",
      "    node",
      "  end",
      " ",
      "  private def next_node(node : Node(K, V)) : Node(K, V)?",
      "    if node.right",
      "      node = node.right",
      "      while node.not_nil!.left",
      "        node = node.not_nil!.left",
      "      end",
      "      node",
      "    else",
      "      while node",
      "        par = node.not_nil!.parent",
      "        if par && par.not_nil!.left_side?(node)",
      "          return par",
      "        end",
      "        node = par",
      "      end",
      "      node",
      "    end",
      "  end",
      " ",
      "  private def level(node : Node(K, V)?)",
      "    node ? node.level : 0",
      "  end",
      " ",
      "  def initialize",
      "    @root = nil",
      "    @default = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(@default : V)",
      "    @root = nil",
      "    self",
      "  end",
      " ",
      "  def initialize(enumerable : Enumerable({ K, V }))",
      "    @root = nil",
      "    concat(enumerable)",
      "    self",
      "  end",
      " ",
      "  def concat(elems) : self",
      "    elems.each { |elem| self << elem }",
      "    self",
      "  end",
      " ",
      "  def includes?(key : K, value : V) : Bool",
      "    node = find_node(@root, key)",
      "    node.nil? ? false : node.key == key && node.value == value",
      "  end",
      " ",
      "  def clear",
      "    @root = nil",
      "  end",
      " ",
      "  def empty? : Bool",
      "    @root.nil?",
      "  end",
      " ",
      "  def at(k : Int) : {K, V}",
      "    k += size if k < 0",
      "    raise IndexError.new unless 0 <= k && k < size",
      "    node = @root",
      "    k += 1",
      "    loop do",
      "      left_size = (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "      break if left_size == k",
      " ",
      "      if k < left_size",
      "        node = node.not_nil!.left",
      "      else",
      "        node = node.not_nil!.right",
      "        k -= left_size",
      "      end",
      "    end",
      "    {node.not_nil!.key, node.not_nil!.value}",
      "  end",
      " ",
      "  def at?(k : Int) : {K, V}?",
      "    k += size if k < 0",
      "    return nil unless 0 <= k && k < size",
      "    at(k)",
      "  end",
      " ",
      "  def key_at(k : Int) : K; at(k)[0] end",
      "  def key_at?(k : Int) : K?; t = at?(k); t ? t[0] : nil end",
      "  def value_at(k : Int) : V; at(k)[1] end",
      "  def value_at?(k : Int) : V?; t = at?(k); t ? t[1] : nil end",
      " ",
      "  def each_key(& : K ->)",
      "    each do |key, _|",
      "      yield key",
      "    end",
      "  end",
      " ",
      "  def each_value(& : V ->)",
      "    each do |_, value|",
      "      yield value",
      "    end",
      "  end",
      " ",
      "  def each(& : {K, V} ->)",
      "    node = begin_node",
      "    while node",
      "      pr = {node.not_nil!.key, node.not_nil!.value}",
      "      yield pr",
      "      node = next_node(node.not_nil!)",
      "    end",
      "  end",
      " ",
      "  def keys : Array(K)",
      "    res = Array(K).new",
      "    each do |key, _|",
      "      res << key",
      "    end",
      "    res",
      "  end",
      " ",
      "  def values : Array(V)",
      "    res = Array(V).new",
      "    each do |_, value|",
      "      res << value",
      "    end",
      "    res",
      "  end",
      " ",
      "  def delete_key(key : K) : Bool",
      "    return false unless @root",
      " ",
      "    node = find_node(@root, key)",
      "    return false unless node.not_nil!.key == key",
      " ",
      "    if node.not_nil!.left || node.not_nil!.right",
      "      child = find_node(node.not_nil!.left ? node.not_nil!.left : node.not_nil!.right, key)",
      "      node.not_nil!.assign(child.not_nil!)",
      "      node = child",
      "    end",
      " ",
      "    par = node.not_nil!.parent",
      "    if par",
      "      if par.not_nil!.left_side?(node)",
      "        par.left = nil",
      "      else",
      "        par.right = nil",
      "      end",
      "    else",
      "      @root = nil",
      "    end",
      "    node = par",
      " ",
      "    while node",
      "      new_level = { level(node.left), level(node.right) }.min + 1",
      "      if new_level < node.level",
      "        node.level = new_level",
      "        if new_level < level(node.right)",
      "          node.right.not_nil!.level = new_level",
      "        end",
      "      end",
      " ",
      "      node.size -= 1",
      "      node = skew(node).not_nil!",
      "      skew(node.right.not_nil!.right) if skew(node.right)",
      " ",
      "      node = split(node)",
      "      split(node.not_nil!.right)",
      " ",
      "      unless node.not_nil!.parent",
      "        @root = node",
      "        break",
      "      end",
      "      node = node.not_nil!.parent",
      "    end",
      "    true",
      "  end",
      " ",
      "  # TODO: Improve performance",
      "  def delete_at(k : Int)",
      "    key = key_at(k)",
      "    delete_key(key)",
      "  end",
      " ",
      "  # TODO: Improve performance",
      "  def delete_at(k : Int)",
      "    key = key_at?(k)",
      "    return if key.nil?",
      "    delete_key(key)",
      "  end",
      " ",
      "  def has_key?(key : K) : Bool",
      "    return false unless @root",
      "    node = find_node(@root, key)",
      "    node.nil? ? false : node.key == key",
      "  end",
      " ",
      "  def lower_bound_index(key : K) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if key <= node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      " ",
      "  def upper_bound_index(key : K) : Int32",
      "    node = @root",
      "    return 0 unless node",
      "    index = 0",
      "    while node",
      "      if key < node.not_nil!.key",
      "        node = node.not_nil!.left",
      "      else",
      "        index += (node.not_nil!.left ? node.not_nil!.left.not_nil!.size : 0) + 1",
      "        node = node.not_nil!.right",
      "      end",
      "    end",
      "    index",
      "  end",
      "",
      "  def less_index(key : K) : Int32?",
      "    index = lower_bound_index(key)",
      "    index == 0 ? nil : index - 1",
      "  end",
      "  ",
      "  def less_equal_index(key : K) : Int32?",
      "    index = lower_bound_index(key)",
      "    key == at?(index) ? index : (index == 0 ? nil : index - 1)",
      "  end",
      "  ",
      "  def greater_index(key : K) : Int32?",
      "    index = upper_bound_index(key)",
      "    index == size ? nil : index",
      "  end",
      "  ",
      "  def greater_equal_index(key : K) : Int32?",
      "    index = lower_bound_index(key)",
      "    index == size ? nil : index",
      "  end",
      "",
      "  def size : Int32",
      "    @root ? @root.not_nil!.size : 0",
      "  end",
      " ",
      "  def to_a : Array({K, V})",
      "    res = Array({K, V}).new",
      "    return res unless @root",
      "    dfs = uninitialized Node(K, V) -> Nil",
      "    dfs = ->(node : Node(K, V)) do",
      "      dfs.call(node.left.not_nil!) if node.left",
      "      res << {node.key, node.value}",
      "      dfs.call(node.right.not_nil!) if node.right",
      "      nil",
      "    end",
      "    dfs.call(@root.not_nil!)",
      "    res",
      "  end",
      " ",
      "  def to_s(io : IO) : Nil",
      "    io << \"{\" + to_a.map{ |key, value| \"#{key} => #{value}\" }.join(\", \") + \"}\"",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      " ",
      "  def <<(item : {K, V}) : Nil; upsert(item[0], item[1]) end",
      " ",
      "  def [](key : K) : V",
      "    return @default.not_nil! if @root.nil? && !@default.nil?",
      "    raise KeyError.new \"Missing key: #{key.inspect}\" unless @root",
      "    node = find_node(@root, key)",
      "    return @default.not_nil! if node.not_nil!.key != key && !@default.nil?",
      "    raise KeyError.new \"Missing key: #{key.inspect}\" if node.not_nil!.key != key",
      "    node.not_nil!.value",
      "  end",
      " ",
      "  def []?(key : K) : V?",
      "    return @default if @root.nil?",
      "    node = find_node(@root, key)",
      "    return @default if node.not_nil!.key != key",
      "    node.not_nil!.value",
      "  end",
      " ",
      "  def []=(key : K, value : V) : V",
      "    upsert(key, value)",
      "    value",
      "  end",
      "end"
    ],
    "description": "AATreeMap"
  },
  "セグメント木": {
    "prefix": "SegmentTree",
    "body": [
      "class SegmentTree(S)",
      "  include Enumerable(S)",
      "",
      "  getter size : Int32",
      "  delegate empty?, to: @nodes",
      "",
      "  @op : S, S -> S",
      "  @e : -> S",
      "",
      "  @height : Int32",
      "  @n : Int32",
      "  @nodes : Array(S)",
      "",
      "  def self.max(elems : Enumerable(S))",
      "    new elems, ->(x : S, y : S){ x > y ? x : y }, ->(){ S::MIN }",
      "  end",
      "",
      "  def self.min(elems : Enumerable(S))",
      "    new elems, ->(x : S, y : S){ x < y ? x : y }, ->(){ S::MAX }",
      "  end",
      "",
      "  def initialize(elems : Enumerable(S), @op : S, S -> S, @e : -> S)",
      "    @size = elems.size",
      "",
      "    @height = log2_ceil(@size)",
      "    @n = 1 << @height",
      "",
      "    @nodes = Array.new(2 * @n){ e.call }",
      "",
      "    elems.each_with_index{ |x, i| @nodes[@n + i] = x}",
      "    (1..@n - 1).reverse_each{ |i| update(i) }",
      "  end",
      "",
      "  def set(i : Int, val : S) : Nil",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    @nodes[i] = val",
      "    (1..@height).each{ |j| update(i >> j) }",
      "  end",
      "",
      "  def at(i : Int) : S",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    @nodes[i + @n]",
      "  end",
      "",
      "  def at?(i : Int) : S?",
      "    return nil unless 0 <= i && i < @size",
      "    at(i)",
      "  end",
      "",
      "  def each(& : S ->)",
      "    @size.times do |i|",
      "      yield at(i)",
      "    end",
      "  end",
      "",
      "  def prod(l, r) : S",
      "    raise IndexError.new unless 0 <= l && l <= r && r <= @size",
      "    sml, smr = @e.call, @e.call",
      "    l += @n",
      "    r += @n",
      "    while l < r",
      "      sml = @op.call(sml, @nodes[(l += 1) - 1]) if l.odd?",
      "      smr = @op.call(@nodes[r -= 1], smr) if r.odd?",
      "      l >>= 1",
      "      r >>= 1",
      "    end",
      "    @op.call(sml, smr)",
      "  end",
      "",
      "  def prod(range : Range(Int?, Int?)) : S",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    prod(left, right)",
      "  end",
      "",
      "  def prod?(l : Int, r : Int) : S?",
      "    return nil unless 0 <= l && l <= r && r <= @size",
      "    prod(l, r)",
      "  end",
      "",
      "  def prod?(range : Range(Int?, Int?)) : S?",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "    prod?(left, right)",
      "  end",
      "",
      "  def all_prod",
      "    @nodes[1]",
      "  end",
      "",
      "  def all_prod?",
      "    @nodes[1]?",
      "  end",
      "",
      "  def max_right(l : Int, & : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= l && l <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless yield @e.call",
      "    return @size if l == @size",
      "    l += @n",
      "    sm = @e.call",
      "    loop do",
      "      while l.even?",
      "        l >>= 1",
      "      end",
      "      unless (yield @op.call(sm, @nodes[l]))",
      "        while l < @n",
      "          l = 2 * l",
      "          if (yield @op.call(sm, @nodes[l]))",
      "            sm = @op.call(sm, @nodes[l])",
      "            l += 1",
      "          end",
      "        end",
      "        return (l - @n).to_i",
      "      end",
      "      sm = @op.call(sm, @nodes[l])",
      "      l += 1",
      "      break if (l & -l) == l",
      "    end",
      "    @size",
      "  end",
      "",
      "  def max_right?(l : Int, & : S -> Bool) : Int32?",
      "    return nil unless 0 <= l && l <= @size",
      "    return nil unless yield @e.call",
      "    max_right(l){ |x| yield x }",
      "  end",
      "",
      "  def min_left(r : Int, & : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= r && r <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless yield @e.call",
      "    return 0 if r == 0",
      "    r += @n",
      "    sm = @e.call",
      "    loop do",
      "      r -= 1",
      "      while r > 1 && r.odd?",
      "        r >>= 1",
      "      end",
      "      unless yield @op.call(@nodes[r], sm)",
      "        while r < @n",
      "          r = 2 * r + 1",
      "          if yield @op.call(@nodes[r], sm)",
      "            sm = @op.call(@nodes[r], sm)",
      "            r -= 1",
      "          end",
      "        end",
      "        return (r + 1 - @n).to_i",
      "      end",
      "      break if (r & -r) == r",
      "    end",
      "    0",
      "  end",
      "",
      "  def min_left?(r : Int, & : S -> Bool) : Int32?",
      "    return nil unless 0 <= r && r <= @size",
      "    return nil unless yield @e.call",
      "    min_left(r){ |x| yield x }",
      "  end",
      "",
      "  def [](i); at(i) end",
      "  def [](range : Range(Int?, Int?)); prod(range) end",
      "  def []?(i); at?(i) end",
      "  def []?(range : Range(Int?, Int?)); prod?(range) end",
      "  def []=(i : Int, val : S); set(i, val) end",
      "",
      "  def to_a : Array(S)",
      "    Array(S).new(@size){ |i| at(i) }",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    @size.times do |i|",
      "      io << \" \" unless i == 0",
      "      io << at(i)",
      "    end",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      "",
      "  private def update(k : Int)",
      "    @nodes[k] = @op.call(@nodes[2 * k], @nodes[2 * k + 1])",
      "  end",
      "",
      "  @[AlwaysInline]",
      "  private def log2_ceil(n : Int32) : Int32",
      "    log2_floor = 31 - n.leading_zeros_count",
      "    log2_floor + ((n & n - 1) == 0 ? 0 : 1)",
      "  end",
      "end"
    ],
    "description": "SegmentTree"
  },
  "遅延評価セグメント木": {
    "prefix": "LazySegmentTree",
    "body": [
      "struct Intervalish(T)",
      "  property val : T",
      "  property size : Int64",
      "  def initialize(@val : T, @size : Int64)",
      "  end",
      "",
      "  def self.zero",
      "    new T.zero, Int64.zero",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    io << @val",
      "  end",
      "end",
      "",
      "class LazySegmentTree(S, F)",
      "  include Enumerable(S)",
      "",
      "  getter size : Int32",
      "",
      "  @op : S, S -> S",
      "  @mapping : F, S -> S",
      "  @composition : F, F -> F",
      "",
      "  @height : Int32",
      "  @n : Int32",
      "  @nodes : Array(S)",
      "  @lazy_nodes : Array(F)",
      "",
      "  def initialize(elems : Enumerable(S), @op : S, S -> S, @e : -> S, @mapping : F, S -> S, @composition : F, F -> F, @id : -> F)",
      "    @size = elems.size",
      "",
      "    @height = log2_ceil(@size)",
      "    @n = 1 << @height",
      "",
      "    @nodes = Array.new(2 * @n){ @e.call }",
      "    @lazy_nodes = Array.new(@n){ @id.call }",
      "    ",
      "    elems.each_with_index{ |x, i| @nodes[@n + i] = x }",
      "    (@n - 1).downto(1) do |i|",
      "      update(i)",
      "    end",
      "  end",
      "",
      "  # 区間加算・区間最小値を取得するセグ木を構築します。",
      "  def self.range_add_range_min(elems : Enumerable(S))",
      "    op = ->(a : S, b : S){ a < b ? a : b }",
      "    e = ->(){ S::MAX }",
      "    mapping = ->(f : F, x : S){ f + x }",
      "    composition = ->(f : F, g : F){ f + g }",
      "    id = ->(){ F.zero }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  # 区間加算・区間最大値を取得するセグ木を構築します。",
      "  def self.range_add_range_max(elems : Enumerable(S))",
      "    op = ->(a : S, b : S){ a > b ? a : b }",
      "    e = ->(){ S::MIN }",
      "    mapping = ->(f : F, x : S){ f + x }",
      "    composition = ->(f : F, g : F){ f + g }",
      "    id = ->(){ F.zero }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  # 区間加算・区間和を取得するセグ木を構築します。",
      "  #",
      "  # S には Intervalish な型を使用する必要があります。",
      "  def self.range_add_range_sum(elems : Enumerable(S))",
      "    op = ->(a : S, b : S) { S.new(a.val + b.val, a.size + b.size) }",
      "    e = ->() { S.zero }",
      "    mapping = ->(f : F, x : S) { S.new(x.val + f * x.size, x.size) }",
      "    composition = ->(f : F, g : F) { f + g }",
      "    id = ->() { F.zero }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  # 区間変更・区間最小値を取得するセグ木を構築します。",
      "  def self.range_add_range_min(elems : Enumerable(S))",
      "    op = ->(a : S, b : S){ a < b ? a : b }",
      "    e = ->(){ S::MAX }",
      "    mapping = ->(f : F, x : S){ f == F::MAX ? x : f }",
      "    composition = ->(f : F, g : F){ f == F::MAX ? g : f }",
      "    id = ->(){ F::MAX }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  # 区間変更・区間最大値を取得するセグ木を構築します。",
      "  def self.range_add_range_min(elems : Enumerable(S))",
      "    op = ->(a : S, b : S){ a > b ? a : b }",
      "    e = ->(){ S::MIN }",
      "    mapping = ->(f : F, x : S){ f == F::MAX ? x : f }",
      "    composition = ->(f : F, g : F){ f == F::MAX ? g : f }",
      "    id = ->(){ F::MAX }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  # 区間変更・区間和を取得するセグ木を構築します。",
      "  #",
      "  # S には Intervalish な型を使用する必要があります。",
      "  def self.range_set_range_sum(elems : Enumerable(S))",
      "    op = ->(a : S, b : S) { S.new(a.val + b.val, a.size + b.size) }",
      "    e = ->() { S.zero }",
      "    mapping = ->(f : F, x : S) { x.val = f * x.size if f != F::MAX; x }",
      "    composition = ->(f : F, g : F) { f == F::MAX ? g : f }",
      "    id = ->() { F::MAX }",
      "    new elems, op, e, mapping, composition, id",
      "  end",
      "",
      "  def set(i : Int, val : S) : Nil",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    @height.downto(1) { |j| push(i >> j) }",
      "    @nodes[i] = val",
      "    (1..@height).each{ |j| update(i >> j)}",
      "  end",
      "",
      "  def at(i : Int) : S",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    @height.downto(1) { |j| push(i >> j) }",
      "    @nodes[i]",
      "  end",
      "",
      "  def at?(i : Int) : S?",
      "    return nil unless 0 <= i && i < @size",
      "    at(i)",
      "  end",
      "",
      "  def each(& : S ->)",
      "    @size.times do |i|",
      "      yield at(i)",
      "    end",
      "  end",
      "",
      "  def prod(l : Int, r : Int) : S",
      "    raise IndexError.new unless 0 <= l && l <= r && r <= @size",
      "    return @e.call if l == r",
      "",
      "    l += @n",
      "    r += @n",
      "",
      "    (1..@height).each do |i|",
      "      j = @height - i + 1",
      "      push(l >> j) if ((l >> j) << j) != l",
      "      push((r - 1) >> j) if ((r >> j) << j) != r",
      "    end",
      "",
      "    sml, smr = @e.call, @e.call",
      "    while l < r",
      "      sml = @op.call(sml, @nodes[(l += 1) - 1]) if l.odd?",
      "      smr = @op.call(@nodes[r -= 1], smr) if r.odd?",
      "      l >>= 1",
      "      r >>= 1",
      "    end",
      "",
      "    @op.call(sml, smr)",
      "  end",
      "",
      "  def prod?(l : Int, r : Int) : S?",
      "    return nil unless 0 <= l && l <= r && r <= @size",
      "    prod(l, r)",
      "  end",
      "",
      "  def prod(range : Range(Int, Int)) : S",
      "    prod(range.begin, range.exclusive? ? range.end : range.end + 1)",
      "  end",
      "",
      "  def prod?(range : Range(Int, Int)) : S?",
      "    prod?(range.begin, range.exclusive? ? range.end : range.end + 1)",
      "  end",
      "",
      "  def all_prod : S",
      "    @nodes[1]",
      "  end",
      "",
      "  def all_prod? : S?",
      "    @nodes[1]?",
      "  end",
      "",
      "  def apply(i : Int, f : F) : Nil",
      "    raise IndexError.new unless 0 <= i && i < @size",
      "    i += @n",
      "    @height.downto(1) { |j| push(i >> j) }",
      "    @nodes[i] = @mapping.call(f, @nodes[i])",
      "    (1..@height).each{ |j| update(i >> j) }",
      "  end",
      "",
      "  def apply(l : Int, r : Int, f : F) : Nil",
      "    raise IndexError.new unless 0 <= l && l <= r && r <= @size",
      "    return if l == r",
      "",
      "    l += @n",
      "    r += @n",
      "",
      "    @height.downto(1) do |i|",
      "      push(l >> i) if ((l >> i) << i) != l",
      "      push((r - 1) >> i) if ((r >> i) << i) != r",
      "    end",
      "",
      "    l2, r2 = l, r",
      "    while l < r",
      "      all_apply((l += 1) - 1, f) if l.odd?",
      "      all_apply(r -= 1, f) if r.odd?",
      "      l >>= 1",
      "      r >>= 1",
      "    end",
      "    l, r = l2, r2",
      "",
      "    (1..@height).each do |i|",
      "      update(l >> i) if ((l >> i) << i) != l",
      "      update((r - 1) >> i) if ((r >> i) << i) != r",
      "    end",
      "  end",
      "",
      "  def apply(range : Range(Int, Int), f : F)",
      "    apply(range.begin, range.exclusive? ? range.end : range.end + 1, f)",
      "  end",
      "",
      "  def apply?(i : Int, f : F) : Bool",
      "    return false unless 0 <= i && i < @size",
      "    apply(i, f)",
      "    true",
      "  end",
      "",
      "  def apply?(l : Int, r : Int, f : F) : Bool",
      "    return false unless 0 <= l && l <= r && r <= @size",
      "    apply(l, r, f)",
      "    true",
      "  end",
      "",
      "  def apply?(range : Range(Int, Int), f : F) : Bool",
      "    l = range.begin",
      "    r = range.exclusive? ? range.end : range.end + 1",
      "    return false unless 0 <= l && l <= r && r <= @size",
      "    apply(l, r, f)",
      "    true",
      "  end",
      "",
      "  def max_right(l : Int, ok : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= l && l <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless ok.call(@e.call)",
      "    return @size if l == @size",
      "    l += @n",
      "    (1..@height).each{ |i| push(l >> i) }",
      "    sm = @e.call",
      "    loop do",
      "      while l.even?",
      "        l >>= 1",
      "      end",
      "      unless ok.call(@op.call(sm, @nodes[l]))",
      "        while l < @n",
      "          push(l)",
      "          l = 2 * l",
      "          if ok.call(@op.call(sm, @nodes[l]))",
      "            sm = @op.call(sm, @nodes[l])",
      "            l += 1",
      "          end",
      "        end",
      "        return (l - @n).to_i",
      "      end",
      "      sm = @op.call(sm, @nodes[l])",
      "      l += 1",
      "      break if (l & -l) == l",
      "    end",
      "    @size",
      "  end",
      "",
      "  def max_right?(l : Int, ok : S -> Bool) : Int32?",
      "    return nil unless 0 <= l && l <= @size",
      "    return nil unless ok.call(@e.call)",
      "    max_right(l, ok)",
      "  end",
      "",
      "  def min_left(r : Int, ok : S -> Bool) : Int32",
      "    raise IndexError.new unless 0 <= r && r <= @size",
      "    raise \"単位元 e で ok(e) == true である必要があります。\" unless ok.call(@e.call)",
      "    return 0 if r == 0",
      "    r += @n",
      "    @height.downto(1) { |j| push((r - 1) >> i) }",
      "    sm = @e.call",
      "    loop do",
      "      r -= 1",
      "      while r > 1 && r.odd?",
      "        r >>= 1",
      "      end",
      "      unless ok.call(@op.call(@nodes[r], sm))",
      "        while r < @n",
      "          push(r)",
      "          r = 2 * r + 1",
      "          if ok.call(@op.call(@nodes[r], sm))",
      "            sm = @op.call(@nodes[r], sm)",
      "            r -= 1",
      "          end",
      "        end",
      "        return (r + 1 - @n).to_i",
      "      end",
      "      break if (r & -r) == r",
      "    end",
      "    0",
      "  end",
      "",
      "  def min_left?(r : Int, ok : S -> Bool) : Int32?",
      "    return nil unless 0 <= r && r <= @size",
      "    return nil unless ok.call(@e.call)",
      "    min_left(r, ok)",
      "  end",
      "",
      "  def [](i : Int); at(i) end",
      "  def []?(i : Int); at?(i) end",
      "  def []=(i : Int, val : S); set(i, val) end",
      "",
      "  def to_a : Array(S)",
      "    Array(S).new(@size){ |i| at(i) }",
      "  end",
      "",
      "  def to_s(io : IO)",
      "    @size.times do |i|",
      "      io << \" \" unless i == 0",
      "      io << at(i)",
      "    end",
      "  end",
      "",
      "  def inspect(io : IO); to_s(io) end",
      "",
      "  private def update(k : Int) : Nil",
      "    @nodes[k] = @op.call(@nodes[2 * k], @nodes[2 * k + 1])",
      "  end",
      "",
      "  private def all_apply(k : Int, f : F) : Nil",
      "    @nodes[k] = @mapping.call(f, @nodes[k])",
      "    @lazy_nodes[k] = @composition.call(f, @lazy_nodes[k]) if k < @n",
      "  end",
      "",
      "  private def push(k : Int) : Nil",
      "    all_apply(2 * k, @lazy_nodes[k])",
      "    all_apply(2 * k + 1, @lazy_nodes[k])",
      "    @lazy_nodes[k] = @id.call",
      "  end",
      "",
      "  @[AlwaysInline]",
      "  private def log2_ceil(n : Int32) : Int32",
      "    log2_floor = 31 - n.leading_zeros_count",
      "    log2_floor + ((n & n - 1) == 0 ? 0 : 1)",
      "  end",
      "end"
    ],
    "description": "LazySegmentTree"
  },
  "ConvexHullTrick": {
    "prefix": "ConvexHullTrick",
    "body": [
      "class ConvexHullTrick(T)",
      "  getter lines : Array({T, T})",
      "  @head : Int32",
      "  @comp : T, T -> Bool",
      "",
      "  def initialize(&@comp : T, T -> Bool)",
      "    @head = 0",
      "    @lines = [] of {T, T}",
      "  end",
      "",
      "  def self.min",
      "    new { |lhs, rhs| lhs >= rhs }",
      "  end",
      "",
      "  def self.max",
      "    new { |lhs, rhs| lhs <= rhs }",
      "  end",
      "",
      "  def add(k : T, b : T)",
      "    line = {k, b}",
      "    while @lines.size - @head >= 2 && check(@lines[-2], @lines.last, line)",
      "      @lines.pop",
      "    end",
      "    @lines << line",
      "  end",
      "",
      "  def monotonic_query(x : T)",
      "    while @lines.size - @head >= 2 && compare(f(@lines[@head], x), f(@lines[@head + 1], x))",
      "      @head += 1",
      "    end",
      "    f(@lines[@head], x)",
      "  end",
      "",
      "  def query(x : T)",
      "    ac = @lines.size - 1",
      "    wa = -1",
      "    while ac - wa > 1",
      "      wj = (ac + wa) // 2",
      "      if !compare(f(@lines[wj], x), f(@lines[wj + 1], x))",
      "        ac = wj",
      "      else",
      "        wa = wj",
      "      end",
      "    end",
      "    f(@lines[ac], x)",
      "  end",
      "",
      "  @[AlwaysInline]",
      "  private def compare(a : T, b : T) : Bool",
      "    @comp.call(a, b)",
      "  end",
      "",
      "  @[AlwaysInline]",
      "  private def f(line : {T, T}, x) : T",
      "    line[0] * x + line[1]",
      "  end",
      "",
      "  @[AlwaysInline]",
      "  private def check(l1 : {T, T}, l2 : {T, T}, l3 : {T, T}) : Bool",
      "    (l2[0] - l1[0]) * (l3[1] - l2[1]) >= (l2[1] - l1[1]) * (l3[0] - l2[0])",
      "  end",
      "end"
    ],
    "description": "ConvexHullTrick"
  },
  "双方向リスト": {
    "prefix": "DoublyLinkedList",
    "body": [
      "class DoublyLinkedList(T)",
      "  class Node(T)",
      "    protected property pred : Node(T)?",
      "    protected property next : Node(T)?",
      "    @val : T",
      "    protected property dummy : Bool",
      "",
      "    def initialize(@pred : Node(T)?, @next : Node(T)?, @val : T, @dummy : Bool = false)",
      "    end",
      "",
      "    getter(val){ dummy ? nil.not_nil! : val }",
      "    getter?(val){ dummy ? nil : val }",
      "    setter val",
      "  end",
      "",
      "  getter head : Node(T)",
      "  getter tail : Node(T)",
      "  getter size : Int32",
      "",
      "  def initialize",
      "    @head = Node(T).new(nil, nil, T.new, dummy: true)",
      "    @tail = @head",
      "    @size = 0",
      "  end",
      "",
      "",
      "  # リストに要素を右側（tail側）に挿入します。",
      "  #",
      "  # 挿入された右側のノードを返します。",
      "  #",
      "  # ```",
      "  # list = DoublyLinkedList(Int32).new",
      "  # it = list.insert_right(list.head, 10)",
      "  # it = list.insert_right(it, 20)",
      "  # it = list.insert_right(it, 30)",
      "  # list # => [10, 20, 30]",
      "  # ```",
      "  def insert_right(node : Node(T), val : T)",
      "    @size += 1",
      "    if @size == 1",
      "      @head = Node.new(nil, nil, val)",
      "      @tail = @head",
      "      return @head",
      "    else",
      "      if node.next.nil?",
      "        node.next = Node.new(pred: node, next: nil, val: val)",
      "        @tail = node.next.not_nil!",
      "        @tail.pred = node",
      "      else",
      "        tmp = node.next.not_nil!",
      "        node.next = Node.new(pred: node, next: tmp, val: val)",
      "        tmp.pred = node.next",
      "      end",
      "      return node.next.not_nil!",
      "    end",
      "  end",
      "",
      "  # リストに要素を左側（head側）に挿入します。",
      "  #",
      "  # 挿入された左側のノードを返します。",
      "  #",
      "  # ```",
      "  # list = DoublyLinkedList(Int32).new",
      "  # it = list.insert_left(list.head, 10)",
      "  # it = list.insert_left(it, 20)",
      "  # it = list.insert_left(it, 30)",
      "  # list # => [30, 20, 10]",
      "  # ```",
      "  def insert_left(node : Node(T), val : T)",
      "    @size += 1",
      "    if @size == 1",
      "      @head = Node.new(nil, nil, val)",
      "      @tail = @head",
      "      return @head",
      "    else",
      "      if node.pred.nil?",
      "        node.pred = Node.new(pred: nil, next: node, val: val)",
      "        @head = node.pred.not_nil!",
      "        @head.next = node",
      "      else",
      "        tmp = node.pred.not_nil!",
      "        node.pred = Node.new(pred: tmp, next: node, val: val)",
      "        tmp.next = node.pred",
      "      end",
      "      return node.pred.not_nil!",
      "    end",
      "  end",
      "",
      "  # ノードを削除します。",
      "  #",
      "  # 削除された右側のノードを返します。",
      "  #",
      "  # ```",
      "  # list = DoublyLinkedList(Int32).new [1, 2, 3]",
      "  # list # => [10, 20, 30]",
      "  # list.erase(list.head)",
      "  # list # => [20, 30]",
      "  # ```",
      "  def erase(node : Node(T))",
      "    raise Exception.new(\"無効なノードを削除しようとしています。\") if node.val?.nil?",
      "    if node == @head",
      "      @head = @head.next.nil? ? Node.new(nil, nil, nil) : @head.next",
      "      @tail = @head if @head.val?.nil?",
      "    elsif node == @head",
      "    else",
      "    end",
      "    pre = node.pred",
      "    nxt = node.next",
      "    pre.next = nxt",
      "    nxt.pred = pre",
      "  end",
      "",
      "",
      "  def to_s(io : IO)",
      "    return if @size == 0",
      "    node = @head",
      "    io << \"[\"",
      "    loop do",
      "      io << node.not_nil!.val",
      "      node = node.next",
      "      break if node.nil? || node.val?.nil?",
      "      io << \", \"",
      "    end",
      "    io << \"]\"",
      "  end",
      "end"
    ],
    "description": "双方向リスト [WIP]"
  },
  "SparseTable": {
    "prefix": "SparseTable",
    "body": [
      "class SparseTable(T)",
      "  getter size : Int32",
      "  @data : Array(T)",
      "  @table : Array(Array(T))",
      "  @lookup : Array(Int32)",
      "  @op : (T, T) -> T",
      "",
      "  def self.max(elems : Enumerable(T))",
      "    new elems, ->(x : T, y : T){ x > y ? x : y }",
      "  end",
      "",
      "  def self.min(elems : Enumerable(T))",
      "    new elems, ->(x : T, y : T){ x < y ? x : y }",
      "  end",
      "",
      "  def self.bitwise_or(elems : Enumerable(T))",
      "    new elems, ->(x : T, y : T){ x | y }",
      "  end",
      "",
      "  def self.bitwise_and(elems : Enumerable(T))",
      "    new elems, ->(x : T, y : T){ x & y }",
      "  end",
      "",
      "  def self.gcd(elems : Enumerable(T))",
      "    new elems, ->(x : T, y : T){ x.gcd(y) }",
      "  end",
      "",
      "  def initialize(elems : Enumerable(T), @op : (T, T) -> T)",
      "    @size = elems.size",
      "    @data = Array(T).new",
      "    log = (0..).index{ |k| (1 << k) > @size }.not_nil!",
      "",
      "    @table = Array.new(log){ Array(T).new(1 << log, T.zero) }",
      "    elems.each_with_index{ |e, i| @table[0][i] = e; @data << e }",
      "",
      "    (1...log).each do |i|",
      "      j = 0",
      "      while j + (1 << i) <= (1 << log)",
      "        @table[i][j] = @op.call(@table[i - 1][j], @table[i - 1][j + (1 << (i - 1))])",
      "        j += 1",
      "      end",
      "    end",
      "",
      "    @lookup = [0] * (@size + 1)",
      "    (2..@size).each do |i|",
      "      @lookup[i] = @lookup[i >> 1] + 1",
      "    end",
      "  end",
      "",
      "  def prod(range : Range(Int?, Int?))",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "",
      "    b = @lookup[right - left]",
      "    @op.call(@table[b][left], @table[b][right - (1 << b)])",
      "  end",
      "",
      "  def prod?(range : Range(Int?, Int?))",
      "    left = (range.begin || 0)",
      "    right = if range.end.nil?",
      "        @size",
      "      else",
      "        range.end.not_nil! + (range.exclusive? ? 0 : 1)",
      "      end",
      "",
      "    return nil unless 0 <= left && left <= right && right <= @size",
      "    prod(range)",
      "  end",
      "",
      "  def [](i)",
      "    @data[i]",
      "  end",
      "",
      "  def []?(i)",
      "    @data[i]?",
      "  end",
      "",
      "  def [](range : Range(Int?, Int?))",
      "    prod(range)",
      "  end",
      "",
      "  def []?(range : Range(Int?, Int?))",
      "    prod?(range)",
      "  end",
      "end"
    ],
    "description": "SparseTable"
  },

  // その他
  "Mo's Algorithm": {
    "prefix": "Mo",
    "body": [
      "module Moable",
      "  abstract def size : Int32",
      "  abstract def add(i : Int)",
      "  abstract def delete(i : Int)",
      "  abstract def answer",
      "",
      "  def answers(ranges : Array(Range(Int, Int)))",
      "    q = ranges.size",
      "  ",
      "    width = Math.max(1, (size / Math.max(1.0, Math.sqrt(q * 2 / 3))).to_i)",
      "    orders = (0...q).to_a",
      "  ",
      "    orders.sort! { |i, j|",
      "      ablock = ranges[i].begin // width",
      "      bblock = ranges[j].begin // width",
      "      if ablock != bblock",
      "        next ablock <=> bblock",
      "      end",
      "      if ablock.odd?",
      "        next ranges[i].end <=> ranges[j].end",
      "      end",
      "      -ranges[i].end <=> -ranges[j].end",
      "    }",
      "  ",
      "    left = 0",
      "    right = 0",
      "    indices = [0] * q",
      "    answers = orders.map_with_index { |i, index|",
      "      while left > ranges[i].begin",
      "        add(left - 1)",
      "        left -= 1",
      "      end",
      "      while right < ranges[i].end",
      "        add(right)",
      "        right += 1",
      "      end",
      "      while left < ranges[i].begin",
      "        delete(left)",
      "        left += 1",
      "      end",
      "      while right > ranges[i].end",
      "        delete(right - 1)",
      "        right -= 1",
      "      end",
      "      indices[i] = index",
      "      answer",
      "    }",
      "",
      "    Array.new(q) { |i| answers[indices[i]] }",
      "  end",
      "end",
      "",
      "class Mo",
      "  include Moable",
      "",
      "  @a : Array(Int64)",
      "",
      "  def initialize(@a)",
      "  end",
      "",
      "  def size : Int32",
      "    @a.size",
      "  end",
      "",
      "  def add(i : Int)",
      "  end",
      "",
      "  def delete(i : Int)",
      "  end",
      "",
      "  def answer",
      "  end",
      "end"
    ],
    "description": "Mo"
  },

  // マラソン
  "XorShift": {
    "prefix": "XorShift",
    "body": [
      "class XorShift",
      "  def initialize",
      "    @m1 = 1859738746",
      "    @m2 = 9707750167",
      "    @m3 = 2653432786",
      "    @m4 = 3463085849",
      "  end",
      "",
      "  def next_int32(n : Int32)",
      "    revolve",
      "    (@m4 % n).to_i32",
      "  end",
      "",
      "  def next_int32(a : Int32, b : Int32)",
      "    revolve",
      "    (@m4 % (b - a) + a).to_i32",
      "  end",
      "",
      "  def next_int32(range : Range(Int32, Int32))",
      "    next_int32(range.begin, range.end + (range.exclusive? ? 0 : 1))",
      "  end",
      "",
      "  def next_int64(n : Int64)",
      "    revolve",
      "    (@m4 % n).to_i64",
      "  end",
      "",
      "  def next_int64(a : Int64, b : Int64)",
      "    revolve",
      "    (@m4 % (b - a) + a).to_i64",
      "  end",
      "",
      "  def next_int64(range : Range(Int64, Int64))",
      "    next_int64(range.begin, range.end + (range.exclusive? ? 0 : 1))",
      "  end",
      "",
      "  private def revolve",
      "    t = @m1 ^ (@m1 << 11_u64)",
      "    @m1, @m2, @m3 = @m2, @m3, @m4",
      "    @m4 = (@m4 ^ (@m4 >> 19_u64)) ^ (t ^ (t >> 8_u64))",
      "  end",
      "end"
    ],
    "description": "XorShift"
  },
  "Stopwatch": {
    "prefix": "Stopwatch",
    "body": [
      "class Stopwatch",
      "  def initialize",
      "    @start = Time.utc",
      "  end",
      "",
      "  def reset",
      "    @start = Time.utc",
      "  end",
      "",
      "  def ms",
      "    Time.utc.to_unix_ms - @start.to_unix_ms",
      "  end",
      "",
      "  def sec",
      "    ms / 1000",
      "  end",
      "",
      "  def to_s(io)",
      "    io << ms << \"ms\"",
      "  end",
      "end"
    ],
    "description": "Stopwatch"
  },
}