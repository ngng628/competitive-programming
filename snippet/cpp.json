{
    //─────────────────────────────────────────────────────────
    //  1. 型
    //─────────────────────────────────────────────────────────
    "Solver": {
        "prefix": "Solver",
        "body": [
            "struct Solver {",
            "   Solver() = default;",
            "   ${1:void} solve($2) {",
            "   }",
            "};"
        ],
        "description": "Solver"
    },
    "構造体": {
        "prefix": "struct",
        "body": [
            "struct ${1:Data} {",
            "   ${1:Data}() = default;",
            "};"
        ],
        "description": "構造体"
    },
    //─────────────────────────────────────────────────────────
    //  2. 出力
    //─────────────────────────────────────────────────────────
    "cout": {
        "prefix": "cout",
        "body": [
            "cout << ${1:ans} << '\\n';"
        ],
        "description": "標準出力"
    },
    "Yes": {
        "prefix": "Yes",
        "body": [
            "puts(\"Yes\");"
        ],
        "description": "Yes"
    },
    "No": {
        "prefix": "No",
        "body": [
            "puts(\"No\");"
        ],
        "description": "No"
    },
    "hr": {
        "prefix": "hr",
        "body": [
            "eprintf(\"===========================\\n\");"
        ],
        "description": "水平線"
    },
    "inf": {
        "prefix": "inf",
        "body": [
            "cout << (${1:ans} >= oo ? -1 : ${1:ans}) << '\\n';",
        ],
        "description": "INFで条件分岐する出力"
    },
    "yn": {
        "prefix": "yn",
        "body": [
            "puts(${1:condition} ? \"Yes\" : \"No\");",
        ],
        "description": "Yes/No表示"
    },
    "YN": {
        "prefix": "YN",
        "body": [
            "puts(${1:condition} ? \"YES\" : \"NO\");",
        ],
        "description": "YES/NO表示"
    },
    "printf": {
        "prefix": "printf",
        "body": [
            "printf(\"${1:message}\\n\"$2);",
        ],
        "description": "printf"
    },
    "eprintf": {
        "prefix": "eprintf",
        "body": [
            "eprintf(\"${1:message}\\n\"$2);",
        ],
        "description": "eprintf"
    },
    //─────────────────────────────────────────────────────────
    //  3. 標準入りしてほしいような便利関数
    //─────────────────────────────────────────────────────────
    "modinv": {
        "prefix": "modinv",
        "body": [
            "int modinv(int a, int m) {",
            "    int b = m, u = 1, v = 0;",
            "    while (b) {",
            "        int t = a / b;",
            "        a -= t * b;",
            "        swap(a, b);",
            "        u -= t * v;",
            "        swap(u, v);",
            "    }",
            "    u %= m;",
            "    if (u < 0) u += m;",
            "    return u;",
            "}",
        ],
        "description": "mod mの世界での逆元"
    },
    "splited": {
        "prefix": "splited",
        "body": [
            "vec<string> splited(const string &s, char delim) {",
            "   vec<string> elems;",
            "   string item;",
            "   for (char ch: s) {",
            "       if (ch == delim) {",
            "           if (!item.empty()) elems.pb(item);",
            "           item.clear();",
            "       }",
            "       else item += ch;",
            "   }",
            "   if (!item.empty()) elems.pb(item);",
            "   return elems;",
            "}",
        ],
        "description": "Split関数"
    },
    "Unique": {
        "prefix": "Unique",
        "body": [
            "template <class T>",
            "inline void Unique(T &v) {",
            "   sort(all(v));",
            "   v.erase(unique(all(v)), v.end());",
            "}"
        ],
        "description": "Unique"
    },
    "ctoi": {
        "prefix": "ctoi",
        "body": [
            "int ctoi(char c){ return isdigit(c) ? c - '0' : -1; }"
        ],
        "description": "ctoi"
    },
    "回文判定": {
        "prefix": [
            "IsPalidrome",
            "isPalidrome",
            "kaibun"
        ],
        "body": [
            "template <class T>",
            "bool IsPalindrome(const T& s) {",
            "   const int n = len(s);",
            "   rep (i, n / 2) {",
            "      if (s[i] != s[n - i - 1]) {",
            "         return false;",
            "      }",
            "   }",
            "   return true;",
            "}"
        ],
        "description": "回文判定"
    },
    "secondでソートするためのラムダ式": {
        "prefix": "by_second",
        "body": "[](const pii& a, const pii& b){ return make_pair(a.second, a.first) < make_pair(b.second, b.first); }",
        "description": "secondでソートするためのラムダ式"
    },
    "overflowing": {
        "prefix": "overflowing",
        "body": [
            "namespace overflowing {",
            "   template <class T1, class T2>",
            "   constexpr bool add(T1 lhs, T2 rhs) {",
            "      decltype(lhs + rhs) _res;",
            "      return __builtin_add_overflow(lhs, rhs, &_res);",
            "   }",
            "",
            "   template <class T1, class T2>",
            "   constexpr bool sub(T1 lhs, T2 rhs) {",
            "      decltype(lhs - rhs) _res;",
            "      return __builtin_sub_overflow(lhs, rhs, &_res);",
            "   }",
            "",
            "   template <class T1, class T2>",
            "   constexpr bool mul(T1 lhs, T2 rhs) {",
            "      decltype(lhs * rhs) _res;",
            "      return __builtin_mul_overflow(lhs, rhs, &_res);",
            "   }",
            "}"
        ],
        "description": "overflowing"
    },
    //─────────────────────────────────────────────────────────
    //  4. ループ処理
    //─────────────────────────────────────────────────────────
    "bitfor": {
        "prefix": "bitfor",
        "body": [
            "rep (mask, BitOperations::Bit(${1:n})) {",
            "   $2",
            "   rep (i, ${1:n}) {",
            "      if (BitOperations::Stand(mask, i)) {",
            "      }",
            "   }",
            "}",
        ],
        "description": "bit全探索"
    },
    "combifor": {
        "prefix": "combifor",
        "body": [
            "void recursive_comb(int *indexes, int s, int rest, std::function<void(int *)> f) {",
            "   if (rest == 0) f(indexes);",
            "   else {",
            "      if (s < 0) return;",
            "      recursive_comb(indexes, s - 1, rest, f);",
            "      indexes[rest - 1] = s;",
            "      recursive_comb(indexes, s - 1, rest - 1, f);",
            "   }",
            "}",
            "",
            "void for_comb(int n, int k, std::function<void(int *)> f) {",
            "   int indexes[k];",
            "   recursive_comb(indexes, n - 1, k, f);",
            "}",
            "",
            "void for_perm(int n, std::function<void(int *)> f) {",
            "   int indexes[n];",
            "   rep (i, n) indexes[i] = i;",
            "   do {",
            "      f(indexes);",
            "   } while (std::next_permutation(indexes, indexes + n));",
            "}",
            "",
            "void for_perm(int n, int k, std::function<void(int *)> f) {",
            "   for_comb(n, k, [&](int *c_indexes) {",
            "      for_perm(k, [&](int *p_indexes) {",
            "         int indexes[k];",
            "         rep (i, k) indexes[i] = c_indexes[p_indexes[i]];",
            "         f(indexes);",
            "      });",
            "   });",
            "}"
        ],
        "description": "combifor"
    },
    "erasefor": {
        "prefix": "erasefor",
        "body": [
            "for (auto it = ${1:v}.begin(); it != ${1:v}.end();) {",
            "   if (${2:condition(*it)}) it = ${1:v}.erase(it);",
            "   else ++it;",
            "}"
        ],
        "description": "erasefor"
    },
    //─────────────────────────────────────────────────────────
    //  5. 累積和・いもす法
    //─────────────────────────────────────────────────────────
    "累積和": {
        "prefix": "StaticRangeSum",
        "body": [
          "template <class T>",
          "struct StaticRangeSum {",
          "   StaticRangeSum() = default;",
          "   explicit StaticRangeSum(const vec<T>& seq) {",
          "      const int n = len(seq);",
          "      sums.resize(n + 1);",
          "      sums[0] = 0;",
          "      partial_sum(all(seq), begin(sums) + 1);",
          "   }",
          "",
          "   T get(int r) const {",
          "      return get(0, r);",
          "   }",
          "   T operator ()(int r) const { return get(0, r); }",
          "",
          "   T get(int l, int r) const {",
          "      assert(0 <= l and l < r and r <= len(sums) - 1);",
          "      return sums[r] - sums[l];",
          "   }",
          "   T operator ()(int l, int r) const { return get(l, r); }",
          "",
          "   int lower_bound(T val) const {",
          "      return distance(cbegin(sums) + 1, lower_bound(cbegin(sums) + 1, sums.cend(), val));",
          "   }",
          "",
          "   int upper_bound(T val) const {",
          "      return distance(cbegin(sums) + 1, upper_bound(cbegin(sums) + 1, sums.cend(), val));",
          "   }",
          "",
          "   vec<T> sums;",
          "};"
        ],
        "description": "累積和"
    },
    "いもす法": {
        "prefix": "Imos",
        "body": [
            "struct Imos {",
            "   Imos() = default;",
            "   // [0, n]",
            "   Imos(int n) : cnt(n + 2) {}",
            "",
            "   // [l, r]",
            "   void add(int l, int r, int x = 1) {",
            "      cnt[l] += x;",
            "      cnt[r + 1] -= x;",
            "   }",
            "",
            "   // [0, n]",
            "   vi get() const {",
            "      auto tmp = cnt;",
            "      rep (i, len(cnt) - 1) tmp[i+1] += tmp[i];",
            "      tmp.pop_back();",
            "      return tmp;",
            "   }",
            "",
            "   vi cnt;",
            "};"
        ],
        "description": "いもす法"
    },
    //─────────────────────────────────────────────────────────
    //  6. 配列操作
    //─────────────────────────────────────────────────────────
    "rotated": {
        "prefix": "rotated",
        "body": [
            "vvi rotated(const vvi& s, const int t) {",
            "   const int h = len(s), w = len(s[0]);",
            "   switch ((t % 4 + 4) % 4) {",
            "      case 0: return s;",
            "      case 1: {",
            "         vvi r(w, vi(h, 0));",
            "         rep (i, w) rep (j, h) r[i][j] = s[h-1-j][i];",
            "         return r;",
            "      }",
            "      case 2: {",
            "         vvi r = s;",
            "         rep (i, h / 2) rep (j, w) swap(r[i][j], r[h-1-i][j]);",
            "         rep (i, h) reverse(all(r[i]));",
            "         return r;",
            "      }",
            "      case 3: {",
            "         vvi r(w, vi(h, 0));",
            "         rep (i, w) rep (j, h) r[i][j] = s[j][w-1-i];",
            "         return r;",
            "      }",
            "   }",
            "   return vvi();",
            "}"
        ],
        "description": "rotated"
    },
    "transposed": {
        "prefix": "transposed",
        "body": [
            "vvi transposed(const vvi& s) {",
            "   const int h = len(s), w = len(s[0]);",
            "   vvi r(w, vi(h));",
            "   rep (i, h) rep (j, w) r[j][i] = s[i][j];",
            "   return r;",
            "}",
        ],
        "description": ""
    },
    //─────────────────────────────────────────────────────────
    //  7. 深さ優先探索・幅優先探索
    //─────────────────────────────────────────────────────────
    "幅優先探索": {
        "prefix": "bfs",
        "body": [
            "for (queue<int> que({${1:start}}); not que.empty();) {",
            "   int now = que.front(); que.pop();",
            "   for (${2:int nxt : graph[now]}) {",
            "      if (${3:/* visited */}) continue;",
            "      que.push(nxt);",
            "   }",
            "}"
        ],
        "description": "幅優先探索"
    },
    "深さ優先探索": {
        "prefix": ["dfs", "rec"],
        "body": [
          "Bind([&](auto&& dfs, int subroot, int parent) {",
          "   for (int child : graph[subroot]) {",
          "      if (child == parent) continue;",
          "      dfs(child, subroot);",
          "   }",
          "});"
        ],
        "description": "深さ優先探索"
    },
    "over": {
        "prefix": "over",
        "body": [
            "auto over = [h, w](int y, int x) { return y < 0 or y >= h or x < 0 or x >= w; };",
        ],
        "description": "範囲超え判定"
    },
    "node": {
        "prefix": "node",
        "body": [
            "auto node = [w](int y, int x) { return w*y + x; };",
        ],
        "description": "(y, x)をノード番号に変換"
    },
    "mazebfs": {
        "prefix": "mazebfs",
        "body": [
            "vvi dist(h, vi(w, -1));",
            "dist[${1:sy}][${2:sx}] = 0;",
            "for (queue<pii> que({{${1:sy}, ${2:sx}}}); not que.empty();){",
            "   auto [y, x] = que.front();",
            "   que.pop();",
            "   for (auto [dy, dx] : dydx4) {",
            "      int ny = y + dy, nx = x + dx;",
            "      if (over(ny, nx)) continue;",
            "      if (dist[ny][nx] != -1) continue;",
            "      if (s[ny][nx] == '#') continue;",
            "      dist[ny][nx] = dist[y][x] + 1;",
            "      que.emplace(ny, nx);",
            "   }",
            "}"
        ],
        "description": "mazebfs"
    },
    //─────────────────────────────────────────────────────────
    //  7. グラフ
    //─────────────────────────────────────────────────────────
    "辺を逆向きに貼ったグラフ": {
        "prefix": "RevGraph",
        "body": [
            "vvi RevGraph(const vvi& graph) {",
            "   const int n = len(graph);",
            "   vvi res(n);",
            "   rep (i, n) {",
            "      for (int j : graph[i]) {",
            "         res[j].push_back(i);",
            "      }",
            "   }",
            "   return res;",
            "}"
        ],
        "description": "辺を逆向きに貼ったグラフ"
    },
    "Edge": {
        "prefix": "Edge",
        "body": [
            "struct Edge {",
            "   Edge() = default;",
            "   Edge(int t, int w = 0) : to(t), weight(w) {}",
            "   int to;",
            "   int weight;",
            "};",
            "using Graph = vec<vec<Edge>>;",
        ],
        "description": "重み付き辺"
    },
    "最小全域木": {
        "prefix": "MinimumSpanningTree",
        "body": [
            "struct MinimumSpanningTree {",
            "   struct Edge {",
            "      Edge() = default;",
            "      Edge(int _u, int _v, int w) : u(_u), v(_v), weight(w) {}",
            "      int u;",
            "      int v;",
            "      int weight;",
            "      friend bool operator <(const Edge& a, const Edge& b) { return a.weight < b.weight; }",
            "   };",
            "",
            "   MinimumSpanningTree() = default;",
            "   MinimumSpanningTree(int _v) : v(_v) {}",
            "   MinimumSpanningTree(int _v, const vec<Edge>& _edges) : v(_v), edges(_edges) { compile(); }",
            "",
            "   void add_edge(int u, int v, int w) {",
            "      edges.eb(u, v, w);",
            "   }",
            "",
            "   void add_edge(const Edge& edge) {",
            "      add_edge(edge.u, edge.v, edge.weight);",
            "   }",
            "",
            "   void compile() {",
            "      sum = 0;",
            "      graph.assign(v, vi());",
            "",
            "      sort(all(edges));",
            "      UnionFind ut(v);",
            "      for (auto& [u, v, w] : edges) {",
            "         if (!ut.equiv(u, v)) {",
            "            ut.unite(u, v);",
            "            sum += w;",
            "         }",
            "      }",
            "   }",
            "",
            "   int v;",
            "   int sum;",
            "   vvi graph;",
            "",
            "private:",
            "   vec<Edge> edges;",
            "};"
        ],
        "description": "最小全域木"
    },
    "ダイクストラ法": {
        "prefix": "dijkstra",
        "body": [
            "vi dist(len(${1:/* graph */}), oo);",
            "MinHeap<pair<int, int>> heap; // {dist, to}",
            "dist[${2:/* start */}] = 0;",
            "heap.emplace(dist[${2:/* start */}], ${2:/* start */});",
            "while (not heap.empty()) {",
            "   auto [d, now] = heap.top(); heap.pop();",
            "   if (dist[now] < d) continue;",
            "   for (auto& edge : ${1:/* graph */}[now]) {",
            "      int cost = dist[now] + edge.weight;",
            "      if (chmin(dist[edge.to], cost)) {",
            "         heap.emplace(cost, edge.to);",
            "      }",
            "   }",
            "}"
        ],
        "description": "ダイクストラ法"
    },
    "LowLink": {
        "prefix": "LowLink",
        "body": [
            "struct LowLink {",
            "   vec<int> aps;        // 関節点",
            "   vec<pii> bridges;  // 橋の集合",
            "",
            "   LowLink(const vec<vec<int>>& _graph) : graph(_graph) {",
            "       const int v = len(graph);",
            "       used.assign(v, 0);",
            "       ord.assign(v, 0);",
            "       low.assign(v, 0);",
            "       int k = 0;",
            "       rep (i, v) {",
            "           if (not used[i]) k = dfs(i, k, -1);",
            "       }",
            "       sort(all(aps));  // 必要ならソートする",
            "       sort(all(bridges)); // 必要ならソートする",
            "   }",
            "",
            "private:",
            "   const vec<vec<int>>& graph;",
            "   vec<int> used, ord, low;",
            "",
            "   int dfs(int id, int k, int par) { // id:探索中の頂点, k:dfsで何番目に探索するか, par:idの親",
            "       used[id] = true;",
            "       ord[id] = k++;",
            "       low[id] = ord[id];",
            "       bool is_aps = false;",
            "       int cnt = 0; // 子の数",
            "       for (int e : graph[id]) {",
            "           if (not used[e]) {",
            "               cnt++;",
            "               k = dfs(e, k, id);",
            "               chmin(low[id], low[e]);",
            "               if (par != -1 and ord[id] <= low[e]) is_aps = true; ",
            "               if (ord[id] < low[e]) bridges.eb(min(id, e), max(id, e)); // 条件を満たすので橋",
            "           } else if (e != par) { // eが後退辺の時",
            "               chmin(low[id], ord[e]);",
            "           }",
            "       }",
            "       if (par == -1 and cnt >= 2) is_aps = true; ",
            "       if (is_aps) aps.pb(id);",
            "       return k;",
            "   }",
            "};",
        ],
        "description": "橋と関節点を求める"
    },
    "最近共通祖先": {
        "prefix": "LCA",
        "body": [
            "struct LCA {",
            "   vvi parent;  // parent[k][u]:= u の 2^k 先の親",
            "   vi dist;     // root からの距離",
            "   LCA(const vvi& graph, int root = 0) {",
            "      int V = len(graph);",
            "      int K = 1;",
            "      while ((1 << K) < V) K++;",
            "      parent.assign(K, vi(V, -1));",
            "      dist.assign(V, -1);",
            "      auto dfs = [&](auto&& self, int v, int p, int d) -> void {",
            "         parent[0][v] = p;",
            "         dist[v] = d;",
            "         for (int u : graph[v]) {",
            "            if (u != p) self(self, u, v, d + 1);",
            "         }",
            "      };",
            "      dfs(dfs, root, -1, 0);",
            "      rep (k, K - 1) {",
            "         rep (v, V) {",
            "            if (parent[k][v] < 0) parent[k + 1][v] = -1;",
            "            else parent[k + 1][v] = parent[k][parent[k][v]];",
            "         }",
            "      }",
            "   }",
            "",
            "   int query(int u, int v) {",
            "      if (dist[u] < dist[v]) swap(u, v);",
            "      int K = len(parent);",
            "      rep (k, K) {",
            "         if ((dist[u] - dist[v]) >> k & 1) {",
            "            u = parent[k][u];",
            "         }",
            "      }",
            "      if (u == v) return u;",
            "      rrep (k, K) {",
            "         if (parent[k][u] != parent[k][v]) {",
            "            u = parent[k][u];",
            "            v = parent[k][v];",
            "         }",
            "      }",
            "      return parent[0][u];",
            "   }",
            "",
            "   int get_dist(int u, int v) { ",
            "      return dist[u] + dist[v] - 2*dist[query(u, v)];",
            "   }",
            "",
            "   bool is_on_path(int u, int v, int a) {",
            "      return get_dist(u, a) + get_dist(a, v) == get_dist(u, v);",
            "   }",
            "};"
        ],
        "description": "最近共通祖先"
    },
    "topological_sort": {
        "prefix": "topological_sort",
        "body": [
            "vi topological_sort(const vvi& graph) {",
            "   vi res;",
            "   int n = len(graph);",
            "   vi idx(n);",
            "   rep (i, n) {",
            "       for (int nxt : graph[i]) idx[nxt]++;",
            "   }",
            "   queue<int> que;",
            "   rep (i, n) {",
            "       if (idx[i] == 0) que.push(i);",
            "   }",
            "   while (not que.empty()) {",
            "       int now = que.front(); que.pop();",
            "       res.pb(now);",
            "       for (int nxt : graph[now]) {",
            "           idx[nxt]--;",
            "           if (idx[nxt] == 0) que.push(nxt);",
            "       }",
            "   }",
            "   return res;",
            "}",
        ],
        "description": "トポロジカルソート"
    },
    "強連結成分分解": {
        "prefix": [
            "StronglyConnectedComponents"
        ],
        "body": [
            "class StronglyConnectedComponents {",
            "public:",
            "   vvi graph;",
            "   vvi groups;",
            "   vi leader;",
            "",
            "   StronglyConnectedComponents(const vvi& _g)",
            "      : leader(len(_g), -1), n(len(_g)), g(_g), gg(len(_g)), rg(len(_g)), used(len(_g))",
            "   {",
            "      rep (i, n) for (int v : g[i]) {",
            "         gg[i].push_back(v);",
            "         rg[v].push_back(i);",
            "      }",
            "      build();",
            "   }",
            "",
            "   /**",
            "    * @brief 分解前の頂点 u と v について、同じ連結成分かどうか",
            "    */",
            "   bool same(int u, int v) const { ",
            "      assert(0 <= u and u < n);",
            "      assert(0 <= v and v < n);",
            "      return leader[u] == leader[v];",
            "   }",
            "",
            "   /**",
            "    * @brief 分解後のグラフのノードの数",
            "    */",
            "   int size() const {",
            "      return len(groups);",
            "   }",
            "",
            "   /**",
            "    * @brief 分解前の頂点 v について、所属している連結成分の大きさ",
            "    */",
            "   int size(int v) const {",
            "      assert(0 <= v and v < n);",
            "      return len(groups[leader[v]]);",
            "   }",
            "",
            "private:",
            "   int n;",
            "   const vvi& g;",
            "   vvi gg, rg;",
            "   vi order, used;",
            "",
            "   void dfs(int idx) {",
            "      if (used[idx]) return;",
            "      used[idx] = true;",
            "      for (int to : gg[idx]) dfs(to);",
            "      order.pb(idx);",
            "   }",
            "",
            "   void rdfs(int idx, int cnt) {",
            "      if (leader[idx] != -1) return;",
            "      leader[idx] = cnt;",
            "      for (int to : rg[idx]) rdfs(to, cnt);",
            "   }",
            "",
            "   void build() {",
            "      rep (i, len(gg)) dfs(i);",
            "      reverse(all(order));",
            "      int ptr = 0;",
            "      for (int i : order) if(leader[i] == -1) rdfs(i, ptr), ptr++;",
            "",
            "      if (not graph.empty()) graph.clear();",
            "      graph.resize(ptr);",
            "      groups.resize(ptr);",
            "      rep (i, n) {",
            "         groups[leader[i]].push_back(i);",
            "         for (int to : g[i]) {",
            "            int x = leader[i], y = leader[to];",
            "            if (x == y) continue;",
            "            graph[x].pb(y);",
            "         }",
            "      }",
            "   }",
            "};"
        ],
        "description": "強連結成分分解"
    },
    //─────────────────────────────────────────────────────────
    //  8. データ構造
    //─────────────────────────────────────────────────────────
    "phash": {
        "prefix": "phash",
        "body": [
            "struct phash {",
            "   inline size_t operator ()(const pair<int,int>& p) const {",
            "       const auto h1 = hash<int>()(p.first);",
            "       const auto h2 = hash<int>()(p.second);",
            "       return h1 ^ (h2 << 1);",
            "   }",
            "};",
        ],
        "description": "phash"
    },
    "mexset": {
        "prefix": "mexset",
        "body": [
            "template <class Type = int>",
            "struct mexset {",
            "   mexset() { ",
            "      s.emplace(numeric_limits<Type>::min(), numeric_limits<Type>::min());",
            "      s.emplace(numeric_limits<Type>::max(), numeric_limits<Type>::max());",
            "   }",
            "   mexset(Type inf, Type sup) { s.emplace(inf, inf), s.emplace(sup, sup); }",
            "",
            "   bool contains(const Type x) const {",
            "      auto it = prev(s.lower_bound({x + 1, x + 1}));",
            "      auto [l, u] = *it;",
            "      return l <= x && x <= u;",
            "   }",
            "",
            "   bool insert(const Type x) {",
            "      auto nit = s.lower_bound({x + 1, x + 1});",
            "      auto it = prev(nit);",
            "      auto [l, u] = *it;",
            "      auto [nl, nu] = *nit;",
            "      if (l <= x && x <= u) {",
            "         mset.insert(x);",
            "         return false;",
            "      }",
            "",
            "      if (u == x - 1) {",
            "         if (nl == x + 1) s.erase(it), s.erase(nit), s.emplace(l, nu);",
            "         else s.erase(it), s.emplace(l, x);",
            "      }",
            "      else {",
            "         if (nl == x + 1) s.erase(nit), s.emplace(x, nu);",
            "         else s.emplace(x, x);",
            "      }",
            "      return true;",
            "   }",
            "",
            "   bool erase(const Type x) {",
            "      auto it0 = mset.find(x);",
            "      if (it0 != mset.end()) {",
            "         mset.erase(it0);",
            "         return true;",
            "      }",
            "      auto it = prev(s.lower_bound({x + 1, x + 1}));",
            "      auto [l, u] = *it;",
            "      if (x < l || u < x) return false;",
            "",
            "      s.erase(it);",
            "      if (x == l and l < u) s.emplace(l + 1, u);",
            "      else if (x == u and l < u) s.emplace(l, u - 1);",
            "      else s.emplace(l, x - 1), s.emplace(x + 1, u);",
            "      return true;",
            "   }",
            "",
            "   Type mex(const Type inf = 0) const {",
            "      auto [l, u] = *prev(s.lower_bound({inf + 1, inf + 1}));",
            "      if (l <= inf && inf <= u) return u + 1;",
            "      else return inf;",
            "   }",
            "",
            "private:",
            "   set<pair<Type, Type>> s;",
            "   multiset<Type> mset;",
            "};"
        ],
        "description": "mexset"
    },
    "UnionFind": {
        "prefix": "UnionFind",
        "body": [
            "class UnionFind {",
            "public:",
            "   UnionFind() : _n(0) {}",
            "   UnionFind(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "   int unite(int a, int b) {",
            "      assert(0 <= a && a < _n);",
            "      assert(0 <= b && b < _n);",
            "      int x = leader(a), y = leader(b);",
            "      if (x == y) return x;",
            "      if (-parent_or_size[x] < -parent_or_size[y]) std::swap(x, y);",
            "      parent_or_size[x] += parent_or_size[y];",
            "      parent_or_size[y] = x;",
            "      return x;",
            "   }",
            "",
            "   bool equiv(int a, int b) {",
            "      assert(0 <= a && a < _n);",
            "      assert(0 <= b && b < _n);",
            "      return leader(a) == leader(b);",
            "   }",
            "",
            "   int leader(int a) {",
            "      assert(0 <= a && a < _n);",
            "      if (parent_or_size[a] < 0) return a;",
            "      return parent_or_size[a] = leader(parent_or_size[a]);",
            "   }",
            "",
            "   int size(int a) {",
            "      assert(0 <= a && a < _n);",
            "      return -parent_or_size[leader(a)];",
            "   }",
            "",
            "   vvi groups() {",
            "      vi leader_buf(_n), group_size(_n);",
            "      rep (i, _n) {",
            "         leader_buf[i] = leader(i);",
            "         group_size[leader_buf[i]]++;",
            "      }",
            "      vvi result(_n);",
            "      rep (i, _n) result[i].reserve(group_size[i]);",
            "      rep (i, _n) result[leader_buf[i]].pb(i);",
            "      result.erase(",
            "            remove_if(all(result), [&](const vi& v) { return v.empty(); }), result.end());",
            "      return result;",
            "   }",
            "",
            "private:",
            "   int _n;",
            "",
            "   // root node: -1 * component size",
            "   // otherwise: parent",
            "   vi parent_or_size;",
            "};"
        ],
        "description": "UnionFind"
    },
    "FenwickTree": {
        "prefix": "FenwickTree",
        "body": [
            "// 1-index",
            "struct FenwickTree {",
            "   int n;",
            "   vi bit;",
            "   FenwickTree(int _n) : n(_n), bit(n+1, 0) {}",
            "   FenwickTree(const vi& a) : n(len(a)), bit(len(a)+1, 0) {",
            "      rep (i, n) add(i+1, a[i]);",
            "   }",
            "",
            "   void add(int i, int x) {",
            "      assert(0 <= i and i <= n);",
            "      if (i == 0) return;",
            "      for (int k = i; k <= n; k += (k & -k)) bit[k] += x;",
            "   }",
            "",
            "   void set(int i, int x) {",
            "      assert(0 <= i and i <= n);",
            "      if (i == 0) return;",
            "      int a = get(i);",
            "      for (int k = i; k <= n; k += (k & -k)) bit[k] += x - a;",
            "   }",
            "",
            "   int sum(int i) {",
            "      assert(0 <= i and i <= n);",
            "      int s = 0;",
            "      if (i == 0) return s;",
            "      for (int k = i; k > 0; k -= (k & -k)) s+=bit[k];",
            "      return s;",
            "   }",
            "",
            "   int sum(int l, int r) {",
            "      return sum(r) - sum(l-1);",
            "   }",
            "",
            "   int get(int i) {",
            "      assert(0 <= i and i <= n);",
            "      return i == 0 ? 0 : sum(i) - sum(i-1);",
            "   }",
            "",
            "   int lower_bound(int x) {",
            "      if (x <= 0) return 0;",
            "      else {",
            "         int i = 0; int r = 1;",
            "         while (r < n) r <<= 1;",
            "         for (int dist = r; dist > 0; dist >>= 1) {",
            "            if (i + dist < n and bit[i + dist] < x) {",
            "               x -= bit[i + dist];",
            "               i += dist;",
            "            }",
            "         }",
            "         return i+1;",
            "      }",
            "   }",
            "};",
        ],
        "description": "フェニック木"
    },
    "FenwickTree2D": {
        "prefix": "FenwickTree2D",
        "body": [
            "template <typename T>",
            "struct FenwickTree2D {",
            "   int H, W;",
            "   vec<vec<T>> bit;  // データの格納先",
            "   FenwickTree2D(int H_, int W_) { init(H_, W_); }",
            "   void init(int H_, int W_) {",
            "       H = H_ + 1;",
            "       W = W_ + 1;",
            "       bit.assign(H, vec<T>(W, 0));",
            "   }",
            "   void add(int h, int w, T x) {",
            "       for (int i = h; i < H; i += (i & -i)) {",
            "           for (int j = w; j < W; j += (j & -j)) {",
            "               bit[i][j] += x;",
            "           }",
            "       }",
            "   }",
            "   // 1≦i≦h かつ 1≦j≦w",
            "   T sum(int h, int w) {",
            "       T s(0);",
            "       for (int i = h; i > 0; i -= (i & -i)) {",
            "           for (int j = w; j > 0; j -= (j & -j)) {",
            "               s += bit[i][j];",
            "           }",
            "       }",
            "       return s;",
            "   }",
            "   // h1≦i<h2 かつ w1≦j<w2",
            "   T query(int h1, int w1, int h2, int w2) {",
            "       return sum(h2 - 1, w2 - 1) - sum(h2 - 1, w1 - 1) - sum(h1 - 1, w2 - 1) + sum(h1 - 1, w1 - 1);",
            "   }",
            "};",
        ],
        "description": "FenwickTree (二次元バージョン)"
    },
    "inversion_number": {
        "prefix": "inversion_number",
        "body": [
            "int inversion_number(const vi& v) {",
            "   const int n = len(v);",
            "   FenwickTree fw(n);",
            "   int ret = 0;",
            "   rep (i, n) {",
            "       ret += i - fw.sum(v[i]);",
            "       fw.add(v[i], 1);",
            "   }",
            "   return ret;",
            "}",
        ],
        "description": "転倒数を求める"
    },
    "SegmentTree": {
        "prefix": "SegmentTree",
        "body": [
            "template <class Monoid, class Mapping>",
            "struct SegmentTree {",
            "   SegmentTree() = default;",
            "   SegmentTree(int n) : SegmentTree(vec<Monoid>(n, Monoid::e())) {}",
            "   SegmentTree(const vec<Monoid>& v) : _n(len(v)) {",
            "      n_leaves = 1;",
            "      while (_n > n_leaves) n_leaves <<= 1;",
            "      val.resize(2*n_leaves, Monoid::e());",
            "      lazy.resize(2*n_leaves, Mapping::id());",
            "      rep (i, _n) val[i + n_leaves - 1] = v[i];",
            "      rrep (p, n_leaves - 1) update(p);",
            "   }",
            "",
            "   void apply(int l, int r, Mapping f) {",
            "      assert(0 <= l and l < r and r <= _n);",
            "      apply_rec(l, r, f, 0, 0, n_leaves);",
            "   }",
            "",
            "   Monoid prod(int l, int r) {",
            "      assert(0 <= l and l < r and r <= _n);",
            "      return prod_rec(l, r, 0, 0, n_leaves);",
            "   }",
            "",
            "private:",
            "   int _n, n_leaves;",
            "   vec<Monoid> val;",
            "   vec<Mapping> lazy;",
            "",
            "   void update(int p) {",
            "      val[p] = val[2*p + 1] * val[2*p + 2];",
            "   }",
            "",
            "   void eval(int p) {",
            "      if (lazy[p].is_id()) return;",
            "",
            "      if (p < n_leaves - 1) {",
            "         lazy[2*p + 1] = lazy[2*p + 1] * lazy[p];",
            "         lazy[2*p + 2] = lazy[2*p + 2] * lazy[p];",
            "      }",
            "",
            "      val[p] = lazy[p] * val[p];",
            "      lazy[p] = Mapping::id();",
            "   }",
            "",
            "   void apply_rec(int a, int b, Mapping f, int p, int l, int r) {",
            "      eval(p);",
            "      if (a <= l and r <= b) {",
            "         lazy[p] = f;",
            "         eval(p);",
            "      }",
            "      else if (b > l and r > a) {",
            "         apply_rec(a, b, f, 2*p + 1, l, (l + r) / 2);",
            "         apply_rec(a, b, f, 2*p + 2, (l + r) / 2, r);",
            "         update(p);",
            "      }",
            "   }",
            "",
            "   Monoid prod_rec(int a, int b, int p, int l, int r) {",
            "      eval(p);",
            "      if (b <= l or r <= a) {",
            "         return Monoid::e();",
            "      }",
            "      else if (a <= l and r <= b) {",
            "         return val[p];",
            "      }",
            "      else {",
            "         Monoid vl = prod_rec(a, b, 2*p + 1, l, (l + r) / 2);",
            "         Monoid vr = prod_rec(a, b, 2*p + 2, (l + r) / 2, r);",
            "         return vl * vr;",
            "      }",
            "   }",
            "};",
            "",
            "struct Monoid {",
            "   int val;",
            "   static Monoid e() { return Monoid{0}; }",
            "};",
            "Monoid operator *(const Monoid& a, const Monoid& b) { return Monoid{gcd(a.val, b.val)}; }",
            "struct Mapping {",
            "   int val;",
            "   static Mapping id() { return Mapping{0}; }",
            "   bool is_id() const { return val == id().val; }",
            "};",
            "Mapping operator *(const Mapping& f, const Mapping& g) { return Mapping{f.val}; }",
            "Monoid operator *(const Mapping& f, const Monoid& x) { return Monoid{f.is_id() ? x.val : f.val}; }",
            ""
        ],
        "description": "SegmentTree"
    },
    "TreeList": {
        "prefix": "TreeList",
        "body": [
            "# include <ext/pb_ds/assoc_container.hpp>",
            "# include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "using TreeList = tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>;"
        ],
        "description": "TreeList"
    },
    //─────────────────────────────────────────────────────────
    //  9. 数学
    //─────────────────────────────────────────────────────────
    "floor_sqrt": {
        "prefix": "floor_sqrt",
        "body": [
            "constexpr int floor_sqrt(int n) {",
            "   if (n <= 1) return n;",
            "   int r = sqrt(n);",
            "   do r = (r & n / r) + (r ^ n / r) / 2; while (r > n / r);",
            "   return r;",
            "}"
        ]
    },
    "Sum": {
        "prefix": "sum",
        "body": [
            "accumulate(all(${1:v}), int(0))"
        ]
    },
    "Product": {
        "prefix": "prod",
        "body": [
            "accumulate(all(${1:v}), int(1), [](int acc, int x){ return acc * x; })"
        ]
    },
    "二項係数": {
        "prefix": [
            "Combination",
            "nchoosek"
        ],
        "body": [
            "struct Combination {",
            "   vec<mint> fact, ifact;",
            "   Combination(int n) : fact(n + 1), ifact(n + 1) {",
            "      assert(n < mint::mod());",
            "      fact[0] = 1;",
            "      reps (i, n) fact[i] = fact[i-1] * i;",
            "      ifact[n] = fact[n].inv();",
            "      rreps (i, n) ifact[i-1] = ifact[i] * i;",
            "   }",
            "   mint operator()(int n, int k) {",
            "      if (k < 0 or k > n) return 0;",
            "      return fact[n] * ifact[k] * ifact[n - k];",
            "   }",
            "} nchoosek(1e6 + 1);"
        ],
        "description": "二項係数"
    },
    "dydx4": {
        "prefix": "dydx4",
        "body": [
            "constexpr array<pair<int, int>, 4> dydx4 = {{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}};",
        ],
        "description": "4近傍"
    },
    "dydx8": {
        "prefix": "dydx8",
        "body": [
            "constexpr array<pair<int, int>, 8> dydx8 = {{",
            "   {1, 0}, {0, 1}, {-1, 0}, {0, -1},",
            "   {1, 1}, {-1, -1}, {-1, 1}, {1, -1},",
            "}};",
        ],
        "description": "8近傍"
    },
    "約数を列挙する": {
        "prefix": "divisor",
        "body": [
            "vi divisor(int n) {",
            "   vi v;",
            "   for (int i = 1; i*i <= n; i++) {",
            "       if (n % i == 0) {",
            "           v.pb(i);",
            "           if (i*i != n) v.pb(n / i);",
            "       }",
            "   }",
            "   sort(all(v));",
            "   return v;",
            "}",
        ],
        "description": "約数列挙"
    },
    "素数系ライブラリ": {
        "prefix": "Prime",
        "body": [
            "struct Prime {",
            "   Prime() : n_max(0) {}",
            "   // O ( N loglog(N) )",
            "   Prime(int n) : n_max(n), table(n+1, true), osak(n+1) {",
            "       iota(osak.begin(), osak.end(), 0);",
            "       osak[0] = 1;",
            "       if (n >= 0) table[0] = false;",
            "       if (n >= 1) table[1] = false;",
            "       for (int i = 2; i * i <= n; i++) {",
            "           if (not table[i]) continue;",
            "           for(int k = i + i; k <= n; k += i) {",
            "               table[k] = false;",
            "               osak[k] = i;",
            "           }",
            "       }",
            "       reps (i, 2, n) if (table[i]) lst.pb(i);",
            "   }",
            "",
            "   // n <= n_max のとき: O(1)",
            "   // それ超えのとき: O( sqrt(N) )",
            "   bool is(const int n) {",
            "       if (n <= n_max) return table[n];",
            "       if (n <= 4) return n == 2 || n == 3;",
            "       if (n % 2 == 0 || n % 3 == 0 || (n % 6 != 1 && n % 6 != 5)) return false;",
            "       for (int i = 5; i * i <= n; i += 6) if (n % i == 0 || n % (i + 2) == 0) return false;",
            "       return true;",
            "   }",
            "",
            "   // O( sqrt(N) )",
            "   map<int, int> factor(int n) {",
            "       if (n == 1) {",
            "           map<int, int> one;",
            "           one[1] = 1;",
            "           return one;",
            "       }",
            "       if (n <= n_max) return impl_factor_fast(n);",
            "       map<int, int> ret;",
            "       for (int i = 2; i * i <= n; i++) {",
            "           while (n % i == 0) {",
            "               ret[i]++;",
            "               n /= i;",
            "           }",
            "       }",
            "       if (n != 1) ret[n] = 1;",
            "       return ret;",
            "   }",
            "",
            "   // O( log(N) )",
            "   map<int, int> impl_factor_fast(int n) {",
            "       map<int, int> ret;",
            "       while (n != 1) {",
            "           int p = osak[n];",
            "           ret[p]++;",
            "           n /= p;",
            "       }",
            "       return ret;",
            "   }",
            "",
            "   // O( len(v) log(v_max) )",
            "   bool to(vi v) {",
            "       unordered_set<int> s;",
            "       for (auto& n : v) {",
            "           while (n != 1) {",
            "               int p = osak[n];",
            "               if (s.count(p)) return false;",
            "               else s.insert(p);",
            "               while (n % p == 0) n /= p;",
            "           }",
            "       }",
            "       return true;",
            "   }",
            "",
            "   const int n_max;",
            "   vb table;",
            "   vi osak;",
            "   vi lst;",
            "} PRIME(1e7);",
        ],
        "description": "素数系ライブラリ"
    },
    "modint": {
        "prefix": "mint",
        "body": [
            "using mint = atcoder::${1|modint998244353,modint1000000007|};",
            "istream& operator >>(istream& is, mint& r){ int t; is >> t; r = t; return is; }",
            "ostream& operator <<(ostream& os, const mint& r){ return os << r.val(); }",
            "mint operator\"\" _mod_(unsigned long long n) { return n; }",
            "using vm = vec<mint>;",
            "using vvm = vec<vm>;",
            "using vvvm = vec<vvm>;"
        ],
        "description": "mint / modint"
    },
    "分数": {
        "prefix": "Fraction",
        "body": [
            "struct Fraction {",
            "   // コンストラクタ",
            "   Fraction() : m_num(0), m_den(1) {}",
            "   Fraction(int n) : m_num(n), m_den(1) {}",
            "   Fraction(int n, int d) : m_num(n), m_den(d) { reduce(); m_num *= abs(m_den) / m_den; m_den = abs(m_den); }",
            "   Fraction(const string& s) {",
            "      auto pos = s.find_first_of('.');",
            "      if (pos == string::npos) *this = Fraction(stoll(s));",
            "      else {",
            "         int d = 1;",
            "         int ten = 10;",
            "         for (int m = len(s) - 1 - pos; m > 0; m >>= 1) {",
            "            if (m & 1) d *= ten;",
            "            ten *= ten;",
            "         }",
            "         int n = 0;",
            "         for (char c : s) if (c != '.') n = 10*n + c - '0';",
            "         *this = Fraction(n, d);",
            "      }",
            "   }",
            "",
            "   // 代入操作",
            "   Fraction& operator =(int n) { m_num = n, m_den = 1; return *this; }",
            "   Fraction& assign(int n, int d) { m_num = n, m_den = d; return *this; }",
            "",
            "   // ゲッター",
            "   constexpr int num() const { return m_num; }",
            "   constexpr int den() const { return m_den; }",
            "   Fraction inv() const { return Fraction(m_den, m_num); }",
            "",
            "   // 分数同士の四則演算",
            "   Fraction& operator +=(const Fraction& f){ int l = m_den != 0 and f.m_den != 0 ? lcm(m_den, f.m_den) : 1; *this = Fraction(m_num*(l / m_den) + f.m_num*(l / f.m_den), l); return *this; }",
            "   Fraction& operator -=(const Fraction& f){ int l = m_den != 0 and f.m_den != 0 ? lcm(m_den, f.m_den) : 1; *this = Fraction(m_num*(l / m_den) - f.m_num*(l / f.m_den), l); return *this; }",
            "   Fraction& operator *=(const Fraction& f){ int g1 = gcd(m_den, f.m_num), g2 = gcd(m_num, f.m_den); *this = Fraction((m_num / g2)*(f.m_num / g1), (m_den / g1)*(f.m_den / g2)); return *this; }",
            "   Fraction& operator /=(const Fraction& f){ int g1 = gcd(m_den, f.m_den), g2 = gcd(m_num, f.m_num); *this = Fraction((m_num / g2)*(f.m_den / g1), (m_den / g1)*(f.m_num / g2)); return *this; }",
            "",
            "   friend Fraction operator +(const Fraction& a, const Fraction& b) { return Fraction(a) += b; }",
            "   friend Fraction operator -(const Fraction& a, const Fraction& b) { return Fraction(a) -= b; }",
            "   friend Fraction operator *(const Fraction& a, const Fraction& b) { return Fraction(a) *= b; }",
            "   friend Fraction operator /(const Fraction& a, const Fraction& b) { return Fraction(a) /= b; }",
            "",
            "   // 整数型との四則演算",
            "   Fraction& operator +=(const int n){ *this = Fraction(m_num + m_den*n, m_den); return *this; }",
            "   Fraction& operator -=(const int n){ *this = Fraction(m_num - m_den*n, m_den); return *this; }",
            "   Fraction& operator *=(const int n){ *this = Fraction(m_num*n, m_den); return *this; }",
            "   Fraction& operator /=(const int n){ *this = Fraction(m_num, m_den*n); return *this; }",
            "",
            "   friend Fraction operator +(const int n, const Fraction& f) { return Fraction(n) += f; }",
            "   friend Fraction operator -(const int n, const Fraction& f) { return Fraction(n) -= f; }",
            "   friend Fraction operator *(const int n, const Fraction& f) { return Fraction(n) *= f; }",
            "   friend Fraction operator /(const int n, const Fraction& f) { return Fraction(n) /= f; }",
            "",
            "   friend Fraction operator +(const Fraction& f, const int n) { return Fraction(f) += Fraction(n); }",
            "   friend Fraction operator -(const Fraction& f, const int n) { return Fraction(f) -= Fraction(n); }",
            "   friend Fraction operator *(const Fraction& f, const int n) { return Fraction(f) *= Fraction(n); }",
            "   friend Fraction operator /(const Fraction& f, const int n) { return Fraction(f) /= Fraction(n); }",
            "",
            "",
            "   // 単項演算子",
            "   Fraction operator -() const { return Fraction(-m_num, m_den); }",
            "   Fraction operator +() const { return *this; }",
            "",
            "   // インクリメントとデクリメント",
            "   const Fraction& operator ++() { *this = Fraction(m_num + m_den, m_den); return *this; }",
            "   const Fraction& operator --() { *this = Fraction(m_num - m_den, m_den); return *this; }",
            "",
            "   Fraction operator ++(int32_t) { Fraction res = *this; ++*this; return res; }",
            "   Fraction operator --(int32_t) { Fraction res = *this; --*this; return res; }",
            "",
            "   // 否定演算",
            "   bool operator !() const noexcept { return !m_num; }",
            "",
            "   // 比較演算",
            "   friend bool operator <(const Fraction& a, const Fraction& b) { return a.m_num * b.m_den < a.m_den * b.m_num; }",
            "   friend bool operator >(const Fraction& a, const Fraction& b) { return b < a; }",
            "   friend bool operator <=(const Fraction& a, const Fraction& b) { return !(a > b); }",
            "   friend bool operator >=(const Fraction& a, const Fraction& b) { return !(a < b); }",
            "",
            "   friend bool operator ==(const Fraction& a, const Fraction& b) { return a.m_num == b.m_num and a.m_den == b.m_den; }",
            "   friend bool operator !=(const Fraction& a, const Fraction& b) { return !(a == b); }",
            "",
            "   // 絶対値",
            "   friend Fraction abs(const Fraction& f) { return Fraction(abs(f.m_num), f.m_den); }",
            "",
            "   // 入出力",
            "   friend istream& operator >>(istream& is, Fraction& f){ int n, d; f = Fraction(n, d); return is; }",
            "   // friend ostream& operator <<(ostream& os, const Fraction& f){ return os << \"frac{\" << f.num() << \"}{\" << f.den() << \"}\"; }",
            "   friend ostream& operator <<(ostream& os, const Fraction& f){ ",
            "      if (f.den() == 1) return os << f.num();",
            "      else return os << \"(\" << f.num() << \"/\" << f.den() << \")\";",
            "   }",
            "",
            "   // キャスト変換",
            "   operator double() const { return double(m_num) / m_den; }",
            "   operator float() const { return double(m_num) / m_den; }",
            "   operator int() const { return m_num / m_den; }",
            "",
            "private:",
            "   int m_num, m_den;",
            "   bool reduce() {",
            "      if (m_num == 0) {",
            "         m_den = 1;",
            "         return false;",
            "      }",
            "      else if (m_den == 0) {",
            "         m_num = 1;",
            "         return false;",
            "      }",
            "      else {",
            "         int g = gcd(m_num, m_den);",
            "         m_num /= g;",
            "         m_den /= g;",
            "         return g != 1;",
            "      }",
            "   }",
            "};"
        ],
        "description": "分数"
    },
    "行列": {
        "prefix": "Matrix",
        "body": [
            "template <class T>",
            "struct Matrix {",
            "   // コンストラクタ",
            "   Matrix() : m(vec<vec<T>>()) {}",
            "   Matrix(int n) : m(vec<vec<T>>(n, vec<T>(n))) {}",
            "   Matrix(int h, int w) : m(vec<vec<T>>(h, vec<T>(w, 0))) {}",
            "   Matrix(int h, int w, T d) : m(vec<vec<T>>(h, vec<T>(w, d))){}",
            "   Matrix(const vec<vec<T>>& _m) : m(_m){}",
            "",
            "   // 単位行列",
            "   const static Matrix Identity(const int n) {",
            "      Matrix mat(n);",
            "      rep (i, n) mat[i][i] = T(1);",
            "      return mat;",
            "   }",
            "",
            "   // 要素アクセス",
            "   vec<T> operator[](const int i) const { return m[i]; }",
            "   vec<T>& operator[](const int i) { return m[i]; }",
            "   T operator ()(const int i, const int j) const { return m[i][j]; }",
            "   T& operator ()(const int i, const int j) { return m[i][j]; }",
            "",
            "   // ゲッター",
            "   [[nodiscard]] constexpr int n_rows() const { return len(m); }",
            "   [[nodiscard]] constexpr int n_cols() const { return len(m[0]); }",
            "",
            "   // 行・列の拡張",
            "   void resize(const int h, const int w) { m.resize(h, w, T()); }",
            "   void push_back_row(const vec<T>& v) { m.push_back(v); }",
            "   void push_back_col(const vec<T>& v) { rep (i, n_rows()) m[i].push_back(v[i]); }",
            "   void pop_back_row() { m.pop_back(); }",
            "   void pop_back_col() { rep (i, n_rows()) m[i].pop_back(); }",
            "",
            "   // 四則演算とべき乗",
            "   Matrix& operator +=(const Matrix& other) {",
            "      const int r = n_rows();",
            "      const int c = n_cols();",
            "      assert(r == other.n_rows() and c == other.n_cols());",
            "      rep (i, r) rep (j, c) (*this)(i, j) += other(i, j);",
            "      return *this;",
            "   }",
            "   Matrix& operator -=(const Matrix& other) {",
            "      const int r = n_rows();",
            "      const int c = n_cols();",
            "      assert(r == other.n_rows() and c == other.n_cols());",
            "      rep (i, r) rep (j, c) (*this)(i, j) -= other(i, j);",
            "      return *this;",
            "   }",
            "   Matrix& operator *=(const Matrix& other) {",
            "      const int r = n_rows(), c = other.n_cols(), p = n_cols();",
            "      assert(p == other.n_rows());",
            "      vec<vec<T>> v(r, vec<T>(c, T(0)));",
            "      rep (i, r) rep (j, c) rep (k, p) v[i][j] = (v[i][j] + (*this)(i, k) * other(k, j));",
            "      m.swap(v);",
            "      return *this;",
            "   }",
            "   Matrix& operator ^=(int n) {",
            "      Matrix res = Matrix::Identity(n_rows());",
            "      Matrix x = *this;",
            "      while (n > 0) {",
            "         if (n & 1) res *= x;",
            "         x *= x;",
            "         n >>= 1;",
            "      }",
            "      swap(m, res.m);",
            "      return *this;",
            "   }",
            "",
            "   friend Matrix operator +(const Matrix& a, const Matrix& b) { return Matrix(a) += b; }",
            "   friend Matrix operator -(const Matrix& a, const Matrix& b) { return Matrix(a) -= b; }",
            "   friend Matrix operator *(const Matrix& a, const Matrix& b) { return Matrix(a) *= b; }",
            "   friend Matrix operator ^(const Matrix& a, const int n) { return Matrix(a) ^= n; }",
            "",
            "   // スカラー倍",
            "   Matrix& operator *=(T k) { rep (i, n_rows()) rep (j, n_cols()) (*this)(i, j) *= k; return *this; }",
            "   Matrix& operator /=(T k) { rep (i, n_rows()) rep (j, n_cols()) (*this)(i, j) /= k; return *this; }",
            "   friend Matrix operator *(const Matrix& a, const int b) { return Matrix(a) *= b; }",
            "   friend Matrix operator *(const int a, const Matrix& b) { return Matrix(b) *= a; }",
            "   friend Matrix operator /(const Matrix& a, const int b) { return Matrix(a) /= b; }",
            "",
            "   // 単項演算子",
            "   Matrix operator -() const { Matrix mat; rep (i, n_rows()) rep (j, n_cols()) mat(i, j) = -*this(i, j); return mat; }",
            "   Matrix operator +() const { return *this; }",
            "",
            "   // 累乗",
            "   Matrix pow(int n) { return (*this) ^ n; }",
            "   friend Matrix pow(const Matrix& mat, int n) { return mat.pow(n); }",
            "",
            "   // 行列式 （T型が体であるときのみ対応）",
            "   T det() {",
            "      assert(n_rows() == n_cols());",
            "      Matrix mat(*this);",
            "      T ret = 1;",
            "      rep (i, n_cols()) {",
            "         int idx = -1;",
            "         rep (j, i, n_cols()) {",
            "            if (mat(j, i) != T(0)) idx = j;",
            "         }",
            "         if (idx == -1) return 0;",
            "         if (i != idx) {",
            "            ret *= -1;",
            "            swap(mat[i], mat[idx]);",
            "         }",
            "         ret *= mat(i, i);",
            "         T v = mat(i, i);",
            "         rep (j, n_cols()) mat(i, j) /= v;",
            "         rep (j, i + 1, n_cols()) {",
            "            T a = mat(j, i);",
            "            rep (k, n_cols()) mat(j, k) -= mat(i, k) * a;",
            "         }",
            "      }",
            "      return ret;",
            "   }",
            "   friend T det(const Matrix& mat) { return mat.det(); }",
            "",
            "   // 逆行列",
            "   Matrix inv() {",
            "      Matrix mat = *this;",
            "      int n = mat.n_rows();",
            "      assert(n == mat.n_cols());",
            "      Matrix res = Matrix::Identity(n);",
            "      int rank = 0;",
            "      rep (j, n) {",
            "         int pivot = -1;",
            "         T mx = 0;",
            "         rep (i, rank, n) if (chmax(mx, abs(mat(i, j)))) pivot = i;",
            "         if (pivot == -1) continue;",
            "",
            "         swap(mat[pivot], mat[rank]);",
            "         swap(res[pivot], res[rank]);",
            "",
            "         auto fac = mat(rank, j);",
            "         rep (k, n) {",
            "            mat(rank, k) /= fac;",
            "            res(rank, k) /= fac;",
            "         }",
            "",
            "         rep (i, n) {",
            "            if (i != rank and abs(mat(i, j)) > T(0)) {",
            "               auto fac = mat(i, j);",
            "               rep (k, n) {",
            "                  mat(i, k) -= mat(rank, k) * fac;",
            "                  res(i, k) -= res(rank, k) * fac;",
            "               }",
            "            }",
            "         }",
            "         ++rank;",
            "      }",
            "      return res;",
            "   }",
            "   friend T inv(const Matrix& mat) { return mat.inv(); }",
            "",
            "   // 対角行列",
            "   friend Matrix diag(const vec<T>& v) {",
            "      const int n = len(v);",
            "      Matrix mat(n, n);",
            "      rep (i, n) mat[i][i] = v[i];",
            "      return mat;",
            "   }",
            "",
            "   // 掃き出し法",
            "   //! @param is_extended 拡大係数行列か",
            "   friend int sweep(Matrix& mat, bool is_extended = false) {",
            "      int r = mat.n_rows(), c = mat.n_cols();",
            "      int rank = 0;",
            "      rep (j, c) {",
            "         if (is_extended and j == c - 1) break;",
            "",
            "         int pivot = -1;",
            "         T mx = 0;",
            "         rep (i, rank, r) if (chmax(mx, abs(mat(i, j)))) pivot = i;",
            "         if (pivot == -1) continue;",
            "",
            "         swap(mat[pivot], mat[rank]);",
            "",
            "         auto fac = mat(rank, j);",
            "         rep (k, c) mat(rank, k) /= fac;",
            "",
            "         rep (i, r) {",
            "            if (i != rank and abs(mat(i, j)) > T(0)) {",
            "               auto fac = mat(i, j);",
            "               rep (k, c) mat(i, k) -= mat(rank, k) * fac;",
            "            }",
            "         }",
            "         ++rank;",
            "      }",
            "      return rank;",
            "   }",
            "",
            "   // 入出力",
            "   friend istream& operator >>(istream& is, Matrix& mat){ rep (i, mat.n_rows()) rep (j, mat.n_cols()) is >> mat(i, j); return is; }",
            "   friend ostream& operator <<(ostream& os, const Matrix& mat){ rep (i, mat.n_rows()) rep (j, mat.n_cols()) os << mat(i, j) << \" \\n\"[j == mat.n_cols() - 1]; return os; }",
            "",
            "private:",
            "   vec<vec<T>> m;",
            "};"
        ],
        "description": "行列"
    },
    //─────────────────────────────────────────────────────────
    //  10. 二分探索・二分法
    //─────────────────────────────────────────────────────────
    "二分探索": {
        "prefix": "binary_chop",
        "body": [
            "template <class T, class F>",
            "T binary_chop(T ac, T wa, const F& f) {",
            "   while (abs(ac - wa) > 1) {",
            "      T wj = (ac + wa) >> 1;",
            "      (f(wj) ? ac : wa) = wj;",
            "   }",
            "   return ac;",
            "}"
        ],
        "description": "二分探索"
    },
    "二分法": {
        "prefix": "bisect",
        "body": [
            "template <class T, class F>",
            "T bisect(T ac, T wa, const F& f, int ts = 628) {",
            "   while (ts--) {",
            "      T wj = (ac + wa) / 2;",
            "      (f(wj) ? ac : wa) = wj;",
            "   }",
            "   return ac;",
            "}"
        ],
        "description": "二分法"
    },
    "lower_bound_index": {
        "prefix": "lb",
        "body": [
            "distance(begin(${1:v}), lower_bound(all(${1:v}), ${2:x}))",
        ],
        "description": "lower_bound_index"
    },
    "upper_bound_index": {
        "prefix": "ub",
        "body": [
            "distance(begin(${1:v}), upper_bound(all(${1:v}), ${2:x}))",
        ],
        "description": "upper_bound_index"
    },
    //─────────────────────────────────────────────────────────
    //  11. 動的計画法
    //─────────────────────────────────────────────────────────
    "部分和問題": {
        "prefix": "subset_sum",
        "body": [
            "db subset_sum(const vi& a, int K) {",
            "   db dp(K+1, false);",
            "   dp[0] = true;",
            "   for (const auto& e : a) {",
            "      for (int k = K; k >= e; --k) {",
            "         dp[k] |= dp[k - e];",
            "      }",
            "   }",
            "   return dp;",
            "}"
        ],
        "description": "部分和問題"
    },
    //─────────────────────────────────────────────────────────
    //  12. ビット操作
    //─────────────────────────────────────────────────────────
    "ビット演算": {
        "prefix": "BitOperations",
        "body": [
            "namespace BitOperations {",
            "   constexpr int Popcount(int x) { return __builtin_popcountll(x); }",
            "   constexpr int Parity(int x) { return __builtin_parityll(x); }",
            "   constexpr int Ffs(int x) { return __builtin_ffsll(x); }",
            "   constexpr int Clz(int x) { return __builtin_clzll(x); }",
            "   constexpr int Ctz(int x) { return __builtin_ctzll(x); }",
            "",
            "   constexpr int Bit(int x) { return 1LL << x; }",
            "   constexpr bool Isbit(int x) { return x and (x & -x) == x; }",
            "   constexpr int Msb(int x) { return x == 0 ? -1 : 63 - Clz(x); }",
            "   constexpr int Lsb(int x) { return x == 0 ? 64 : Ctz(x); }",
            "   constexpr int Allbit(int n) { return (1LL << n) - 1; }",
            "   constexpr bool Stand(int x, int i) { return x & Bit(i); }",
            "   constexpr int Log2i(int x) { return Msb(x); }",
            "}",
            "using namespace BitOperations;"
        ],
        "description": "ビット演算"
    },
    //─────────────────────────────────────────────────────────
    //  13. 高速化
    //─────────────────────────────────────────────────────────
    "入出力の高速化": {
        "prefix": "Setup_io",
        "body": [
            "struct Setup_io {",
            "   Setup_io() {",
            "      ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);",
            "      cout << fixed << setprecision(15);",
            "   }",
            "} setup_io;",
        ],
        "description": "入出力最適化"
    },
    //─────────────────────────────────────────────────────────
    //  14. コメントアウト
    //─────────────────────────────────────────────────────────
    "guide": {
        "prefix": "guide",
        "body": [
            "// ────────────────────────────────",
            "//  ${1:section}. ${2:message}",
            "// ────────────────────────────────"
        ],
        "description": "guide"
    },
    //─────────────────────────────────────────────────────────
    //  99. テンプレート
    //─────────────────────────────────────────────────────────
    "ifnonline": {
        "prefix": "ifnonline",
        "body": [
            "# ifndef ONLINE_JUDGE",
            "# endif",
        ],
        "description": "オンラインジャッジ環境かを判定"
    }
}